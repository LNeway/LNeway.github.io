<!doctype html>



  


<html class="theme-next muse use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta property="og:type" content="website">
<meta property="og:title" content="Learning">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Learning">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Learning">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/"/>





  <title>Learning</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="">

  















  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Learning</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Startseite
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archiv
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/01/22/Android中的状态保存/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Tom Liu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Learning">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/01/22/Android中的状态保存/" itemprop="url">Android中的状态保存</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-01-22T23:07:38+08:00">
                2017-01-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在Android中，当我们的Acitivity 被系统干掉的时候，会给我们一次保存数据的机会，我们通过可以通过这个机会来将需要的数据保存下来，然后在用户从新打开APP的时候，把这个数据恢复。</p>
<p>先来看一下Activity是怎么保存数据的 </p>
<p>先来看一下onSaveInstanceState()方法 </p>
<pre><code>protected void onSaveInstanceState(Bundle outState) {
    outState.putBundle(WINDOW_HIERARCHY_TAG, mWindow.saveHierarchyState());
    Parcelable p = mFragments.saveAllState();
    if (p != null) {
        outState.putParcelable(FRAGMENTS_TAG, p);
    }
    getApplication().dispatchActivitySaveInstanceState(this, outState);
}
</code></pre><p>代码非常的简单，保存了3个对象的状态，分别是mWindow, mFragments和 Application 对象<br>mWindow的实际实现对象是PhoneWindow, 我们进入到 saveHierarchyState() 方法看看 </p>
<pre><code>    /** {@inheritDoc} */
@Override
public Bundle saveHierarchyState() {
    Bundle outState = new Bundle();
    if (mContentParent == null) {
        return outState;
    }

    SparseArray&lt;Parcelable&gt; states = new SparseArray&lt;Parcelable&gt;();
    mContentParent.saveHierarchyState(states);
    outState.putSparseParcelableArray(VIEWS_TAG, states);

    // Save the focused view ID.
    final View focusedView = mContentParent.findFocus();
    if (focusedView != null &amp;&amp; focusedView.getId() != View.NO_ID) {
        outState.putInt(FOCUSED_ID_TAG, focusedView.getId());
    }

    // save the panels
    SparseArray&lt;Parcelable&gt; panelStates = new SparseArray&lt;Parcelable&gt;();
    savePanelState(panelStates);
    if (panelStates.size() &gt; 0) {
        outState.putSparseParcelableArray(PANELS_TAG, panelStates);
    }

    if (mDecorContentParent != null) {
        SparseArray&lt;Parcelable&gt; actionBarStates = new SparseArray&lt;Parcelable&gt;();
        mDecorContentParent.saveToolbarHierarchyState(actionBarStates);
        outState.putSparseParcelableArray(ACTION_BAR_TAG, actionBarStates);
    }
    return outState;
}
</code></pre><p>首先是尝试去保存 mContentParent 的状态， 这个mContentParent 实际上就是在DecorView中 id 为 content的 ViewGroup, 我们setContetnView中添加的View就是放在了它的下面。mContentParent 是FrameLayout， 最终类型就是ViewGroup。先看看ViewGroup的父类 View怎么实现 saveHierarchyState .saveHierarchyState 调用了 dispatchSaveInstanceState，而这个方法是View中的方法，</p>
<pre><code>protected void dispatchSaveInstanceState(SparseArray&lt;Parcelable&gt; container) {
    if (mID != NO_ID &amp;&amp; (mViewFlags &amp; SAVE_DISABLED_MASK) == 0) {
        mPrivateFlags &amp;= ~PFLAG_SAVE_STATE_CALLED;
        Parcelable state = onSaveInstanceState();
        if ((mPrivateFlags &amp; PFLAG_SAVE_STATE_CALLED) == 0) {
            throw new IllegalStateException(
                    &quot;Derived class did not call super.onSaveInstanceState()&quot;);
        }
        if (state != null) {
            // Log.i(&quot;View&quot;, &quot;Freezing #&quot; + Integer.toHexString(mID)
            // + &quot;: &quot; + state);
            container.put(mID, state);
        }
    }
}
</code></pre><p>实际上就是把onSaveInstanceState 放的返回值 保存了起来，在这里我们可以看到，这里是根据mID 也就是我们在布局文件为View指定的id来保存状态的，同时因为 SparseArray 是一个key ,value的键值对集合，所以这里，如果指定了相同的key,前面的key对应的view状态会被后来的覆盖掉，所以要尽量避免key的重复。</p>
<p>再来看 ViewGroup的 dispatchSaveInstanceState 方法。</p>
<pre><code>@Override
protected void dispatchSaveInstanceState(SparseArray&lt;Parcelable&gt; container) {
    super.dispatchSaveInstanceState(container);
    final int count = mChildrenCount;
    final View[] children = mChildren;
    for (int i = 0; i &lt; count; i++) {
        View c = children[i];
        if ((c.mViewFlags &amp; PARENT_SAVE_DISABLED_MASK) != PARENT_SAVE_DISABLED) {
            c.dispatchSaveInstanceState(container);
        }
    }
}
</code></pre><p>ViewGroup 首先调用了View的dispatchSaveInstanceState 方法来保存自身的状态，然后调用了其子View 的dispatchSaveInstanceState 方法来保存 子view的 状态。这样最终的ViewTree的状态就被保存下来了。</p>
<p>Activity 把View的状态都存下来了之后，再开始存Fragment的状态<br>Fragment状态的保存实在FragmentManager的saveAllState()方法来完成的，在这个方法当中调用了<br>saveFragmentBasicState()方法，</p>
<pre><code> Bundle saveFragmentBasicState(Fragment f) {
    Bundle result = null;

    if (mStateBundle == null) {
        mStateBundle = new Bundle();
    }
    f.performSaveInstanceState(mStateBundle);
    if (!mStateBundle.isEmpty()) {
        result = mStateBundle;
        mStateBundle = null;
    }

    if (f.mView != null) {
        saveFragmentViewState(f);
    }
    if (f.mSavedViewState != null) {
        if (result == null) {
            result = new Bundle();
        }
        result.putSparseParcelableArray(
                FragmentManagerImpl.VIEW_STATE_TAG, f.mSavedViewState);
    }
    if (!f.mUserVisibleHint) {
        if (result == null) {
            result = new Bundle();
        }
        // Only add this if it&apos;s not the default value
        result.putBoolean(FragmentManagerImpl.USER_VISIBLE_HINT_TAG, f.mUserVisibleHint);
    }

    return result;
}
</code></pre><p>performSaveInstanceState 的代码如下 </p>
<pre><code>void performSaveInstanceState(Bundle outState) {
    onSaveInstanceState(outState);
    if (mChildFragmentManager != null) {
        Parcelable p = mChildFragmentManager.saveAllState();
        if (p != null) {
            outState.putParcelable(Activity.FRAGMENTS_TAG, p);
        }
    }
}
</code></pre><p>performSaveInstanceState onSaveInstanceState 方法，在这个方法里面我们可以保存自己想要保存的信息，之后又开始调用FragmentManamager 的 saveAllState()方法，就是递归调用了。跳出这个方法，接着看 saveFragmentViewState()</p>
<pre><code>    void saveFragmentViewState(Fragment f) {
    if (f.mView == null) {
        return;
    }
    if (mStateArray == null) {
        mStateArray = new SparseArray&lt;Parcelable&gt;();
    } else {
        mStateArray.clear();
    }
    f.mView.saveHierarchyState(mStateArray);
    if (mStateArray.size() &gt; 0) {
        f.mSavedViewState = mStateArray;
        mStateArray = null;
    }
}
</code></pre><p>关键的代码是  f.mView.saveHierarchyState(mStateArray);这个方法保存开始保存View的信息， 这个就是在开始分析的保存ViewTree那一部分的内容了。</p>
<p>在上面的内容保存完了还要保存当前已经添加的Fragment的信息，和回退栈的信息。</p>
<pre><code>// Build list of currently added fragments.
   if (mAdded != null) {
       N = mAdded.size();
       if (N &gt; 0) {
           added = new int[N];
           for (int i=0; i&lt;N; i++) {
               added[i] = mAdded.get(i).mIndex;
               if (added[i] &lt; 0) {
                   throwException(new IllegalStateException(
                           &quot;Failure saving state: active &quot; + mAdded.get(i)
                           + &quot; has cleared index: &quot; + added[i]));
               }
               if (DEBUG) Log.v(TAG, &quot;saveAllState: adding fragment #&quot; + i
                       + &quot;: &quot; + mAdded.get(i));
           }
       }
   }

   // Now save back stack.
   if (mBackStack != null) {
       N = mBackStack.size();
       if (N &gt; 0) {
           backStack = new BackStackState[N];
           for (int i=0; i&lt;N; i++) {
               backStack[i] = new BackStackState(this, mBackStack.get(i));
               if (DEBUG) Log.v(TAG, &quot;saveAllState: adding back stack #&quot; + i
                       + &quot;: &quot; + mBackStack.get(i));
           }
       }
   }
</code></pre><p><strong>所以在Fragment保存的内容当中一共是当前active fragment的信息，已经添加的fragment 信息，和回退栈的信息，三部分</strong></p>
<p>在回到Activity 的onSaveInstanceState 方法当中去，最后一步就是通知注册在Application当中的Activity 生命周期的回调。</p>
<p>onSaveInstanceState() 一般在onStop之前调用，再到ActivityThread的performStopActivity方法看看</p>
<pre><code>final void performStopActivity(IBinder token, boolean saveState, String reason) {
    ActivityClientRecord r = mActivities.get(token);
    performStopActivityInner(r, null, false, saveState, reason);
}
</code></pre><p>首先获取了了 一个 ActivityClientRecord 对象，然后在 performStopActivityInner 方法当中，根据saveState的值，会去调用 callCallActivityOnSaveInstanceState 方法</p>
<p>代码如下</p>
<pre><code> private void callCallActivityOnSaveInstanceState(ActivityClientRecord r) {
    r.state = new Bundle();
    r.state.setAllowFds(false);
    if (r.isPersistable()) {
        r.persistentState = new PersistableBundle();
        mInstrumentation.callActivityOnSaveInstanceState(r.activity, r.state,
                r.persistentState);
    } else {
        mInstrumentation.callActivityOnSaveInstanceState(r.activity, r.state);
    }
}
</code></pre><p>接着看 callActivityOnSaveInstanceState 方法，里面直接 调用了 activity.performSaveInstanceState(outState)， 再回到Activity看performSaveInstanceState，</p>
<pre><code>final void performSaveInstanceState(Bundle outState) {
    onSaveInstanceState(outState);
    saveManagedDialogs(outState);
    mActivityTransitionState.saveState(outState);
    storeHasCurrentPermissionRequest(outState);
    if (DEBUG_LIFECYCLE) Slog.v(TAG, &quot;onSaveInstanceState &quot; + this + &quot;: &quot; + outState);
}
</code></pre><p>调用了 onSaveInstanceState 这个就是前文分析的入口了，除了前文分析的保存的状态还保存了，dialog ，activity transaction, 权限相关的信息 ，这些信息都被存入了outState当中。而这个正是ActivityClientRecrod的成员变量之一，ActivityClientRecrod有最终被存在了 ActivityThread 的 mActivities 集合当中。</p>
<p>这里需要注意</p>
<p>现在保存的信息都分析完了，后面用户再回来的时候就需要将保存的信息再传给Activity，启动Acitivty在ActivityThread中的 performLaunchActivity 方法，<br>在这个方法当有如下代码 </p>
<pre><code>if (r.isPersistable()) {
    mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);
} else {
    mInstrumentation.callActivityOnCreate(activity, r.state);
}
</code></pre><p>这里最终将ActivityClientRecord对象中保存的 state 在传递给 activity的 onCreate 方法，这样就可以在onCreate的时候实现对上一个Activity对象状态的恢复。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/01/20/C-中的静态/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Tom Liu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Learning">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/01/20/C-中的静态/" itemprop="url">C++中的静态</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-01-20T23:14:42+08:00">
                2017-01-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>通过添加static关键字将成员与类结合在一起而不是与特定的对象绑定在一起，这一点和java中static关键字是一样的，而且也可以使用访问修饰符修饰</p>
<p>静态成员函数不和任何对象绑定在一起，他们不包含任何this 指针，作为结果，静态成员函数不能成名成const的，而且不能再静态函数的内部使用this指针。</p>
<p>可以使用作用域运算法直接访问静态成员。例如在Account中定义了静态的rate()函数，可以使用Accout::rate()调用。</p>
<p>和其他的成员函数一样，我们既可以在类的内部也可以在类的外部定义静态成员函数，当在类的外部定义静态成员函数的时候不能重复static关键字。</p>
<p>因为静态数据库成员不属于类的任何一个对象，所以他们不是在创建类的对象的时候被定义的，这意味着他们不是由类的构造函数初始化的，而且一般来说我们不能在类的内部初始化静态成员，相反的，必须在类的外部定义和初始化静态成员，类似于全局变量，静态成员定义于任何函数之外，一旦定义就存于程序的整个生命周期。</p>
<p>下面是一个使用static的例子</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

class MyStatic{

public:
    static void test();
    static string name;
};

void MyStatic::test() {
    cout&lt;&lt;&quot;this is static test method&quot;&lt;&lt;endl;
}

string MyStatic::name = &quot;ssssss&quot;;
int main(void) {
    MyStatic::test();
    cout&lt;&lt;MyStatic::name&lt;&lt;endl;
    return 0;
}
</code></pre><p>静态成员可以用于某些场景而普通成员不能</p>
<ol>
<li><p>静态成员不收不完全类型的限制</p>
<pre><code>class MyStatic{
    private:
        MyStatic *my;
        static MyStatic instance;
    public:
        static void test();
        static string name;
};
</code></pre></li>
</ol>
<p>在上面的例子中，如果去掉 instance 变量前的是static，那么将会编译失败</p>
<p>2.静态成员可以作为默认的实参，而普通成员则不行</p>
<pre><code>class MyStatic{
    private:
        static const int  a = 0;
        int b;
    public:
        MyStatic(int c = a):b(a){

        }
    };
</code></pre><p>如果把常量a 的 static关键字拿到，那么编译将报错。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/01/15/Android-热修复技术/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Tom Liu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Learning">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/01/15/Android-热修复技术/" itemprop="url">Android 热修复技术</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-01-15T10:37:59+08:00">
                2017-01-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>今天动手实践了一下安卓上的热修复机制，现在总结一下、</p>
<p>在Android中要想实现热更新实际上就是对class文件的替换，将目标文件替换成新的class文件即可，但是在Android中并没有直接使用class文件，而是将class重新打包在了一个dex文件中，然后从这个dex文件中去load class.<br>在Android中，系统为我们提供了这么一个类，叫做<a href="http://androidxref.com/7.1.1_r6/xref/libcore/dalvik/src/main/java/dalvik/system/DexClassLoader.java" target="_blank" rel="external">DexClassLoader</a>, 从这个类的注释中我们可以看到这个类可以从包含了dex文件的jar和 apk文件中去载类，但是这个类实际上什么都没有做，只是继承了<a href="http://androidxref.com/7.1.1_r6/xref/libcore/dalvik/src/main/java/dalvik/system/BaseDexClassLoader.java" target="_blank" rel="external">BaseDexClassLoader</a>，BaseDexClassLoader中重写findClass方法</p>
<pre><code>@Override
protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException {
    List&lt;Throwable&gt; suppressedExceptions = new ArrayList&lt;Throwable&gt;();
    Class c = pathList.findClass(name, suppressedExceptions);        
    if (c == null) {
        ClassNotFoundException cnfe = new ClassNotFoundException(&quot;Didn&apos;t find class \&quot;&quot; + name + &quot;\&quot; on path: &quot; + pathList);
        for (Throwable t : suppressedExceptions) {
            cnfe.addSuppressed(t);
        }
        throw cnfe;
    }
    return c;
}
</code></pre><p>从上面的代码可以看出,实际上BaseDexClassLoader自己也什么都没有做，而是交给了已 pathList 这个对象去完成加载的任务，pathList 是一个<a href="http://androidxref.com/7.1.1_r6/xref/libcore/dalvik/src/main/java/dalvik/system/DexPathList.java" target="_blank" rel="external">DexPathList</a> 对象，它的findClass实现如下，</p>
<pre><code> public Class findClass(String name, List&lt;Throwable&gt; suppressed) {
    for (Element element : dexElements) {
        DexFile dex = element.dexFile;

        if (dex != null) {
            Class clazz = dex.loadClassBinaryName(name, definingContext, suppressed);
            if (clazz != null) {
                return clazz;
            }
        }
    }
    if (dexElementsSuppressedExceptions != null) {
        suppressed.addAll(Arrays.asList(dexElementsSuppressedExceptions));
    }
    return null;
}
</code></pre><p>它实际上会先遍历一个内部一个dexElements数组，然后从数组元素Elment中加载class对象，在这里我们最终找到了我们的classd对象是什么时候加载的了，既然知道了是什么时候加载的，我们就可以通过替换的方式来改变class了，在虚拟机加载一个class的时候，如果一个类已经被加载过了那么后面就不会再加载它，所以可以将包含补丁class的 Elment 放在数组的最前面，让虚拟机先加载补丁class, 这样需要被替换的class就不会被加载了，从而实现了更新。</p>
<p>实际上PathClassLoader也是BaseDexClassLoader的子类，系统就是使用了这个类来实现加载，PathClassLoader和上面提到的DexClassLoader区别如下， 在创建BaseDexClassLoader的对象时候需要填一个 optimizedDirectory 参数，optimizedDirectory是用来缓存我们需要加载的dex文件的，并创建一个DexFile对象，如果它为null，那么会直接使用dex文件原有的路径来创建DexFile对象。同时optimizedDirectory必须是一个内部存储路径，无论哪种动态加载，加载的可执行文件一定要存放在内部存储。DexClassLoader可以指定自己的optimizedDirectory，所以它可以加载外部的dex，因为这个dex会被复制到内部路径的optimizedDirectory；而PathClassLoader没有optimizedDirectory，所以它只能加载内部的dex，这些大都是存在系统中已经安装过的apk里面的。</p>
<p>因为这些类和变量我们在SDK中都无法直接的获取，所以只能通过反射的方式来获取。<br>下面是核心代码：</p>
<pre><code>package com.baidu.myhotfix;

import android.content.Context;
import android.util.Log;

import java.lang.reflect.Array;
import java.lang.reflect.Field;

import dalvik.system.BaseDexClassLoader;
import dalvik.system.DexClassLoader;

/**
 * Created by liuwei64 on 2017/1/14.
 */

public class HotFixUtil {

    private static final String TAG = &quot;HotFixUtil&quot;;

    public static void init(Context context) {
        ClassLoader classLoader = context.getClassLoader();
        try {
            if (classLoader instanceof BaseDexClassLoader) {
                Log.i(TAG, &quot;get baseclassloader instance&quot;);
                Field field = BaseDexClassLoader.class.getDeclaredField(&quot;pathList&quot;);
                field.setAccessible(true);
                Object dexPathList = getValue(BaseDexClassLoader.class, classLoader, &quot;pathList&quot;);
                Object dexElements = getValue(dexPathList.getClass(), dexPathList, &quot;dexElements&quot;);

                DexClassLoader cl = new DexClassLoader(&quot;/storage/sdcard0/classex_dex.jar&quot;,
                        context.getCacheDir().getAbsolutePath(),
                        null, context.getClassLoader());

                Object dexPathListNew = getValue(BaseDexClassLoader.class, cl, &quot;pathList&quot;);
                Object dexElementsNew = getValue(dexPathListNew.getClass(), dexPathListNew, &quot;dexElements&quot;);

                Object newElements = combineArray(dexElementsNew, dexElements);
                setValue(dexPathList.getClass(), dexPathList, &quot;dexElements&quot;, newElements);
            }
        } catch (Exception ex) {
            Log.e(TAG, ex.getMessage());
        }
    }

    public static Object getValue(Class clz, Object instance, String fileName) {
        try {
            Field field = clz.getDeclaredField(fileName);
            field.setAccessible(true);
            return field.get(instance);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }

    public static void setValue(Class clz, Object instance, String fileName, Object value) {
        try {
            Field field = clz.getDeclaredField(fileName);
            field.setAccessible(true);
            field.set(instance, value);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public static Object combineArray(Object arrayFirst, Object arraySecond) {
        if (arrayFirst == null || arrayFirst == null) {
            return null;
        }

        int firstLen = Array.getLength(arrayFirst);
        int secondLen = Array.getLength(arraySecond);

        int totalLen =  firstLen + secondLen;
        Object result = Array.newInstance(Array.get(arrayFirst, 0).getClass(), totalLen);
        for (int  i = 0; i &lt; totalLen; i++) {
            if (i &lt; firstLen) {
                Array.set(result, i , Array.get(arrayFirst, i));
            } else {
                Array.set(result, i , Array.get(arraySecond, i - firstLen));
            }
        }

        return result;
    }
}
</code></pre><p>实际上这里还有一个问题要解决，就是<a href="https://mp.weixin.qq.com/s?__biz=MzI1MTA1MzM2Nw==&amp;mid=400118620&amp;idx=1&amp;sn=b4fdd5055731290eef12ad0d17f39d4a&amp;scene=1&amp;srcid=1106Imu9ZgwybID13e7y2nEi#wechat_redirect" target="_blank" rel="external">CLASS_ISPREVERIFIED</a>的问题，后面自己实现了再来更新！</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/12/12/LeakCanary源码分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Tom Liu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Learning">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/12/12/LeakCanary源码分析/" itemprop="url">LeakCanary源码分析(1)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-12-12T22:15:45+08:00">
                2016-12-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>LeakCanary是在Android上一款开源的内存泄露分析工具，通过这款工具你可以实时的观察到当前app中出现的内存泄露情况，并且提供泄露路径方便用户来查找内存泄露的根源，[链接]是GitHub上的项目<a href="https://github.com/square/leakcanary" target="_blank" rel="external">1</a></p>
<p>LeakCanary 项目中，包括了五个模块，分别是</p>
<ul>
<li>leakcanary-analyser(为解析hprof文件，找到泄露的对象)</li>
<li>leakcanry-android(主要包含了暴漏给android使用的接口)</li>
<li>leakcanary-anroid-no-op(没有用到)</li>
<li>leakcanary-smaple(示例代码)</li>
<li>leakcanary-watcher(监视对象，触发GC并且生成hprof文件)</li>
</ul>
<p>下面从示例代码中开始入手看LeakCanary是如何发挥作用的</p>
<h2 id="leakcanary-smaple"><a href="#leakcanary-smaple" class="headerlink" title="leakcanary-smaple"></a>leakcanary-smaple</h2><p>在这个模块当中只有两个类，一个是自定义的ExampleApplication，继承于Application，一个是MainActivity.</p>
<pre><code>@Override
public void onCreate() {
    super.onCreate();
    if (LeakCanary.isInAnalyzerProcess(this)) {
        // This process is dedicated to LeakCanary for heap analysis.
        // You should not init your app in this process.
        return;
    }
    enabledStrictMode();
    LeakCanary.install(this);
}
</code></pre><p>在onCreate方法当中，首先判断当前的进程是不是分析进程，在LeakCanary当中为了避免在用户程序的进程当中占用太多的资源，所以整个分析过程是在一个单独的进程当中。</p>
<p>这个方法最终是调用了LeakCanaryInternals这个类的isInServiceProcess方法，这个方法比较简单，主要是通过比较当前Application所在进程的名字是不是HeapAnalyzerService在AndroidManifest.xml中所指定的名字来判断当前的进程是不是应用所在的进程，如果是应用所在的进程    <em>LeakCanary.isInAnalyzerProcess(this)</em>  最终会返回一个false, 这个时候将会继续往下执行，最后执行到LeakCanary.install(this); 如果当前进程的名字就是HeapAnalyzerService在AndroidManifest.xml中所指定的名字，那么表示当前进程是分析hprof的进程，这个时候就直接返回。</p>
<p>接下来进入到 <em>LeakCanary.install(this)</em> 当中，方法的代码如下</p>
<pre><code>  /**
  * Creates a {@link RefWatcher} that works out of the box, and starts watching activity
  * references (on ICS+).
*/
 public static RefWatcher install(Application application) {
    return refWatcher(application).listenerServiceClass(DisplayLeakService.class)
    .excludedRefs(AndroidExcludedRefs.createAppDefaults().build())
    .buildAndInstall();
    }
</code></pre><p>整个方法中都是用调用了通过调用 LeakCanary中的静态方法refWather返回了一个AndroidRefWatcherBuilder对象，这个对象中采用了建造者模式，来设置我们内存泄露中我们设置的一些参数</p>
<ul>
<li>listenerServiceClass()解析结果处理的IntentService. 这个Service需要继承AbstractAnalysisResultService 并且重写onHeapAnalyzed(HeapDump, AnalysisResult)方法来处理得到的分析结果。</li>
<li>excludedRefs 用来方便用户去掉一些特定的引用，当进行内存泄露分析的时候这些引用将不会被考虑在内。</li>
<li><p>buildAndInstall() 创建了RefWatcher实例，并且开始监听Activity的引用。</p>
<pre><code>public RefWatcher buildAndInstall() {
    RefWatcher refWatcher = build();
    if (refWatcher != DISABLED) {
        LeakCanary.enableDisplayLeakActivity(context);
        ActivityRefWatcher.installOnIcsPlus((Application) context, refWatcher);
    }
    return refWatcher;
}
</code></pre></li>
</ul>
<p>从上面代码不难看出其中最重要的方法调用是ActivityRefWatcher.installOnIcsPlus。</p>
<pre><code>@TargetApi(ICE_CREAM_SANDWICH)
public final class ActivityRefWatcher {

    public static void installOnIcsPlus(Application application, RefWatcher refWatcher) {
        if (SDK_INT &lt; ICE_CREAM_SANDWICH) {
            // If you need to support Android &lt; ICS, override onDestroy() in your base activity.
            return;
        }
        ActivityRefWatcher activityRefWatcher = new ActivityRefWatcher(application, refWatcher);
        activityRefWatcher.watchActivities();
    }

    private final Application.ActivityLifecycleCallbacks lifecycleCallbacks =
            new Application.ActivityLifecycleCallbacks() {
                @Override
                public void onActivityCreated(Activity activity, Bundle savedInstanceState) {
                }

                @Override
                public void onActivityStarted(Activity activity) {
                }

                @Override
                public void onActivityResumed(Activity activity) {
                }

                @Override
                public void onActivityPaused(Activity activity) {
                }

                @Override
                public void onActivityStopped(Activity activity) {
                }

                @Override
                public void onActivitySaveInstanceState(Activity activity, Bundle outState) {
                }

                @Override
                public void onActivityDestroyed(Activity activity) {
                    ActivityRefWatcher.this.onActivityDestroyed(activity);
                }
            };

    private final Application application;
    private final RefWatcher refWatcher;

    /**
     * Constructs an {@link ActivityRefWatcher} that will make sure the activities are not leaking
     * after they have been destroyed.
     */
    public ActivityRefWatcher(Application application, final RefWatcher refWatcher) {
        this.application = checkNotNull(application, &quot;application&quot;);
        this.refWatcher = checkNotNull(refWatcher, &quot;refWatcher&quot;);
    }

    void onActivityDestroyed(Activity activity) {
        refWatcher.watch(activity);
    }

    public void watchActivities() {
        // Make sure you don&apos;t get installed twice.
        stopWatchingActivities();
        application.registerActivityLifecycleCallbacks(lifecycleCallbacks);
    }

    public void stopWatchingActivities() {
        application.unregisterActivityLifecycleCallbacks(lifecycleCallbacks);
    }
}
</code></pre><p>看到 lifecycleCallbacks 变量的类型的类型，就应该恍然大悟了，<strong>LeakCanary就是通过在Application当中注册了Activity 生命周期的监听器来实现对Acitivity 引用泄露的分析。</strong> , 每当一个调用一个Activity onDestroy方法之前会调用lifecycleCallbacks的onActivityDestroyed方法。<br>最终会进入到RefWatcher实例的watch(Object ref, String reference Name)方法当中，代码如下：</p>
<pre><code>/**
 * Watches the provided references and checks if it can be GCed. This method is non blocking,
 * the check is done on the {@link WatchExecutor} this {@link RefWatcher} has been constructed
 * with.
 *
 * @param referenceName An logical identifier for the watched object.
 */
public void watch(Object watchedReference, String referenceName) {
    if (this == DISABLED) {
        return;
    }
    checkNotNull(watchedReference, &quot;watchedReference&quot;);
    checkNotNull(referenceName, &quot;referenceName&quot;);
    final long watchStartNanoTime = System.nanoTime();
    String key = UUID.randomUUID().toString();
    retainedKeys.add(key);
    final KeyedWeakReference reference =
            new KeyedWeakReference(watchedReference, key, referenceName, queue);

    ensureGoneAsync(watchStartNanoTime, reference);
}
</code></pre><p>在解释这段代码之前简单的说一下判断一个对象有没有被回收的原理：</p>
<p><strong>在Java中，当我们使用WeakReference指向一个对象的时候，如果这个对象已经被回收了，那么WeakReference 将会被添加到一个指定的队列当中去</strong></p>
<p>在这个方法中，LeakCanary 创建了一个指向Activity的弱引用KeyedWeakReference 对象，KeyedWeakReference继承于WeakReference 但是做了一定的扩展就是添加了两个字符串类型的字段name 和 key。这个key 也就是通过UUID生成的字符串。然后把这个key 添加到了 retainedKeys 代表的字符串集合当中去，只要key还在retainedKeys 当中就表示和 key 绑定的weakreference所指向的对象还没有被回收。</p>
<p>ensureGoneAsync()只是把分析方法通过异步的方式来处理（里面还有很多内容可以分析），在里面最终的调用的方法是 <em>ensureGone(final KeyedWeakReference reference, final long watchStartNanoTime)</em> 方法</p>
<p>放代码</p>
<pre><code>Retryable.Result ensureGone(final KeyedWeakReference reference, final long watchStartNanoTime) {
    ....

    removeWeaklyReachableReferences();

    ...
    if (gone(reference)) {
        return DONE;
    }
    gcTrigger.runGc();
    removeWeaklyReachableReferences();
    if (!gone(reference)) {
        File heapDumpFile = heapDumper.dumpHeap();
        if (heapDumpFile == RETRY_LATER) {
            // Could not dump the heap.
            return RETRY;
        }

        heapdumpListener.analyze(
                new HeapDump(heapDumpFile, reference.key, reference.name, excludedRefs, watchDurationMs,
                        gcDurationMs, heapDumpDurationMs));
    }
    return DONE;
}
</code></pre><p>首先进入removeWeaklyReachableReferences() 方法</p>
<pre><code>private void removeWeaklyReachableReferences() {
    // WeakReferences are enqueued as soon as the object to which they point to becomes weakly
    // reachable. This is before finalization or garbage collection has actually happened.
    KeyedWeakReference ref;
    while ((ref = (KeyedWeakReference) queue.poll()) != null) {
        retainedKeys.remove(ref.key);
    }
}
</code></pre><p>在方法的注释当中我们可以清楚的明白方法的含义：<br>一个对象如果变得只有一个弱引用指向它，那么它就会被添加到指定的队列当中去，就是在前面提到过的queue，这个时候我们可以通过KeyedWeakReference 来找出当初匹配的weakference , name , key，然后将key 从集合中移除，表明key对应引用所指向的对象已经被回收。</p>
<p>接下来这个时候我们在判断一下引用的所指向的对象是不是被回收了，这个判断还是通过判断key 在不在集合当中，如果不在表示这个对象已经完全被回收，可以直接返回。</p>
<p>接下来会触发一次GC. 之所以这样做是为了尽可能的避免进行内存的dump和分析操作。有些对象在这个时候本应该是只有weakreference 可达，但是却不在对队列当中，这个时候触发一次GC并且再进行一次引用分析可以有效地避免一些误判。</p>
<p>这里触发GC的代码如下</p>
<pre><code>// System.gc() does not garbage collect every time. Runtime.gc() is
  // more likely to perfom a gc.
  Runtime.getRuntime().gc();
</code></pre><p>GC完成之后，接下来再进行一次引用的检查，如果这个时候对象还是没有回收那么接下来就要开始内存的dump 操作了。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/12/10/C-显式类型转换/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Tom Liu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Learning">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/12/10/C-显式类型转换/" itemprop="url">C++显式类型转换</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-12-10T21:58:26+08:00">
                2016-12-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>static_cast</strong><br>任何具有明确定义的类型转换，只要不包含底层const，都可以使用static_cast,例如将一个整形的运算对象强制转换为doule类型。static_cast常见的用法有以下两种：</p>
<ul>
<li>类型之间的转换，例如 doule 转为 int.</li>
<li><p>可以用于编译器无法自动执行的类型转换也非常有用，可以使用static_cast找回存在于void* 指针中的值，例如</p>
<p> void<em> p =&d;<br> double </em>dp = static_cast<double*>(p);</double*></p>
</li>
</ul>
<p>当我们把指针保存在void<em>当中，并且使用static_cast找回转换的值得时候，应该保证void</em> 指针的值不变，如果一旦类型发生了变换，那么将产生未定义的后果。</p>
<p>static_cast作类型转换的时候需要我们自己去确保转换的类型是匹配的，static_cast可以用在指针和引用上，还可以用在基础数据和对象上,用static_cast来处理的转换就需要两者具有”一定的关系”了,实际上继承关系是可以被static_cast接受的，其他情况的指针和引用转换都会被static_cast直接扔出编译错误，而这层关系上的转换又几乎都可以被dynamic_cast所代替</p>
<p><strong>const_cast</strong><br>const_cast 只能改变运算对象底层的const修饰、<br>对于将常量对象转为非常量对象的行为，我们一般称之为去掉const性质，一旦我们去掉了某个对象的const性质，编译器就不在阻止我们对该对象进行修改了，虽然我们可以获取修改对象的权限，但是这样的操作时未定义的。<a href="http://www.cnblogs.com/ider/archive/2011/07/22/cpp_cast_operator_part2.html" target="_blank" rel="external">阅读</a></p>
<p><strong>reinterpret_cast</strong><br>reinterpret_cast运算符用来处理无关类型之间的转换，他会产生一个新值，这个值会与原始参数有完全相同的bit位。<br>IBM的C++指南里倒是明确告诉了我们reinterpret_cast可以，或者说应该在什么地方用来作为转换运算符：</p>
<ul>
<li>从指针类型到一个足够大的整数类型</li>
<li>从整数类型或者枚举类型到指针类型</li>
<li>从一个指向函数的指针到另一个不同类型的指向函数的指针</li>
<li>从一个指向对象的指针到另一个不同类型的指向对象的指针</li>
<li>从一个指向类函数成员的指针到另一个指向不同类型的函数成员的指针</li>
<li>从一个指向类数据成员的指针到另一个指向不同类型的数据成员的指针</li>
</ul>
<p><strong>dynamic_cast</strong><br>与static_cast一样，dynamic_cast的转换也需要目标类型和源对象有一定的关系：继承关系。 更准确的说，dynamic_cast是用来检查两者是否有继承关系。因此该运算符实际上只接受基于类对象的指针和引用的类转换。</p>
<p>对于从子类到基类的指针转换，static_cast和dynamic_cast都是成功并且正确的（所谓成功是说转换没有编译错误或者运行异常；所谓正确是指方法的调用和数据的访问输出是期望的结果），这是面向对象多态性的完美体现。</p>
<p>而从基类到子类的转换，static_cast和dynamic_cast都是成功的，但是正确性方面，我对两者的结果都先进行了是否非空的判别：dynamic_cast的结果显示是空指针，而static_cast则是非空指针。但很显然，static_cast的结果应该算是错误的。</p>
<p>如果基类或者子类没有任何虚函数（如果基类有虚函数表，子类当然是自动继承了该表），当他们作为dynamic_cast的源类型进行转换时，编译也会失败。</p>
<p>这种情况是有可能存在的，因为在设计的时候，我们可能不需要让子类重写任何基类的方法。但实际上，这是不合理的，<br>如果要用继承，那么一定要让析构函数是虚函数；如果一个函数是虚函数，那么在子类中也要是虚函数。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/12/08/Java中弱引用的理解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Tom Liu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Learning">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/12/08/Java中弱引用的理解/" itemprop="url">Java中弱引用的理解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-12-08T14:05:24+08:00">
                2016-12-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>弱引用也是用来描述非必需的对象，但是他的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前，当垃圾收集工作时，无论当前内存是否足够，都会回收掉被弱引用关联的对象，在JDK1.2之后，提供了WeakReference类实现弱引用。</p>
<p>看下面的代码</p>
<pre><code>public class TestClient {
        public static void main(String[] args) throws Exception {
                int count = 5;
    System.out.println(&quot;before create object the current memory size = &quot; +                 Runtime.getRuntime().freeMemory());
    Test test = new Test();
    System.out.println(&quot;after create object the current memory size = &quot; + Runtime.getRuntime().freeMemory());
    WeakReference&lt;Test&gt; weakReference = new WeakReference&lt;Test&gt;(test);
    while(true) {
        count--;
        System.gc();
        Thread.sleep(5000);
        if(weakReference.get() == null) {
            System.out.println(&quot;the test has been recycled and the free memory is &quot; + Runtime.getRuntime().freeMemory());
        } else {
            System.out.println(&quot;the test has not been recycled and the free memory is &quot; + Runtime.getRuntime().freeMemory());
            if(count == 0) {
                test = null;
            }
        }
    }
    }
}
class Test  {
    byte data [] = new byte[10 * 1024 * 1024];
}
</code></pre><p>上述代码运行的结果如下</p>
<pre><code>before create object the current memory size = 122179856
after create object the current memory size = 111694080
the test has not been recycled and the free memory is 112663384
the test has not been recycled and the free memory is 112666448
the test has not been recycled and the free memory is 113316792
the test has not been recycled and the free memory is 113316792
the test has not been recycled and the free memory is 113316792
the test has been recycled and the free memory is 123802584
the test has been recycled and the free memory is 123802440
the test has been recycled and the free memory is 123802440
</code></pre><p>我们可以发现我们通过WeakReference 引用到了 Test 对象，但是一旦我们把test这个强引用置为null之后，test对象马上就被回收了。</p>
<p>如果把弱引用改为软引用，那么会发现即使把test置为空，这个对象依然被软引用引用到了，不会不会被垃圾回收器回收。在Java虚拟机中，被软引用引用到的对象只会在内存不够用的情况下才会回收这一部分内存。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/10/15/Android-View测量模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Tom Liu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Learning">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/10/15/Android-View测量模式/" itemprop="url">Android View测量模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-10-15T17:24:43+08:00">
                2016-10-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>今天看android源码的时候无意中发现了源码中关于测量模式的解释，简单的记录一下，一看就是恍然大悟了。</p>
<pre><code>  int result = desiredSize;
int specMode = MeasureSpec.getMode(measureSpec);
int specSize =  MeasureSpec.getSize(measureSpec);
switch (specMode) {
    case MeasureSpec.UNSPECIFIED:
        /* Parent says we can be as big as we want. Just don&apos;t be larger
           than max size imposed on ourselves.
        */
        result = Math.min(desiredSize, maxSize);
        break;
    case MeasureSpec.AT_MOST:
        // Parent says we can be as big as we want, up to specSize. 
        // Don&apos;t be larger than specSize, and don&apos;t be larger than 
        // the max size imposed on ourselves.
        result = Math.min(Math.min(desiredSize, specSize), maxSize);
        break;
    case MeasureSpec.EXACTLY:
        // No choice. Do what we are told.
        result = specSize;
        break;
}
return result;
</code></pre><p>看着代码中的注释应该很容易明白以后测量模式应该怎么用了。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/10/08/C-多态/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Tom Liu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Learning">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/10/08/C-多态/" itemprop="url">C++多态</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-10-08T08:46:44+08:00">
                2016-10-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在函数定义中有vitural关键字的函数就是虚函数，不能用在构造函数和静态函数上面。</p>
<p>虚函数只能借助于指针或者引用来达到多态的效果。</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;cstring&gt;

using namespace std;

class  A {

private:
    string name;    
public:

    A(string n):name(n) {

    }

    string getName() {
        return name;
    }

    void print() {
        cout&lt;&lt;&quot;A&quot;&lt;&lt;endl; 
    }

    virtual void hutrted() {
        cout&lt;&lt;name&lt;&lt;&quot; get hurted&quot;&lt;&lt;endl;
    }

    virtual void attack(A* a) {
        cout&lt;&lt;name&lt;&lt;&quot;attack &quot; &lt;&lt; a-&gt;getName()&lt;&lt;endl;
        a-&gt;hutrted();
    }
};

class B:public A{

public:
    B(string n):A(n) {

    } 

     void hutrted() {
        A::hutrted();
        cout&lt;&lt;&quot;this is b override hutrted&quot;&lt;&lt;endl;
    }

     void attack(A* a) {
        A::attack(a);
        cout&lt;&lt;&quot;this is b override attack&quot;&lt;&lt;endl;
    }

};

int main() {
    A* a = new A(&quot;A&quot;);
    A* b = new B(&quot;B&quot;);

    b-&gt;attack(a);

    cout&lt;&lt;&quot;---------------------&quot;&lt;&lt;endl;
    a-&gt;attack(b); 

    delete a;
    delete b;
    return 0; 
} 
</code></pre><p>在上面的例子中就实现了多态，如果将基类A 方法中的virtual关键字去掉，那么这个时候将无法实现多态。</p>
<p>虚函数的作用在于实现了动态关联，即一个类的函数调用在编译的时候并不能确定而需要在程序运行的时候决定。</p>
<p>如果将A 中的virtual关键字去掉，那么函数的调用在编译的时候即决定。无法实现多态。</p>
<p><strong>与java对比的话，在java当中只需要通过继承并且重写父类的方法即可实现多态</strong></p>
<p>在构造函数和析构函数中不会形成多态，因为这个是在编译期间就确定了其行为。在构造函数和析构函数中调用虚函数，调用的是本类中定义的函数（如果没有定义就从父类中去找）。<em>之所以这么设计是因为如果在父类的构造器中调用了虚函数，在构造子类的时候会先调用父类的构造器这个时候虚函数如果是多态，那么会调用子类的方法，但是这个时候子类还没有生成对象，这个时候调用会产生错误，析构函数同理，子类对象会先于父类对象被析构。这个时候如果在父类的析构函数中调用了虚函数，即在一个已经析构的对象上调用方法，也会产生错误</em></p>
<p><strong>虚析构函数</strong><br>看下面的这段代码</p>
<pre><code>class Super{
public:
~Super(){
    cout&lt;&lt;&quot;~Super invoked&quot;&lt;&lt;endl;
} 
};

class Son : public Super {
    ~Son(){
        cout&lt;&lt;&quot;~Son invoked&quot;&lt;&lt;endl;
    } 
}; 

int main() {
    Super* son = new Son;
    delete son; 
    return 0;
} 
</code></pre><p>当我们动态的分配内存空间给son的时候，如果使用delete删除掉son，这个时候只会调用Super的析构函数，这个时候Son的构造函数并没有得到调用，那么这就有可能造成内存泄露，为了解决这种问题，就出现了<em>虚析构函数</em></p>
<pre><code>class Super{

public:
    virtual~Super(){
        cout&lt;&lt;&quot;~Super invoked&quot;&lt;&lt;endl;
    } 
};

class Son : public Super {
    ~Son(){
        cout&lt;&lt;&quot;~Son invoked&quot;&lt;&lt;endl;
    } 
}; 
int main() {
    Super* son = new Son;
    delete son; 
    return 0;
} 
</code></pre><p>即在在父类的析构函数前加上virtual关键字。这样当我们再次调用delete son的时候，会先调用Son的析构函数在调用Super的析构函数。</p>
<p><strong>C++多态实现的原理</strong><br>在C++当中，如果一个类中包含了虚函数，那么这个类中就会存在虚函数表。并且该类的任何对象中都存在这虚函数表的指针</p>
<pre><code>class Super{
public:
    int a;
    virtual~Super(){
        cout&lt;&lt;&quot;~Super invoked&quot;&lt;&lt;endl;
    } 
};
</code></pre><p>所以当我们输出sizeof(Super)的时候，会输出16(在64位的dev C++中)，这就说明了函数表中存在其他的内容，而这个内容就是虚函数表，多态的函数调用语句被编译成一系列根据基类指针所指向对象中存放的虚函数表的地址，在虚函数表中查找虚函数的地址，并调用虚函数的指令。</p>
<p><strong>纯虚函数和抽象类</strong><br>纯虚函数是指没有函数体的虚函数，那么包含了纯虚函数的类就是抽象类了，抽象类不能生成对象（但是可以使用抽象的指针指向基类），只能作为派生类的基类来使用，并且在类的构造方法和析构函数中不能调用纯虚函数。</p>
<p>一个子类只有实现了父类当中定义的所有纯虚函数才能变成非抽象类，否则还是一个抽象类。</p>
<pre><code>class Super{
public:
    int a;
    virtual~Super(){
        cout&lt;&lt;&quot;~Super invoked&quot;&lt;&lt;endl;
    } 

    virtual void method() = 0; //纯虚函数
};

class Son : public Super {
    int b;
    ~Son(){
        cout&lt;&lt;&quot;~Son invoked&quot;&lt;&lt;endl;
    } 

    void method() { //纯虚函数实现

    }
}; 

int main() {
    Super* son = new Son;
    delete son; 
    return 0;
} 
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/09/25/C-const/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Tom Liu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Learning">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/09/25/C-const/" itemprop="url">C++ const</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-09-25T11:05:41+08:00">
                2016-09-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在C++中可以使用const表示修饰常量。</p>
<p>使用一个const来定义一个对象的时候，那么这个对象是不可以修改的。</p>
<pre><code>class ConstantTest {
public:
    int a;
    void func() const {
        cout&lt;&lt;a&lt;&lt;endl; 
    }
};    
const ConstantTest test; 
test.a = 100; //报错，无法修改常量对象的内容。
</code></pre><p>在常量对象上无法调用非常量成员函数，因为在非常量的成员函数中可能修改了成员变量，</p>
<p>可以使用在成员函数的参数列表后添加<strong>const</strong>关键字来声明一个常量成员函数。常量成员函数中不可以修改对象非静态.也不能调用同类中的非常量函数（静态成员函数除外）</p>
<p><strong><em>Note</em></strong><br>两个成员函数的函数名和参数列表都一样，但是一个有const 一个没有，形成重载</p>
<p>在C++中的const 分为两种，一种是顶层的const，一种是底层的const,</p>
<p>如果一个变量被顶层的const修饰，那么表示这个这变量，将不能改变其指向的对象，在Java中使用fianl 修饰的引用也是这样。</p>
<p>如果变量被一个底层的const修饰，那么这个对象的内容是不可变得。</p>
<p>如何区分两种const，有牛人<a href="https://segmentfault.com/a/1190000005168641" target="_blank" rel="external">总结</a>如下</p>
<p>如果const右结合修饰的为类型或者*，那这个const就是一个底层const<br>如果const右结合修饰的为标识符，那这个const就是一个顶层const</p>
<p>测试代码如下 </p>
<pre><code>#include &quot;Person.h&quot;
#include &lt;iostream&gt;

using namespace std;

int main() {

    /////////// 底层 const//////
    Person person;
    Person person2;
    const Person*  p = &amp;person;
    person.name = &quot;Tom&quot;;
    //p-&gt;name = &quot;liu&quot;; 报错，底层const 不能改变内容
    p = &amp;person2;

    cout&lt;&lt;person.name&lt;&lt;endl;
    cout&lt;&lt;p-&gt;name&lt;&lt;endl;

    ////////////顶层const/////////////
    Person person3;
    Person person4;
    Person* const p1 = &amp;person3;
    p1-&gt;name = &quot;Tom&quot;; // 顶层const 可以修改内容
    //p1 = &amp;person4; // 但是不能修改指针对象的指向
    cout&lt;&lt;p1-&gt;name&lt;&lt;endl;
}
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/09/25/C-函数学习/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Tom Liu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Learning">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/09/25/C-函数学习/" itemprop="url">C++函数学习</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-09-25T11:03:38+08:00">
                2016-09-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>内联函数</strong><br>编译器编译的时候直接将函数的内容作为调用函数的一部分，避免了调用函数所产生的开销。</p>
<pre><code>inline function(int x, int y) {
    cout&lt;&lt;x - y;
} 
</code></pre><p><strong>函数的缺省值</strong></p>
<pre><code>//设置函数的缺省值 
void function(int x, int y = 2, int z = 3) {
    cout&lt;&lt;x+y+z;
}
</code></pre><p><strong>构造函数</strong></p>
<p>对象所占用的存储空间并不是由构造函数分配的，构造只是在对象的存储空间分配之后，来完成一写初始化的工作。</p>
<p><strong>复制构造函数</strong></p>
<p>只能有一个参数，即同类对象的引用。如果自己不写复制构造函数，系统将提供一个默认的复制构造函数，这儿构造函数的功能完成对对象的拷贝。<br>复制构造函数起作用的三种情况：</p>
<ul>
<li>用一个对象去初始化另一个对象。例如 Complex c2 = c1 //初始化语句</li>
<li>如果某一个函数的形参是类A的对象，调用该函数的时候，类A的复制构造函数将被调用 用来 初始化形参。</li>
<li>如果一个函数的返回值是类A的对象，那么函数返回的时候类A的复制构造函数将被调用。复制构造函数用来初始化作为返回值存在的类A对象，例如函数method()的返回值赋值给a, 那么类的A的复制构造函数用来初始化a.</li>
</ul>
<p><strong>析构函数</strong><br>析构函数与构造函数相反是在一个对象被释放掉的时候调用，与Java中Object的finalize 方法相似。析构函数有以下几个调用的时机</p>
<ul>
<li>使用 delete 删除 new所分配的对象。</li>
<li>当一个作用域结束的时候，其中对象的析构方法将被调用。</li>
<li>临时对象的生存期结束。</li>
<li>程序结束，并且存在全局或静态对象，对象的析构函数将被调用。</li>
<li><p>显示的调用一个对象的析构方法时。</p>
<p>使用析构函数时，如果一个类中都是对象和基本类型，那么在析构函数调用的时候将自动的调用这些对象和基本类型的析构函数，如果其中包含了自己手动申请的空间，那么需要自己手动的在析构函数中去释放这些空间。</p>
<p>  public:</p>
<pre><code>Book* book;

MyClass(Book* book) {
    this-&gt;book = book;
}
~MyClass() {
    book-&gt;~Book();
    cout&lt;&lt;&quot;MyClass析构函数被调用&quot;&lt;&lt;endl; 
}
</code></pre><p> };</p>
<p> 如果在MyClass的析构函数中没有手动去的去调用~Book(),那么book所指向的内存将不会释放。</p>
</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Tom Liu" />
          <p class="site-author-name" itemprop="name">Tom Liu</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">26</span>
                <span class="site-state-item-name">Artikel</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">32</span>
                <span class="site-state-item-name">Tags</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Tom Liu</span>
</div>


<div class="powered-by">
  Erstellt mit  <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  

  

  

  

  

</body>
</html>
