<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta property="og:type" content="website">
<meta property="og:title" content="Learning">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Learning">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Learning">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/"/>





  <title>Learning</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  















  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Learning</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/14/Linux学习笔记之进程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Tom Liu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Learning">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/14/Linux学习笔记之进程/" itemprop="url">Linux学习笔记之进程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-02-14T23:11:02+08:00">
                2017-02-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>进程是多道程序设计的操作系统中的基本概念，通常把进程定义为程序执行的一个实例， 例如16个user在使用vi，那么操作系统就有16个独立的进程，尽管他们共享同一个可执行代码。</p>
<p><strong>进程，轻量级进程和线程</strong><br>当一进程创建的时候，它几乎与父进程相同，它接受父进程地址空间的一个（逻辑）拷贝（<em>假设当前进程A中定义了一个变量X,其地址为 0x01,那么拷贝之后，子进程中对应的X，地址空间任然为0x01，虽然两者的地址一样，但是这只限于在虚拟内存的地址空间内，两者在物理地址上肯定是不一样的</em>）。并且从进程创建系统调用的下一条指令开始执行与父进程相同的代码，尽管父子进程可以共享有程序代码的页，但是他们各自有独立的数据拷贝（堆和栈），因此子进程对内存单元的修改对父进程来说是可见的.</p>
<p><strong>进程描述符</strong><br>进程描述符中包含了与一个进程相关的所有信息，它不仅包括了很多进程属性的字段，而且一些字段还包括了指向其他数据结构的指针。进程描述符都是task_struct结构。</p>
<p><strong>进程的状态</strong><br>进程描述符中的state字段描述当前进程的状态，进程每种状态是互斥的。</p>
<ul>
<li>运行状态（TASK_RUNNING）</li>
<li>可中断的等待状态（TASK_INTERRUPTIBLE）：进程被挂起，知道某个条件为真。</li>
<li>不可中断的等待状态（TASK_UNINTERRUPTERABLE） 这个时候即使把信号传递到挂起进程也不能改变它的状态，在一些特定的情况下这种状态很有用，例如，当进程打开一个设备文件，其相应的设备驱动程序开始探测相应的硬件设备时就会用到这种状态，探测完成之前，设备驱动程序不能被中断，否则，硬件设备处于不可知的状态。</li>
<li>暂停状态（TASK_STOPPED） 进程的执行被暂停，当进程接收到SIGSTOP 等信号的时候进入暂停状态。</li>
<li>跟踪状态(TASK_TRACED)进程的执行由debugger程序暂停，当一个进程被另一个进程监控的时候（例如debugger执行ptrace()系统调用监控一个测试程序），任何程序都可以把这个程序置于TASK_TRACED.</li>
<li>僵死状态（EXIT_ZOMBIE） 进程的执行被终止，但是父进程还没有发布wait4() 或者 waitpid() 系统调用来返回死亡进程的信息，发布wait()类系统调用前，内核不能丢弃包含在死进程描述符中的数据，因为父进程可能还需要它。</li>
<li>僵死撤销状态（EXIT_DEAD） 最终状态，由于父进程刚发出wait4()或者waitpid()系统调用，因而进程由系统删除。</li>
</ul>
<p><strong>标识一个进程</strong><br>一般来说能被独立调度的每个执行上下文都必须拥有它自己的进程描述符，因此即使共享内核大部分数据结构的轻量级线程，也有他们自己的task_struct结构。<br>进程和进程描述符之间有非常严格的一一对应的关系，这使得用32位进程描述符地址标识进程成为一种方便的方式，进程描述符指针指向这些地址，内核对进程的大部分引用是通过进程描述符指针进行的。</p>
<p>类Unix操作系统允许用户使用一个叫做进程标识符的processID（PID）的数字来标识进程，PID存放在进程描述符的pid字段中，PID被顺序编号，新建的PID通常是前一个进程的PID加1，pid的值有一个上限，在默认情况下是 32767， 但是系统管理通过修改/proc/sys/kernel/pid_max来减小这个值。同时在64位的体系中可以把PID的上限扩大到 4194303。当内核的使用的PID达到这个上限的时候必须开始循环使用已闲置的小PID号。</p>
<p>由于循环使用PID编号，内核必须通过一个pidmap-array 位图来表示当前已经分配的PID号和闲置的PID号，因为一个页框包含了32768 （4 <em> 1024 </em> 8）个位，所以在32位体系结构中位图单独放在一个页中，在64位体系结构中，当内核分配了超过当前位图大小的pid号时，需要为PID位图增加更多的页。系统会一直保存这些页不会释放掉。</p>
<p><strong>进程的切换</strong><br>尽管每个进程都可以拥有属于自己的进程空间，但是所有的进程都必须共享CPU寄存器，因此在CPU恢复一个进程的执行之前，内核必须必须确保每个寄存器装入挂起进程时的值。</p>
<p>进程恢复之前必须装入寄存器的一组数据称为硬件的上下文，硬件上下文是可执行上下文的一个子集，因为执行上下文包含了进程执行时需要的所有信息。在Linux中，进程硬件上下文的一部分存在TSS段（任务状态段(Task State Segment, TSS)是x86架构电脑上是一个保存任务信息的数据结构，被操作系统内核用于任务管理），而剩余部分存放在内核态堆栈中。</p>
<p><em>thread字段</em><br>在每次切换进程的时候，被替换进程的硬件上下文必须要保存在别处，不能像Intel原始设计那样把它保存在TSS中，因为linux为每个处理器而不是每个进程使用TSS.</p>
<p>因此每个进程描述符包含一个thread_struct的tread 字段，只要进程被切换出去，内核就把其硬件上下文保存在这个结构中。这个数据结构包含的字段设计大部分CPU寄存器，但是不包含eax， ebx这类通用寄存器，他们的值保存在内核堆栈中。</p>
<p><em>执行进程切换</em><br>进程切换可能只能发生在精心定义的点：schedule()函数。<br>本质上，每个进程切换由两步组成</p>
<ol>
<li>切换页全局目录以安装一个新的地址空间。</li>
<li>切换内核堆栈和硬件上下文</li>
</ol>
<p><strong>创建进程</strong><br>为了避免子进程拷贝时耗费资源的问题，现在Linux中引入了三种机制</p>
<ol>
<li>写时复制技术允许父子进程读相同的物理页，只要两者中有一个尝试写一个物理页，内核就把这个页的内容拷贝到新的物理页，并把这个页分配给正在写的进程。</li>
<li>轻量级进程允许父子进程共享进程在内核的很多数据结构，如页表（也就是整个用户态地址空间），打开的文件表和信号处理</li>
<li>vfork(),系统调用创建的进程能共享其父进程的内存地址空间，为了防止父进程重写子进程需要的数据，子进程创建后将阻塞父进程的执行，一直到子进程退出或执行一个新的程序为止。</li>
</ol>
<p>clone(), fork()和 vfork();</p>
<p>在linux中，轻量级进程是由clone() 创建的。在传统的Linux中fork使用clone实现，vfork()系统调用在Linux中也是用clone实现的。</p>
<p>do_fork()函数负责处理clone, fork, vfor,系统调用， do_fork() 利用辅助函数copy_process 来创建进程描述符已经进程执行所需的其他所有内核数据。</p>
<p><strong>线程在linux中的实现</strong><br>liux中实现线程的机制非常的独特，从内核角度来说，它并没有线程这个概念，linux把所有的线程都当做进程来实现，内核并没有定义特别的调度算法和数据结构来表示线程，相反，线程仅仅被视作一个与其他进程共享某些资源的进程，每个线程都有唯一里属于自己的task_struct,所以在内核中他看起来就是一个普通的进程。</p>
<p><strong>内核线程</strong><br>内核经常需要在后台执行一些操作，这种任务可以通过内核线程（独立运行在内核空间的标准线程）来完成，内核线程和普通的进程间的区别在于内核线程没有的地址空间，它们只在内核空间运行，从来不切换到用户空间去，内核进程和普通进程一样，可以被调度也可以被抢占</p>
<p>内核线程只能由其他内核线程创建，内核线程创建之后需要调用wake_up_process()才能运行，否则它不会主动运行，创建一个进程并让它运行起来，可以调用kthread_run()来达到，这个例程是以宏实现的，只是简单的调用了kthread_create和wake_up_process();</p>
<p>内核线程启动之后就一直运行直到调用do_exit()退出，或者内核的其他部分调用kthread_stop()退出，传递给kthread_stop的参数为kthread_create函数返回的task_struct结构的地址。</p>
<pre><code>int kthread_stop(struct task_struct *k);
</code></pre><p><strong>进程的终结</strong><br>一般来说进程的析构是由自身引起的，它发生在exit系统调用时，既可能是显式的调用，也可能是隐式的从程序的主函数返回，C语言的编译器会在函数的返回点后面放置调用exit()的代码，当进程遇到既不能自己处理也不能忽略的信号时，还可能被动的终结。</p>
<p><strong>删除进程描述符</strong><br>在调用了do_exit()方法之后，尽管线程已经僵死不能运行了，但是系统还是保留了他的进程描述符，这样可以让系统在子进程终结之后仍然能获取它的信息，因此进程终结时所需的额清理工作和进程描述符的删除被分开执行，在进程获取已总结的子进程的信息后，或者内核通知他不再关注该信息后，紫禁城的task_struct才被释放。</p>
<p>wait这一族函数都是通过唯一的系统调用wait4来实现的，它的标准动作是挂起调用它的进程，直到其中的一个子进程退出，此时函数会返回该子进程的pid,此外调用该函数提供的指针会包含子函数退出时的代码，</p>
<p><strong>处理孤儿进程</strong><br>如果父进程在子进程之前退出，那么系统会给子进程找一个新的父进程，否则这些孤儿进程在退出自后就会永远处于僵死状态而无法释放其所占用的内存，对于这个问题，解决方法是给子进程在当前线程组内找一个进程作为父亲，如果不行就让init做他们的父亲。在do_exit()方法当中会调用exit_notify() 该函数会调用forget_orginal_parent() 而后者会调用find_new_reaper()来执行寻父的过程。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/13/Android-PackageManager-Service-学习笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Tom Liu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Learning">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/13/Android-PackageManager-Service-学习笔记/" itemprop="url">Android PackageManager Service 学习笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-02-13T23:13:46+08:00">
                2017-02-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>PMS 主要包含三部分的内容</p>
<ul>
<li>提供一个能够根据Intent 匹配找到Activity，Provider， Service ，即通过intent来找到具体的组件</li>
<li>进行权限的检查，当应用程序需要调用一个需要权限的函数的时候，系统能够判断当前调用者是否具有改该权限。</li>
<li>提供安装删除应用程序的接个口</li>
</ul>
<p>PMS服务运行时使用两个目录下的xml文件保存相关的包管理信息，<br>第一个目录是<em>/system/etc/premissions</em>该目录下的xml用于permission的管理，具体包含两个，第一个是定义系统中都包含了那些featrue, 应用程序可以在AndroidManifest.xml中使用 use-featrue 声明程序需要哪些freatrue<br>例如： <use-feature android:name="android.hardware.wifi" android:required="true"><br>该标签表示应用程序需要使用这个功能，如果required = true, 但是设备上没有wifi,那么程序将无法安装</use-feature></p>
<p>设备都包含了那些feature就是在该目录下声明的，如果用户给系统添加了GPS或者蓝牙的功能，则必须在该目录下声明相关的xml文件来告诉framework。 </p>
<p>该目录下还有一个platform.xml文件，该文件为一些特别的uid和gid分配了一些默认的权限，</p>
<p>第二个目录是<em>/data/system/packages.xml</em>,该文件保存了所有安装程序的基本信息，类似注册表。<br>下面是从文件里面拷贝出来的一段</p>
<pre><code>&lt;package name=&quot;xxxxxxx.xxx&quot; codePath=&quot;/data/app/xxxxxxx&quot; nativeLibraryPath=&quot;/data/app/com.tools.freereminder-1/lib&quot; primaryCpuAbi=&quot;armeabi-v7a&quot; flags=&quot;4767300&quot; ft=&quot;15a1c7833a0&quot; it=&quot;15a1c783548&quot; ut=&quot;15a1c783548&quot; version=&quot;170208&quot; userId=&quot;10223&quot;&gt;
    &lt;sigs count=&quot;1&quot;&gt;
        &lt;cert index=&quot;12&quot; key=&quot;xxxxxx&quot; /&gt;
    &lt;/sigs&gt;
    &lt;perms&gt;
        &lt;item name=&quot;android.permission.DOWNLOAD_WITHOUT_NOTIFICATION&quot; /&gt;
        &lt;item name=&quot;android.permission.WRITE_SETTINGS&quot; /&gt;
        &lt;item name=&quot;android.permission.SYSTEM_ALERT_WINDOW&quot; /&gt;
        &lt;item name=&quot;android.permission.RECEIVE_BOOT_COMPLETED&quot; /&gt;
        &lt;item name=&quot;android.permission.GET_TASKS&quot; /&gt;
        &lt;item name=&quot;android.permission.INTERNET&quot; /&gt;
        &lt;item name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot; /&gt;
        &lt;item name=&quot;android.permission.ACCESS_COARSE_LOCATION&quot; /&gt;
        &lt;item name=&quot;android.permission.READ_PHONE_STATE&quot; /&gt;
        &lt;item name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt;
        &lt;item name=&quot;android.permission.DISABLE_KEYGUARD&quot; /&gt;
        &lt;item name=&quot;android.permission.GET_ACCOUNTS&quot; /&gt;
        &lt;item name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt;
        &lt;item name=&quot;android.permission.VIBRATE&quot; /&gt;
        &lt;item name=&quot;android.permission.ACCESS_WIFI_STATE&quot; /&gt;
        &lt;item name=&quot;com.android.launcher.permission.INSTALL_SHORTCUT&quot; /&gt;
        &lt;item name=&quot;android.permission.WAKE_LOCK&quot; /&gt;
    &lt;/perms&gt;
    &lt;proper-signing-keyset identifier=&quot;322&quot; /&gt;
    &lt;signing-keyset identifier=&quot;322&quot; /&gt;
&lt;/package&gt;
</code></pre><p>PMS 在启动的时候，会从这两个目录中解析相关的xml文件，从而建立一个包信息树，应用程序可以间接从这个信息树中查询所有所需的包信息。</p>
<p>除了PMS外，还有两个辅助系统服务用于程序安装，一个是DefaultContainerService,该服务主要把安装程序复制到程序目录中；另一个是installer服务，该服务实际上不是一个binder,而是一个socket客户端，PMS直接和Socket客户端交互，Socket的服务端主要完成程序文件的解压工作及数据目录的创建，比如从APK文件中提取出dex文件，删除delvik-cache目前下的dex文件，创建程序专属的数据目录。</p>
<p>就像所有的操作系统一样，Android中的程序文件也由相关的程序文件组成，这些程序文件可以分为三个部分。<br>第一部分：程序文件，所有的系统程序文件保存在/system/app下，所有第三方的应用程序保存在/data/app下。/data/dalvik-cache目录保存了程序中执行的代码，PMS会从APK中提取出dex保存在该目录下，以便以后能快速的运行。<br>第二部分：framework 库文件，这些库文件位于/system/framework/ 目录下，库文件类型是apk或者jar,系统开机之后，dalvik虚拟机会加载这些库文件，而在PMS启动的时候如果这些jar或者APK还没有被转换为dex文件，PMS会将这些库文件转为dex文件，并且保存到/data/dalvik-cache目录下。(目前为止，我将dex导出之后，从反编译工具去打开这个dex文件，提示不是一个dex文件)<br>第三部分：程序自身的数据文件.</p>
<p>系统安装一个apk的过程分析</p>
<p>入口方法在于PMS的installPackageAsUser 方法。</p>
<p>在方法的开始会进行一系列的权限检查，然后相关的信息封装成一个message 通过自定义的packagehandler 发送出去，关键代码如下 </p>
<pre><code>final File originFile = new File(originPath);
final OriginInfo origin = OriginInfo.fromUntrustedFile(originFile);
final Message msg = mHandler.obtainMessage(INIT_COPY);
final VerificationInfo verificationInfo = new VerificationInfo(
        null , null, -1, callingUid);
final InstallParams params = new InstallParams(origin, null, observer,
        installFlags, installerPackageName, null, verificationInfo, user,
        null, null,null);
params.setTraceMethod(&quot;installAsUser&quot;).setTraceCookie(System.identityHashCode(params));
msg.obj = params;
Trace.asyncTraceBegin(TRACE_TAG_PACKAGE_MANAGER, &quot;installAsUser&quot;,
        System.identityHashCode(msg.obj));
Trace.asyncTraceBegin(TRACE_TAG_PACKAGE_MANAGER, &quot;queueInstall&quot;,
        System.identityHashCode(msg.obj));
mHandler.sendMessage(msg);
</code></pre><p>处理消息的代码可以在PackgetHanlder当中找到，定义在doHandler当中，之前发送的消息类型是INIT_COPY。</p>
<p>处理的代码为下面一段</p>
<pre><code>HandlerParams params = (HandlerParams) msg.obj;
                int idx = mPendingInstalls.size();
                if (DEBUG_INSTALL) Slog.i(TAG, &quot;init_copy idx=&quot; + idx + &quot;: &quot; + params);
                // If a bind was already initiated we dont really
                // need to do anything. The pending install
                // will be processed later on.
                if (!mBound) {
                    Trace.asyncTraceBegin(TRACE_TAG_PACKAGE_MANAGER, &quot;bindingMCS&quot;,
                            System.identityHashCode(mHandler));
                    // If this is the only one pending we might
                    // have to bind to the service again.
                    if (!connectToService()) {
                        Slog.e(TAG, &quot;Failed to bind to media container service&quot;);
                        params.serviceError();
                        Trace.asyncTraceEnd(TRACE_TAG_PACKAGE_MANAGER, &quot;bindingMCS&quot;,
                                System.identityHashCode(mHandler));
                        if (params.traceMethod != null) {
                            Trace.asyncTraceEnd(TRACE_TAG_PACKAGE_MANAGER, params.traceMethod,
                                    params.traceCookie);
                        }
                        return;
                    } else {
                        // Once we bind to the service, the first
                        // pending request will be processed.
                        mPendingInstalls.add(idx, params);
                    }
                } else {
                    mPendingInstalls.add(idx, params);
                    // Already bound to the service. Just make
                    // sure we trigger off processing the first request.
                    if (idx == 0) {
                        mHandler.sendEmptyMessage(MCS_BOUND);
                    }
                }
                break;
</code></pre><p>首先会去检查一个mBound的状态，这个状态表示和系统service的connect结果，PackageHanlder在内部定义了一个方法，connectToService(), 这个service是DefaultContainerService. 在这个类的说明上可以知道这个类主要是做了关于移动存储设备上文件检查和复制的工作。如果这个时候已经成功绑定了服务，那么可以将安装的请求添加到 mPendingInstalls 这个集合当中去。</p>
<p>接下来发送的消息类型是MSC_BOUND<br>在这个消息的处理中还是先判断绑定服务的状态，如果判断当前的状态是没有连接，那么这个时候调用prams的serviceError方法，表示安装失败，这个时候也会清空 mPendingInstalls<br>如果这个时候服务绑定成功，并且mPendingInstalls中有安装请求，这个时候会从集合中拿到第一个安装请求参数，然后开始调用startCopy方法</p>
<pre><code>final boolean startCopy() {
        boolean res;
        try {
            if (DEBUG_INSTALL) Slog.i(TAG, &quot;startCopy &quot; + mUser + &quot;: &quot; + this);
            if (++mRetries &gt; MAX_RETRIES) {
                Slog.w(TAG, &quot;Failed to invoke remote methods on default container service. Giving up&quot;);
                mHandler.sendEmptyMessage(MCS_GIVE_UP);
                handleServiceError();
                return false;
            } else {
                handleStartCopy();
                res = true;
            }
        } catch (RemoteException e) {
            if (DEBUG_INSTALL) Slog.i(TAG, &quot;Posting install MCS_RECONNECT&quot;);
            mHandler.sendEmptyMessage(MCS_RECONNECT);
            res = false;
        }
        handleReturnCode();
        return res;
    }
</code></pre><p>里面加了重试的逻辑，如果重试之后还是失败，那么将进行安装失败通知，核心copy的逻辑在handleStartCopy，这个方法是一个抽象方法，具体的实现看InstallParams。</p>
<pre><code>// If we&apos;re already staged, we&apos;ve firmly committed to an install location
       if (origin.staged) {
           if (origin.file != null) {
               installFlags |= PackageManager.INSTALL_INTERNAL;
               installFlags &amp;= ~PackageManager.INSTALL_EXTERNAL;
           } else if (origin.cid != null) {
               installFlags |= PackageManager.INSTALL_EXTERNAL;
               installFlags &amp;= ~PackageManager.INSTALL_INTERNAL;
           } else {
               throw new IllegalStateException(&quot;Invalid stage location&quot;);
           }
       }
</code></pre><p>方法之中首先开始检查安装的位置，如果找到不到将抛出异常。<br>在检查完安装位置之后，开始安装的的空间是否足够，如果不够，系统会尝试清除一些缓存，再来判断是否可以安装。</p>
<p>如果在上面的检查当中没有出现问题，那么接下来获取安装的位置，并且在这个过程中判断安装是否有版本的回退，如果这个情况也没有，那么将会再设置一次installFlags.</p>
<p>接下来会去检查package verification 是否开启了，如果没有开启将会调用远程服务开始拷贝文件的过程。<br>关于拷贝的过程可以看InstallArgs其中一个子类的实现，FileInstallArgs, copyApk的真正过程在doCopyApk方法当中。</p>
<p>在doCopyApk的方法当中，首先调用了</p>
<pre><code>File tempDir = mInstallerService.allocateStageDirLegacy(volumeUuid, isEphemeral);
</code></pre><p>这个方法用来指定res和code存放的临时目录，在这个步骤中创建了一些临时文件，之所以这么做是因为内部文件系统会为临时文件分配内存，提高效率。</p>
<pre><code>imcs.copyPackage(origin.file.getAbsolutePath(), target);
</code></pre><p>这个imcs的实现在DefaultContainerService当中，安装apk的时候第一步就是检查到这个service的连接。</p>
<p>所以实际上imcs就是 IMediaContainerService.Stub的一个引用，copyPackage 之中又调用了copyPackageInner方法，方法的代码如下</p>
<pre><code>private int copyPackageInner(PackageLite pkg, IParcelFileDescriptorFactory target)
        throws IOException, RemoteException {
    copyFile(pkg.baseCodePath, target, &quot;base.apk&quot;);
    if (!ArrayUtils.isEmpty(pkg.splitNames)) {
        for (int i = 0; i &lt; pkg.splitNames.length; i++) {
            copyFile(pkg.splitCodePaths[i], target, &quot;split_&quot; + pkg.splitNames[i] + &quot;.apk&quot;);
        }
    }
    return PackageManager.INSTALL_SUCCEEDED;
}
</code></pre><p>在copyFile这个方法当中看到了一个熟悉的名字“base.apk”，我们在/data/app/包名下同样有这个文件名的存在，在这里就完成了apk的拷贝。</p>
<p>接下来就是拷贝二进制文件的过程了。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/13/C-动态内存/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Tom Liu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Learning">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/13/C-动态内存/" itemprop="url">C++动态内存</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-02-13T23:12:08+08:00">
                2017-02-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>C++ 支持动态分配对象，动态分配对象的生存周期和他们在哪里创建的无关，这有当显示的释放时，这些对象才会被销毁。</p>
<p>静态内存用来保存局部static变量，类static的成员和任何定义在函数之外的变量。栈内存用来保存定义在函数内的非static对象。分配在静态内存或者栈内存中的对象由编译器自动创建和销毁，对于栈对象，仅在其定义的程序块运行时才存在，static对象在使用前被分配，在程序结束的时候销毁。</p>
<p>除了静态内存和栈内存，每个程序还拥有一个内存池，这部分内存被称作自由空间或者堆，程序用堆来存储动态分配的对象，动态对象的生存周期由程序来控制，<strong>也就是说当动态对象不再使用的时候，我们的代码必须显示的销毁</strong></p>
<p>动态内存和智能指针<br>在C++中，动态内存的管理是通过一对运算符来实现的，<br><strong>new</strong>: 在动态内存中为对象分配空间并返回一个指向该对象的指针，可以选择对对象进行初始化，<br><strong>delete</strong>: 接受一个动态对象指针，销毁该对象，并释放与之关联的内存。</p>
<p>新的标准库提供了两种智能指针，两种智能指针的区别在于管理底层指针的方式，shared_ptr 允许多个指针指向同一个对象，unique_str 则是 “独占”所指向的对象.</p>
<p>shared_ptr 的拷贝和赋值<br>当进行拷或者赋值操作的时候，每个shared_ptr都会记录有多少个其他shared_ptr指向相同的对象。<br>可以认为每个shared_ptr都有一个关联的计数器，通常称其为<em>引用计数</em>,当我们通过任何手段导致指向同一个对象的shared_ptr增加时都会导致引用计数器的递增。当改变了shared_ptr指向的对象，或者shared_ptr被销毁，计数器会递减。<strong>一旦一个shared_ptr的计数器为0，它就会自动释放自己所管理的对象</strong>。</p>
<p>动态生存使用的目的</p>
<ul>
<li>程序自己不知道需要使用多少对象</li>
<li>程序不知道所需对象的准确类型</li>
<li>程序需要在多个对象间共享数据</li>
</ul>
<p><strong>使用new动态分配和初始化对象</strong><br>建议的做法是对动态分配的对象进行初始化</p>
<p>动态创建的对象的时候，任然需要保持构造参数的匹配。</p>
<p>一个动态分配的const对象必须进行初始化，对于定义了默认构造函数的类型，其const对象可以隐式的初始化，而其他的类型必须显式的初始化，</p>
<p><strong>内存耗尽</strong><br>在默认情况下如果new不能分配所要求的内存空间，它会抛出一个类型为bad_alloc的异常。<br>但是可以改变new 的使用方式来变异抛出异常</p>
<pre><code>int* p = new (nothrow) int;
</code></pre><p>这个时候如果分配失败，将返回一个空指针。</p>
<p>这种形式的new称为<em>定位new</em>,定位new表达式将允许向new传达额外的参数</p>
<p><strong>释放内存</strong><br>delete表达式接受一个指针，销毁给定指针指向的对象，释放对应的内存。</p>
<p>传递给delete的指针必须只向动态分配的内存，或者是一个空指针。释放一块非new分配的内存其行为是未定义的。通常情况下编译器不能分辨一个指针指向的内存是静态内存还是动态内存，所以这些问题在编译的时候很难被发现。</p>
<p>在指针delete之后，指针就成了悬空指针，即指向一块曾经保存数据但是现在已经无效的内存的指针。如果我们还需要继续使用这个指针，可以先将其值设为nullptr</p>
<p>当两个指针指向同样的内存，delete了其中一个，此时另外一个也将变得无效。</p>
<p><strong>shared_ptr和new结合使用</strong><br>必须使用直接初始化的方式来初始化一个智能指针,同时不能进行内置指针到隐智能指针的隐式准换。</p>
<pre><code>shared_ptr&lt;int&gt; p1 = new int(1034); // 错误的用法
shared_ptr&lt;int&gt; p2(new int(1024)); // 正确的用法
</code></pre><p>默认情况下用来初始化智能指针的普通指针必须指向动态内存，因为智能指针默认使用delete释放它所关联的对象。</p>
<p>当将一个shared_ptr绑定到一个普通指针的时候，我们就将内存管理的责任交给了这个shared_ptr，一旦这样做了，就不应该在使用再使用内置指针来访问shard_ptr所指向的内存了。</p>
<p>考虑下面一段程序：</p>
<pre><code>void process(shared_ptr&lt;int&gt; ptr) {

} // 离开了这个方法之后，ptr所指向对象的引用计数器会 -1;
</code></pre><p>调用</p>
<pre><code>int* x = new int(88);
process(share_ptr&lt;int&gt;(x)); 
int xValue = *x;
</code></pre><p>当执行完了了process之后，再去访问x实际上会造成未知的结果，因为调用了process方法的时候，我们构建了一个智能指针对象，这个时候为对象的引用计数器 +1，但是离开了process方法之后，智能指针所指对象的引用计数器会 -1，此时对象的引用数最终为0，所以其指向的对象会被释放掉，因此x 这个时候就变成了悬空指针，xValue 去访问x所指的内存就会出现未知的操作。</p>
<p><em>从上面的例子也可以看出来，智能指针的引用计数和内置指针是完全分开的，只要智能指针计算的引用计数为零，这个指针指向的内存就会被释放掉，而并没有在乎是否有内置的指针还指向这块内存</em></p>
<p>智能指针类型定义了一个名为get的函数，它返回一个内置指针，指向智能指针管理的对象，此函数是为了这样一种情况而设计：我们需要向不能使用智能指针的代码传递一个内置指针，使用get返回指针的代码不能delete此指针。</p>
<p>get用来将指针的访问权限传递给代码，只有在确保代码不会delete指针的情况下才能使用get，特别是，永远不要用get初始化一个智能指针或者为另一个智能指针赋值（这是为了避免将一块动态内存绑定到多个独立创建的智能指针上，因为这些独立的智能指针不知道彼此的存在，很可能造成A释放了B正在使用的内存）。</p>
<p><strong>智能指针和异常</strong><br>函数的退出有两种可能，正常处理结束或者发生了异常，无论哪种情况，局部对象都会被销毁。与之相对的是，发生异常时，我们直接管理的内存不会被直接释放掉。</p>
<pre><code>void f() {
    int* x = new int(0);
    //抛出异常，切未在f中处理
    delete x;
}
</code></pre><p>在上面的函数中，在new之后，delete之前出现了异常，且异常尚未在f中捕获，则内存永远都无法释放掉，因为在函数f之外没有指针指向这块内存，因此也就无法释放了。</p>
<p><em>使用自己的释放操作</em><br>默认情况下，shared_ptr在销毁一个对象的时候，它对它管理的指针进行delete操作，但是我们可以设定自己的释放对象操作，来代替默认的操作。例如我们需要释放一个数据库的连接connection，当我们创建创建一个shard_ptr的时候，可以传递一个指向删除器函数的参数，如下 </p>
<pre><code>void end_connection(connection* con) {
    //do something to release connection
}  

//调用
shared_ptr&lt;connection&gt; con_p(connction,end_connection);
</code></pre><p>这样当con_p被销毁的时候，它不会对保存的指针执行delete操作，而是调用end_connection函数，那么不管con_p所处的方法是正常结束还是发生了异常，p都会被销毁，从而保证了连接被关闭。</p>
<p>总结下来，使用智能指针有以下需要注意的地方</p>
<ol>
<li>不使用相同的内置指针初始化多个智能指针</li>
<li>不delete get()返回的内置指针</li>
<li>不使用get 初始化或者reset另一个智能指针</li>
<li>如果使用了get返回的内置指针，当最后一个智能指针被销毁后，这个内置指针也将变得无效</li>
<li>如果使用智能指针管理的资源不是new 分配的内存，那么手动传递给它一个删除器</li>
</ol>
<h2 id="智能指针之Unique-ptr"><a href="#智能指针之Unique-ptr" class="headerlink" title="智能指针之Unique_ptr"></a>智能指针之Unique_ptr</h2><p>一个unique_ptr拥有它所指向的对象，并且某个时候只能有一个unique_ptr指向一个给定的对象，因此unique_ptr不支持普通的拷贝或赋值操作，和shared_ptr类似，初始化unique_ptr必须采用直接初始化的形式。</p>
<p>调用unique_ptr的release方法会切断unique_ptr和它原来管理对象之间的联系，通常release返回的指针被用来初始化另一个智能指针或者给另一个智能指针赋值，我们拿到这个内置指针之后，就由我们来负责指针的销毁。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/09/Andriod中的资源管理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Tom Liu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Learning">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/09/Andriod中的资源管理/" itemprop="url">Andriod中的资源管理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-02-09T12:38:52+08:00">
                2017-02-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Android的安装包本质上是一个zip压缩文件，我们可以使用解压软件打开。<br>其中的resources.arsc 是一个二进制格式的文件，与二进制的xml完全不同，appt在对资源进行编译的时候会为每一个资源分配唯一的id，程序在执行的时候会根据这些id来读取特定的资源，而resources.arsc文件正是包含了所有id资源值得一个数据集合，在该文件中，如果某个id对应的资源是string或者数值，那么该文件会直接包含对应的值，如果id对应的资源是某个layout或者drawable资源，那么该文件会存入对应资源的地址。</p>
<p>安装后的目录如下 </p>
<ul>
<li>/data/app 安装之后，会有一个以报名命名的文件夹在里面，其中base.apk就是用户安装的apk。系统自带的应用在/system/app下面。</li>
<li>/data/dalvik-cache， 每个apk里面都有class.dex，安装之后，所有的dex文件都会放到该目录下面，这样用户在启动APP的时候就可以快速的读取dex文件，而不用解压，在早期版本中，会对dex进行优化，最后生成的odex文件也在这个目录下面，任何程序都可以读写该目录，这就为类的动态加载提供了可能，实际上每个app的dex .</li>
</ul>
<p><strong>styleable, style, attr, theme</strong></p>
<p>styleable 一般和attr联合使用，用于定义一些属性。从AttributeSet对象中获取这三个属性的时候可以，可以传入R.styleable.xxx 这个参数实际上会被编译成一个int []. 数组的内容正是所包含的attrde id。</p>
<p><strong>AttributeSet和TypeArray</strong></p>
<p>AttributeSet 代表了视图属性的集合， TypedArray 类又是对ArributeSet数据的抽象。context.obtainStyledAttribute() ，该函数的内部实现正是通过遍历set中的每一个属性，找到用户感兴趣的属性，然后把值和属性经过重定位返回一个TypedArray对象。</p>
<p>TypedArray 中的内部mValue（类型为一个int 数组）起到了一个内部缓冲的作用，mData 包含了styleable中所有的属性值， 其长度为 styleable 中属性的个数乘以 AssetManager.STYLE_NUM_ENTRIES，AssetManager.STYLE_NUM_ENTRIES的值为6，它实际上表示有6种数据在mData这个数组当中。</p>
<pre><code>static final int STYLE_NUM_ENTRIES = 6;
static final int STYLE_TYPE = 0;
static final int STYLE_DATA = 1;
static final int STYLE_ASSET_COOKIE = 2;
static final int STYLE_RESOURCE_ID = 3;
static final int STYLE_CHANGING_CONFIGURATIONS = 4;
static final int STYLE_DENSITY = 5;
</code></pre><p>比如说我先有一个int 类型的属性值，那么它 实际上在mData中占据了6个 存储位置，从 0 -5 位置上的值分别对应上面的类型。再看如何获取string的存储的，核心方法是调用了 TypedArray的 loadStringValueAt 方法。</p>
<pre><code> public String getString(@StyleableRes int index) {
        if (mRecycled) {
            throw new RuntimeException(&quot;Cannot make calls to a recycled instance!&quot;);
        }

        index *= AssetManager.STYLE_NUM_ENTRIES;
        final int[] data = mData;
        final int type = data[index+AssetManager.STYLE_TYPE];
        if (type == TypedValue.TYPE_NULL) {
            return null;
        } else if (type == TypedValue.TYPE_STRING) {
            return loadStringValueAt(index).toString();
        }

        final TypedValue v = mValue;
        if (getValueAt(index, v)) {
            final CharSequence cs = v.coerceToString();
            return cs != null ? cs.toString() : null;
        }

        throw new RuntimeException(&quot;getString of bad type: 0x&quot; + Integer.toHexString(type));
    }


首页要做的就是找到index在mData中正确的位置，这里将index*=6,如果这里存放的本来就是一个sting那么使用loadStringValueAt，如果不是，那么将调用 TypedValue的 coerceTOsTRING();
</code></pre><p>再来看 loadStringValueAt方法 </p>
<pre><code>private CharSequence loadStringValueAt(int index) {
    final int[] data = mData;
    final int cookie = data[index+AssetManager.STYLE_ASSET_COOKIE];
    if (cookie &lt; 0) {
        if (mXml != null) {
            return mXml.getPooledString(
                data[index+AssetManager.STYLE_DATA]);
        }
        return null;
    }
    return mAssets.getPooledStringForCookie(cookie, data[index+AssetManager.STYLE_DATA]);
}

首先尝试获取字符串的cookie,cookie如果有效的话将会从mXml（mXml是用于解析二进制xml的对象）中去加载，无效的话将调用AssetManager的 getPooledStringForCookie 方法，
</code></pre><p><strong>获取资源</strong><br>获取资源通常需要Resource对象，在构建Resource对象的过程中需要一个AssertManager。</p>
<pre><code>  public AssetManager() {
    synchronized (this) {
        if (DEBUG_REFS) {
            mNumRefs = 0;
            incRefsLocked(this.hashCode());
        }
        init(false);
        if (localLOGV) Log.v(TAG, &quot;New asset manager: &quot; + this);
        ensureSystemAssets();
    }
}
</code></pre><p>init 是一个navtive的方法，它会尝试去加载/system/framework-res.apk， 这样APP就可以使用系统提供的资源。</p>
<p>通过尝试去跟Resource. getXXX方法， 最终都是调用了AssetManager的方法。<br>而AssetManager最终又是采用JNI的方式来获取资源。 </p>
<pre><code>static jint android_content_AssetManager_loadResourceValue(JNIEnv* env, jobject clazz,
                                                       jint ident,
                                                       jshort density,
                                                       jobject outValue,
                                                       jboolean resolve)
{
    AssetManager* am = assetManagerForJavaObject(env, clazz);
    if (am == NULL) {
        return 0;
    }
    const ResTable&amp; res(am-&gt;getResources());
    Res_value value;
    ResTable_config config;
    uint32_t typeSpecFlags;
    ssize_t block = res.getResource(ident, &amp;value, false, density, &amp;typeSpecFlags, &amp;config);
#if THROW_ON_BAD_ID
    if (block == BAD_INDEX) {
        jniThrowException(env, &quot;java/lang/IllegalStateException&quot;, &quot;Bad resource!&quot;);
        return 0;
    }
#endif
    uint32_t ref = ident;
    if (resolve) {
        block = res.resolveReference(&amp;value, block, &amp;ref, &amp;typeSpecFlags, &amp;config);
#if THROW_ON_BAD_ID
        if (block == BAD_INDEX) {
            jniThrowException(env, &quot;java/lang/IllegalStateException&quot;, &quot;Bad resource!&quot;);
            return 0;
        }
#endif
    }
    return block &gt;= 0 ? copyValue(env, outValue, &amp;res, value, ref, block, typeSpecFlags, &amp;config) : block;
}
</code></pre><p>首先通过获取ResTable ,让后从resTable 当中去找到相应的资源，这里的ResTable实际上就是apk文件解压出来之后的resources.arsc。</p>
<p><strong>Framework资源</strong></p>
<p><em>加载和读取</em><br>系统资源是在zygote 进程启动的时候加载的，并且只有在加载系统资源完成之后才开始启动其他的应用进程，从而实现其他应用进程共享系统资源的目标，</p>
<p>方法的调用栈 ZyogteInit.main() -&gt; preload() -&gt; preloadResources() , 系统加载完这些资源之后会在ResoucesImpl通过集合缓存起来。</p>
<pre><code>// Information about preloaded resources.  Note that they are not
// protected by a lock, because while preloading in zygote we are all
// single-threaded, and after that these are immutable.
private static final LongSparseArray&lt;Drawable.ConstantState&gt;[] sPreloadedDrawables;
private static final LongSparseArray&lt;Drawable.ConstantState&gt; sPreloadedColorDrawables
        = new LongSparseArray&lt;&gt;();
private static final LongSparseArray&lt;android.content.res.ConstantState&lt;ComplexColor&gt;&gt;
        sPreloadedComplexColors = new LongSparseArray&lt;&gt;();
</code></pre><p>在ResouscesImpl 内有一个成员变量mPreloading ， 这个值只会在 startPreloading()和 finishPreloading 这两个方法当中被改变，而这两个方法又只会在Zygote进程中被调用，所以当mPreloading为true的时候， 是Zygote 进程正在加载系统资源。所以在ResourcesImpl的cacheDrawble方法当中，可以看到</p>
<pre><code>if (mPreloading) {
        final int changingConfigs = cs.getChangingConfigurations();
        if (isColorDrawable) {
            if (verifyPreloadConfig(changingConfigs, 0, value.resourceId, &quot;drawable&quot;)) {
                sPreloadedColorDrawables.put(key, cs);
            }
        } else {
            if (verifyPreloadConfig(
                    changingConfigs, LAYOUT_DIR_CONFIG, value.resourceId, &quot;drawable&quot;)) {
                if ((changingConfigs &amp; LAYOUT_DIR_CONFIG) == 0) {
                    // If this resource does not vary based on layout direction,
                    // we can put it in all of the preload maps.
                    sPreloadedDrawables[0].put(key, cs);
                    sPreloadedDrawables[1].put(key, cs);
                } else {
                    // Otherwise, only in the layout dir we loaded it for.
                    sPreloadedDrawables[mConfiguration.getLayoutDirection()].put(key, cs);
                }
            }
        }
    }
</code></pre><p>如果mPreloading 是true，那么这个时候是在执行ZygoteInit进程，所以这些数据会被缓存到静态变量当中去。这里加载的Framework的资源，加载的仅仅只是一小部分，对于那些非”预装载”的系统资源则不会缓存到静态集合变量中，在这种情况下，如果应用京城需要一个非预装载的资源，则会在各个进程中保持一个资源的缓存。</p>
<hr>
<p>关于 <a href="https://github.com/fengjundev/Android-Skin-Loader" target="_blank" rel="external">动态加载皮肤框架</a>的实现 </p>
<p><strong>获取新的资源对象 Resources ?</strong><br>简单的概括一下就是通过AssetManager 来构建一个新的Resouce对象。</p>
<pre><code>AssetManager assetManager = AssetManager.class.newInstance();
Method addAssetPath = assetManager.getClass().getMethod(&quot;addAssetPath&quot;, String.class);
addAssetPath.invoke(assetManager, skinPkgPath);
Resources superRes = context.getResources();
Resources skinResource = new                        Resources(assetManager,superRes.getDisplayMetrics(),superRes.getConfiguration());
</code></pre><p>这样既可以获取到一个指向新资源的 Resource 对象。</p>
<p>在获取新的资源对象的时候，先根据现有资源的id来获取资源的字符串名字，就是我们开发的时候给资源的命名，然后根据命名来在新的 Resource对象中 获取相应的资源。</p>
<pre><code>String resName = context.getResources().getResourceEntryName(resId);
int trueResId = mResources.getIdentifier(resName, &quot;color&quot;, skinPackageName);
int trueColor = 0;
try{
    trueColor = mResources.getColor(trueResId);
}catch(NotFoundException e){
    e.printStackTrace();
    trueColor = originColor;
}
return trueColor;
</code></pre><p>拿到资源之后替换即可。</p>
<p><strong>如何获取需要更换皮肤的View.</strong><br>在作者的实现如下，<br>在布局文件中为每一个需要替换皮肤的View 添加了一个属性 skin:enable=”true” ， 同时为LayoutInflator指定自定义的Factory， 在LayoutInflator解析这个布局文件的时候，会调用Factory的onCreateView 方法，这样可以在这里获取到所有添加了 <em>skin:enable=”true”</em> 这个标签的View.</p>
<pre><code>@Override
protected void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
    mSkinInflaterFactory = new SkinInflaterFactory();
    getLayoutInflater().setFactory(mSkinInflaterFactory);
}
</code></pre><p>自定义Factory的核心方法如下</p>
<pre><code>@Override
public View onCreateView(String name, Context context, AttributeSet attrs) {
    // if this is NOT enable to be skined , simplly skip it 
    boolean isSkinEnable = attrs.getAttributeBooleanValue(SkinConfig.NAMESPACE, SkinConfig.ATTR_SKIN_ENABLE, false);
    if (!isSkinEnable){
            return null;
    }
    View view = createView(context, name, attrs);
    if (view == null){
        return null;
    }
    parseSkinAttr(context, attrs, view);
    return view;
}
</code></pre><p>解决以上两个问题，换肤就好实现了。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/03/Google-MVVM-示例代码分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Tom Liu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Learning">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/03/Google-MVVM-示例代码分析/" itemprop="url">Google MVVM 示例代码分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-02-03T22:54:03+08:00">
                2017-02-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>项目的代码位于 <a href="https://github.com/googlesamples/android-architecture/tree/dev-todo-mvvm-databinding/" target="_blank" rel="external">github</a> 上</p>
<p>项目中采用了MVVM方式进行开发，与之前的MVP项目模式相比，直接去掉了MVP模式中的Presenter，数据加载的操作直接用ViewModel中开始. 在获取到了数据之后，通过databiding 来完成数据的展示。</p>
<p>在to-do中，有几个部分，下面是主界面的分析内容。</p>
<p>在TasksViewModel 这个类当中，封装了数据所有的操作，包括数据的加载，判空（isEmpty），清除， 添加过滤条件。</p>
<p>同时应该注意到TasksViewModel 继承了 BaseObservable 这个对象，BaseObservable 最终实现了Observable 接口， 这个接口提供了让数据绑定的UI接受数据变化的通知。<br>同时 BaseObservable 还有其他的类型的子类，例如 ObservableField 等。</p>
<p>在 TasksViewModel 我们也可以找到 BaseObservable 类型的属性，通过这些属性，可以监听到具体属性值 的变化。</p>
<p>除了属性值之外，还可以将方法转可以监听的对象，做法就是给方法加上  @Bindable 注解。<br>下面是这个注解的说明</p>
<p><em>The Bindable annotation should be applied to any getter accessor method of an<br> {@link Observable} class. Bindable will generate a field in the BR class to identify<br> the field that has changed.</em></p>
<p>它用来修饰任意一个get method，被这个注解修饰的方法会在 BR.java这个类中生成对应的属性，例如如果定义了 String getName()方法，那么就会在BR中添加一个name的常量字段。当数据发生变化我们需要通过getName来获取最新的数据的时候，调用 BaseObserverable 的 notifyPropertyChanged(BR.name)，之后getName将再次被调用。</p>
<p>同时也可以看到这个被 @Bindable 注解修饰的方法，可以在 布局文件中直接通过 xxx.name 的方式来访问。</p>
<p>上面说到数据加载操作也是在TasksViewModel中完成的，在loadTasks方法中 调用了 mTasksRepository 的 getTasks， 然后在callback中将数据 添加到了 items当中去，<br>item 是一个 ObservableList </p>
<pre><code>public final ObservableList&lt;Task&gt; items = new ObservableArrayList&lt;&gt;();
</code></pre><p>当调用了 <em>items.addAll(tasksToShow);</em> 方法之后，数据就被绑定到界面上去了。</p>
<p>下面跟踪一下，数据绑定是如何实现的。</p>
<p>在TasksViewModel当中，有一个 ObservableBoolean类型的成员变量dataLoading.在这个类中提供了一个set方法，在改变了value的值之后，它调用了notifyChange(); </p>
<p>notifyChange 是一个定义在其父类 BaseObservable 中的一个同步的方法， 这个方法当中简单调用了PropertyChangeRegistry 这个类的 notifyCallbacks 方法 ，进入到notifyCallbacks 方法，实际上这个方法又是定义在其父类CallbackRegistry之中，通过CallbackRegistry的说明可知，这个类是用来存放callback和进行各种回调的，但是CallbackRegistry对于回调的处理实际上只是对回调的集合进行了管理，它通过递归的方式来通知集合中所有的回调，这里之所以采用递归的方式，文档之中给出的说明是避免在堆上进行临时状态的分配（但是采用递归需要每次都在栈上分配内存，并且堆上同样会有内存的分配，这里还不清楚），既然CallbackRegistry只是集合回调的管理，那么真正的回调应该如何处理实际上 是通过其内部类 NotifierCallback 来完成。</p>
<pre><code>/**
 * Class used to notify events from CallbackRegistry.
 *
 * @param &lt;C&gt; The callback type.
 * @param &lt;T&gt; The notification sender type. Typically this is the containing class.
 * @param &lt;A&gt; An opaque argument to pass to the notifier
 */
public abstract static class NotifierCallback&lt;C, T, A&gt; {
    /**
     * Called by CallbackRegistry during
     * {@link CallbackRegistry#notifyCallbacks(Object, int, Object)}} to notify the callback.
     *
     * @param callback The callback to notify.
     * @param sender The opaque sender object.
     * @param arg The opaque notification parameter.
     * @param arg2 An opaque argument passed in
     *        {@link CallbackRegistry#notifyCallbacks}
     * @see CallbackRegistry#CallbackRegistry(CallbackRegistry.NotifierCallback)
     */
    public abstract void onNotifyCallback(C callback, T sender, int arg, A arg2);
}
</code></pre><p>通过实际上在CallbackRegistry 处理回调的时候就是调用了其 onNotifyCallback来处理。</p>
<p>所以在CallbackRegistry 的说明中可以看到 一句话 ：<em>A subclass of CallbackRegistry.NotifierCallback must be passed to the constructor to define how notifications should be called</em></p>
<p>简单说就是由 NotifierCallback的子类来处理notification。</p>
<p>回到 PropertyChangeRegistry 当中看 NOTIFIER_CALLBACK</p>
<pre><code>private static final CallbackRegistry.NotifierCallback&lt;Observable.OnPropertyChangedCallback, Observable, Void&gt; NOTIFIER_CALLBACK = new CallbackRegistry.NotifierCallback&lt;Observable.OnPropertyChangedCallback, Observable, Void&gt;() {
    @Override
    public void onNotifyCallback(Observable.OnPropertyChangedCallback callback, Observable sender,
            int arg, Void notUsed) {
        callback.onPropertyChanged(sender, arg);
    }
};
</code></pre><p>在接收到通知之后，实际上会调用Observable.OnPropertyChangedCallback的 onPropertyChanged 方法。</p>
<p>从上面的分析可以看来，CallbackRegistry 实际上是一个事件分发中心和订阅中，所有的事件回调都是通过CallbackRegistry来处理，但是真正对事件的处理，却是通过自定义的 NotifierCallback来完成的。</p>
<p>在android的databinding中，同样是通过这样一套机制来工作的，在ViewDataBinding中，定义了WeakPropertyListener，通过重写 onPropertyChanged  方法完成对数据的重新绑定。</p>
<p>回到 TasksFragBinding.java 这个类是tasks_frag_xml这个文件生成的。<br>在其中定义了一个变量， mViewmodel ，因此在这个类中，也为我们生成了一个setViewmodel 方法，在这个方法当中，完成了对数据的mViewmodel 的赋值，然后调用了notifyPropertyChanged 方法，这个方法在前面提到过，定义BaseObservable 当中，所以可以简单的推断 ViewDataBinding 也是继承于BaseObservable。</p>
<p>通过mViewmodel 同样可以推断出，如果我们只是修改了 mViewmodel 的内部属性是无法导致试图被刷新的（已经验证），所以在TaskViewModel 这个类中，我们可以看到，在定义了 private final ObservableField<task> mTaskObservable = new ObservableField&lt;&gt;();之后有这么一段代码 </task></p>
<pre><code>mTaskObservable.addOnPropertyChangedCallback(new OnPropertyChangedCallback() {
        @Override
        public void onPropertyChanged(Observable observable, int i) {
            Task task = mTaskObservable.get();
            if (task != null) {
                title.set(task.getTitle());
                description.set(task.getDescription());
            } else {
                title.set(mContext.getString(R.string.no_data));
                description.set(mContext.getString(R.string.no_data_description));
            }
        }
    });
</code></pre><p>需要自己手动去添加一个监听器来数据的更新。</p>
<p>参照这个例子，如果需要一个更新了成员变量也会刷新对应试图的对象，应该这么定义 </p>
<pre><code>public class Task {
    public final ObservableField&lt;String&gt; title = new ObservableField();
    public final ObservableField&lt;String&gt; content = new ObservableField();

    public Task(String title, String content) {
        this.title.set(title);
        this.content.set(content);
    }

    public void setContent(String content) {
        this.content.set(content);
    }
}
</code></pre><p>对应的布局文件如下</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;layout  xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;
    &lt;data&gt;
        &lt;variable
            name=&quot;task&quot;
            type=&quot;com.devtom.databindingtest.Task&quot;/&gt;
    &lt;/data&gt;

    &lt;RelativeLayout
        xmlns:tools=&quot;http://schemas.android.com/tools&quot;
        android:id=&quot;@+id/activity_main&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;
        android:paddingBottom=&quot;@dimen/activity_vertical_margin&quot;
        android:paddingLeft=&quot;@dimen/activity_horizontal_margin&quot;
        android:paddingRight=&quot;@dimen/activity_horizontal_margin&quot;
        android:paddingTop=&quot;@dimen/activity_vertical_margin&quot;
        tools:context=&quot;com.devtom.databindingtest.MainActivity&quot;&gt;

        &lt;TextView
            android:id=&quot;@+id/title&quot;
            android:layout_width=&quot;wrap_content&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:layout_centerHorizontal=&quot;true&quot;
            android:text=&quot;@{task.title}&quot; /&gt;

        &lt;TextView
            android:id=&quot;@+id/content&quot;
            android:layout_width=&quot;wrap_content&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:layout_centerInParent=&quot;true&quot;
            android:text=&quot;@{task.content}&quot; /&gt;

        &lt;Button
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:text=&quot;Change&quot;
            android:onClick=&quot;change&quot;
            android:layout_alignParentBottom=&quot;true&quot;
            /&gt;
    &lt;/RelativeLayout&gt;
&lt;/layout&gt;
</code></pre><p>Activity 代码如下</p>
<pre><code>public class MainActivity extends AppCompatActivity {
        private Task task;
        @Override
        protected void onCreate(Bundle savedInstanceState) {
            super.onCreate(savedInstanceState);
            setContentView(R.layout.activity_main);
            View view = this.findViewById(R.id.activity_main);
            ActivityMainBinding mainBinding = DataBindingUtil.bind(view);
            task = new Task(&quot;this is title&quot;,&quot;kai gong da ji&quot;);
            mainBinding.setTask(task);
        }

        public void change(View view) {
            task.setContent(&quot;this is chinese new year&quot;);
        }
}
</code></pre><p>当手动的去改变task的某一个属性的时候，也会去刷新对应的试图。</p>
<p>这里需要注意的是Task其中的两个成员变量可以定义为public的也可以定义为private 然后给他添加对应的private 方法。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/01/28/Android中AIDL的理解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Tom Liu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Learning">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/01/28/Android中AIDL的理解/" itemprop="url">Android中AIDL的理解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-01-28T19:39:45+08:00">
                2017-01-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>首先定义 </p>
<pre><code>// IMyService.aidl
package com.devtom.myservice;

interface IMyService {
    void printLog(String message);
}
</code></pre><p>定义完成了之后，编译工具会自动帮我们生成接口相关的文件。<br>生成的代码文件如下</p>
<pre><code>package com.devtom.myservice;

public interface IMyService extends android.os.IInterface {
    /**
     * Local-side IPC implementation stub class.
     */
    public static abstract class Stub extends android.os.Binder implements com.devtom.myservice.IMyService {
        private static final java.lang.String DESCRIPTOR = &quot;com.devtom.myservice.IMyService&quot;;

        /**
         * Construct the stub at attach it to the interface.
         */
        public Stub() {
            this.attachInterface(this, DESCRIPTOR);
        }

        /**
         * Cast an IBinder object into an com.devtom.myservice.IMyService interface,
         * generating a proxy if needed.
         */
        public static com.devtom.myservice.IMyService asInterface(android.os.IBinder obj) {
            if ((obj == null)) {
                return null;
            }
            android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);
            if (((iin != null) &amp;&amp; (iin instanceof com.devtom.myservice.IMyService))) {
                return ((com.devtom.myservice.IMyService) iin);
            }
            return new com.devtom.myservice.IMyService.Stub.Proxy(obj);
        }

        @Override
        public android.os.IBinder asBinder() {
            return this;
        }

        @Override
        public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException {
            switch (code) {
                case INTERFACE_TRANSACTION: {
                    reply.writeString(DESCRIPTOR);
                    return true;
                }
                case TRANSACTION_printLog: {
                    data.enforceInterface(DESCRIPTOR);
                    java.lang.String _arg0;
                    _arg0 = data.readString();
                    this.printLog(_arg0);
                    reply.writeNoException();
                    return true;
                }
            }
            return super.onTransact(code, data, reply, flags);
        }

        private static class Proxy implements com.devtom.myservice.IMyService {
            private android.os.IBinder mRemote;

            Proxy(android.os.IBinder remote) {
                mRemote = remote;
            }

            @Override
            public android.os.IBinder asBinder() {
                return mRemote;
            }

            public java.lang.String getInterfaceDescriptor() {
                return DESCRIPTOR;
            }

            @Override
            public void printLog(java.lang.String message) throws android.os.RemoteException {
                android.os.Parcel _data = android.os.Parcel.obtain();
                android.os.Parcel _reply = android.os.Parcel.obtain();
                try {
                    _data.writeInterfaceToken(DESCRIPTOR);
                    _data.writeString(message);
                    mRemote.transact(Stub.TRANSACTION_printLog, _data, _reply, 0);
                    _reply.readException();
                } finally {
                    _reply.recycle();
                    _data.recycle();
                }
            }
        }

        static final int TRANSACTION_printLog = (android.os.IBinder.FIRST_CALL_TRANSACTION + 0);
    }

    public void printLog(java.lang.String message) throws android.os.RemoteException;
}
</code></pre><p>再来看看service相关的实现</p>
<pre><code>public class MyRemoteService extends Service {

    private static final String TAG = &quot;MyRemoteService&quot;;

    public static class MyServiceBinder extends IMyService.Stub {
        @Override
        public void printLog(String message) throws RemoteException {
            Log.e(TAG, &quot;this is message from remote &quot; + message);
        }
    }

    private MyServiceBinder binder;

    @Override
    public void onCreate() {
        super.onCreate();
        binder = new MyServiceBinder();
    }

    @Nullable
    @Override
    public IBinder onBind(Intent intent) {
        return binder;
    }
}
</code></pre><p>客户端调用的代码如下 </p>
<pre><code>public class MainActivity extends Activity {

    private IMyService binder;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        Intent intent = new Intent(this, MyRemoteService.class);
        bindService(intent, serviceConnection, Service.BIND_AUTO_CREATE);
        this.findViewById(R.id.test).setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                try {
                    binder.printLog(&quot;this is message from client&quot;);
                } catch (RemoteException e) {
                    e.printStackTrace();
                }
            }
        });
    }

    private ServiceConnection serviceConnection = new ServiceConnection() {
        @Override
        public void onServiceConnected(ComponentName name, IBinder service) {
            binder = MyRemoteService.MyServiceBinder.asInterface(service);
        }

        @Override
        public void onServiceDisconnected(ComponentName name) {
            binder = null;
        }
    };
}
</code></pre><p>目前按照个人理解 </p>
<ol>
<li><p>MainActivity当中通过ServiceConnect 拿到的对象实际上是IMyService 当中的Proxy 对象的引用，之所以会有这个代理对象的存在，目前的理解是，系统为了方便我们调用，通过这个代理对象完成了调用远程服务数据的封装，所以我们在Proxy当中可以看到代理对printLog的实现：</p>
<pre><code>@Override
public void printLog(java.lang.String message) throws android.os.RemoteException {
    android.os.Parcel _data = android.os.Parcel.obtain();
    android.os.Parcel _reply = android.os.Parcel.obtain();
    try {
        _data.writeInterfaceToken(DESCRIPTOR);
        _data.writeString(message);
        mRemote.transact(Stub.TRANSACTION_printLog, _data, _reply, 0);
        _reply.readException();
    } finally {
        _reply.recycle();
        _data.recycle();
    }
}
</code></pre></li>
</ol>
<p>在Proxy的实现中，主要是完成了对数据的封装，并没有实现其他的逻辑，完成数据的封装之后，然后调用了 mRemote的transact方法。</p>
<ol>
<li><p>Proxy 中成员变量 mRemote 所指向的对象是 IMyService.Stub ,因为Stub 是一个抽象类，所以最终mRemote指向的实例也就是IMyService.Stub 的实现类了</p>
<pre><code> @Override
public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException {
    switch (code) {
        case INTERFACE_TRANSACTION: {
            reply.writeString(DESCRIPTOR);
            return true;
        }
        case TRANSACTION_printLog: {
            data.enforceInterface(DESCRIPTOR);
            java.lang.String _arg0;
            _arg0 = data.readString();
            this.printLog(_arg0);
            reply.writeNoException();
            return true;
        }
    }
    return super.onTransact(code, data, reply, flags);
}
</code></pre><p> 在onTransact 方法当中实现了对数据的解析，将获取到的数据传给自己定义的方法当中去，最终调用了自己实现的方法。</p>
</li>
</ol>
<p>３.通过这个例子，最重要的还是里面的Binder， 数据的传递，解析都是Binder这个对象来完成的。</p>
<p>知道AIDL 的套路之后，可以自己手写一个实现。</p>
<pre><code>public class MyServiceBinderImpl extends Binder implements MyServiceInterface, IInterface{

    public static final String TAG  = &quot;MyServiceBinderImpl&quot;;

    public static final String DESCRIPTOR = &quot;com.devtom.myservice.MyServiceBinderImpl&quot;;

    @Override
    protected boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException {
        switch (code) {
            case INTERFACE_TRANSACTION:
                reply.writeString(DESCRIPTOR);
                break;
            case Binder.FIRST_CALL_TRANSACTION + 0:
                data.enforceInterface(DESCRIPTOR);
                String strData = data.readString();
                printLog(strData);
                reply.writeNoException();
                break;
        }
        return super.onTransact(code, data, reply, flags);
    }

    @Override
    public void printLog(String message) {
        Log.e(TAG, &quot;this message is &quot; + message);
    }

    @Override
    public IBinder asBinder() {
        return this;
    }
}
</code></pre><p>这个实际上就是自己动手去解析数据。</p>
<p>调用了也很简单 ，</p>
<pre><code>android.os.Parcel _data = android.os.Parcel.obtain();
           android.os.Parcel _reply = android.os.Parcel.obtain();
           try {
               _data.writeInterfaceToken(MyServiceBinderImpl.DESCRIPTOR);
               _data.writeString(&quot;this my own aidl implement&quot;);
               binder.transact(IMyService.Stub.TRANSACTION_printLog, _data, _reply, 0);
               _reply.readException();
           } catch (RemoteException e) {

           } finally {
               _reply.recycle();
               _data.recycle();
           }
</code></pre><p>此处的binder对象就是从ServiceConnection的onServiceConnected 方法参数中获取的，因为我们去掉了代理帮帮我们封装数据，所以这里就只能自己手动的去封装数据了。</p>
<p>其实从上面自己手动实现AIDL 的功能可以看出，我们新建的service只是为了方便我们自己调用，我们完全可以去掉了这些方法（printLog）在onTrasaction里面来实现各种功能,当然这个只是扯淡。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/01/22/Android中的状态保存/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Tom Liu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Learning">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/01/22/Android中的状态保存/" itemprop="url">Android中的状态保存</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-01-22T23:07:38+08:00">
                2017-01-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在Android中，当我们的Acitivity 被系统干掉的时候，会给我们一次保存数据的机会，我们通过可以通过这个机会来将需要的数据保存下来，然后在用户从新打开APP的时候，把这个数据恢复。</p>
<p>先来看一下Activity是怎么保存数据的 </p>
<p>先来看一下onSaveInstanceState()方法 </p>
<pre><code>protected void onSaveInstanceState(Bundle outState) {
    outState.putBundle(WINDOW_HIERARCHY_TAG, mWindow.saveHierarchyState());
    Parcelable p = mFragments.saveAllState();
    if (p != null) {
        outState.putParcelable(FRAGMENTS_TAG, p);
    }
    getApplication().dispatchActivitySaveInstanceState(this, outState);
}
</code></pre><p>代码非常的简单，保存了3个对象的状态，分别是mWindow, mFragments和 Application 对象<br>mWindow的实际实现对象是PhoneWindow, 我们进入到 saveHierarchyState() 方法看看 </p>
<pre><code>    /** {@inheritDoc} */
@Override
public Bundle saveHierarchyState() {
    Bundle outState = new Bundle();
    if (mContentParent == null) {
        return outState;
    }

    SparseArray&lt;Parcelable&gt; states = new SparseArray&lt;Parcelable&gt;();
    mContentParent.saveHierarchyState(states);
    outState.putSparseParcelableArray(VIEWS_TAG, states);

    // Save the focused view ID.
    final View focusedView = mContentParent.findFocus();
    if (focusedView != null &amp;&amp; focusedView.getId() != View.NO_ID) {
        outState.putInt(FOCUSED_ID_TAG, focusedView.getId());
    }

    // save the panels
    SparseArray&lt;Parcelable&gt; panelStates = new SparseArray&lt;Parcelable&gt;();
    savePanelState(panelStates);
    if (panelStates.size() &gt; 0) {
        outState.putSparseParcelableArray(PANELS_TAG, panelStates);
    }

    if (mDecorContentParent != null) {
        SparseArray&lt;Parcelable&gt; actionBarStates = new SparseArray&lt;Parcelable&gt;();
        mDecorContentParent.saveToolbarHierarchyState(actionBarStates);
        outState.putSparseParcelableArray(ACTION_BAR_TAG, actionBarStates);
    }
    return outState;
}
</code></pre><p>首先是尝试去保存 mContentParent 的状态， 这个mContentParent 实际上就是在DecorView中 id 为 content的 ViewGroup, 我们setContetnView中添加的View就是放在了它的下面。mContentParent 是FrameLayout， 最终类型就是ViewGroup。先看看ViewGroup的父类 View怎么实现 saveHierarchyState .saveHierarchyState 调用了 dispatchSaveInstanceState，而这个方法是View中的方法，</p>
<pre><code>protected void dispatchSaveInstanceState(SparseArray&lt;Parcelable&gt; container) {
    if (mID != NO_ID &amp;&amp; (mViewFlags &amp; SAVE_DISABLED_MASK) == 0) {
        mPrivateFlags &amp;= ~PFLAG_SAVE_STATE_CALLED;
        Parcelable state = onSaveInstanceState();
        if ((mPrivateFlags &amp; PFLAG_SAVE_STATE_CALLED) == 0) {
            throw new IllegalStateException(
                    &quot;Derived class did not call super.onSaveInstanceState()&quot;);
        }
        if (state != null) {
            // Log.i(&quot;View&quot;, &quot;Freezing #&quot; + Integer.toHexString(mID)
            // + &quot;: &quot; + state);
            container.put(mID, state);
        }
    }
}
</code></pre><p>实际上就是把onSaveInstanceState 放的返回值 保存了起来，在这里我们可以看到，这里是根据mID 也就是我们在布局文件为View指定的id来保存状态的，同时因为 SparseArray 是一个key ,value的键值对集合，所以这里，如果指定了相同的key,前面的key对应的view状态会被后来的覆盖掉，所以要尽量避免key的重复。</p>
<p>再来看 ViewGroup的 dispatchSaveInstanceState 方法。</p>
<pre><code>@Override
protected void dispatchSaveInstanceState(SparseArray&lt;Parcelable&gt; container) {
    super.dispatchSaveInstanceState(container);
    final int count = mChildrenCount;
    final View[] children = mChildren;
    for (int i = 0; i &lt; count; i++) {
        View c = children[i];
        if ((c.mViewFlags &amp; PARENT_SAVE_DISABLED_MASK) != PARENT_SAVE_DISABLED) {
            c.dispatchSaveInstanceState(container);
        }
    }
}
</code></pre><p>ViewGroup 首先调用了View的dispatchSaveInstanceState 方法来保存自身的状态，然后调用了其子View 的dispatchSaveInstanceState 方法来保存 子view的 状态。这样最终的ViewTree的状态就被保存下来了。</p>
<p>Activity 把View的状态都存下来了之后，再开始存Fragment的状态<br>Fragment状态的保存实在FragmentManager的saveAllState()方法来完成的，在这个方法当中调用了<br>saveFragmentBasicState()方法，</p>
<pre><code> Bundle saveFragmentBasicState(Fragment f) {
    Bundle result = null;

    if (mStateBundle == null) {
        mStateBundle = new Bundle();
    }
    f.performSaveInstanceState(mStateBundle);
    if (!mStateBundle.isEmpty()) {
        result = mStateBundle;
        mStateBundle = null;
    }

    if (f.mView != null) {
        saveFragmentViewState(f);
    }
    if (f.mSavedViewState != null) {
        if (result == null) {
            result = new Bundle();
        }
        result.putSparseParcelableArray(
                FragmentManagerImpl.VIEW_STATE_TAG, f.mSavedViewState);
    }
    if (!f.mUserVisibleHint) {
        if (result == null) {
            result = new Bundle();
        }
        // Only add this if it&apos;s not the default value
        result.putBoolean(FragmentManagerImpl.USER_VISIBLE_HINT_TAG, f.mUserVisibleHint);
    }

    return result;
}
</code></pre><p>performSaveInstanceState 的代码如下 </p>
<pre><code>void performSaveInstanceState(Bundle outState) {
    onSaveInstanceState(outState);
    if (mChildFragmentManager != null) {
        Parcelable p = mChildFragmentManager.saveAllState();
        if (p != null) {
            outState.putParcelable(Activity.FRAGMENTS_TAG, p);
        }
    }
}
</code></pre><p>performSaveInstanceState onSaveInstanceState 方法，在这个方法里面我们可以保存自己想要保存的信息，之后又开始调用FragmentManamager 的 saveAllState()方法，就是递归调用了。跳出这个方法，接着看 saveFragmentViewState()</p>
<pre><code>    void saveFragmentViewState(Fragment f) {
    if (f.mView == null) {
        return;
    }
    if (mStateArray == null) {
        mStateArray = new SparseArray&lt;Parcelable&gt;();
    } else {
        mStateArray.clear();
    }
    f.mView.saveHierarchyState(mStateArray);
    if (mStateArray.size() &gt; 0) {
        f.mSavedViewState = mStateArray;
        mStateArray = null;
    }
}
</code></pre><p>关键的代码是  f.mView.saveHierarchyState(mStateArray);这个方法保存开始保存View的信息， 这个就是在开始分析的保存ViewTree那一部分的内容了。</p>
<p>在上面的内容保存完了还要保存当前已经添加的Fragment的信息，和回退栈的信息。</p>
<pre><code>// Build list of currently added fragments.
   if (mAdded != null) {
       N = mAdded.size();
       if (N &gt; 0) {
           added = new int[N];
           for (int i=0; i&lt;N; i++) {
               added[i] = mAdded.get(i).mIndex;
               if (added[i] &lt; 0) {
                   throwException(new IllegalStateException(
                           &quot;Failure saving state: active &quot; + mAdded.get(i)
                           + &quot; has cleared index: &quot; + added[i]));
               }
               if (DEBUG) Log.v(TAG, &quot;saveAllState: adding fragment #&quot; + i
                       + &quot;: &quot; + mAdded.get(i));
           }
       }
   }

   // Now save back stack.
   if (mBackStack != null) {
       N = mBackStack.size();
       if (N &gt; 0) {
           backStack = new BackStackState[N];
           for (int i=0; i&lt;N; i++) {
               backStack[i] = new BackStackState(this, mBackStack.get(i));
               if (DEBUG) Log.v(TAG, &quot;saveAllState: adding back stack #&quot; + i
                       + &quot;: &quot; + mBackStack.get(i));
           }
       }
   }
</code></pre><p><strong>所以在Fragment保存的内容当中一共是当前active fragment的信息，已经添加的fragment 信息，和回退栈的信息，三部分</strong></p>
<p>在回到Activity 的onSaveInstanceState 方法当中去，最后一步就是通知注册在Application当中的Activity 生命周期的回调。</p>
<p>onSaveInstanceState() 一般在onStop之前调用，再到ActivityThread的performStopActivity方法看看</p>
<pre><code>final void performStopActivity(IBinder token, boolean saveState, String reason) {
    ActivityClientRecord r = mActivities.get(token);
    performStopActivityInner(r, null, false, saveState, reason);
}
</code></pre><p>首先获取了了 一个 ActivityClientRecord 对象，然后在 performStopActivityInner 方法当中，根据saveState的值，会去调用 callCallActivityOnSaveInstanceState 方法</p>
<p>代码如下</p>
<pre><code> private void callCallActivityOnSaveInstanceState(ActivityClientRecord r) {
    r.state = new Bundle();
    r.state.setAllowFds(false);
    if (r.isPersistable()) {
        r.persistentState = new PersistableBundle();
        mInstrumentation.callActivityOnSaveInstanceState(r.activity, r.state,
                r.persistentState);
    } else {
        mInstrumentation.callActivityOnSaveInstanceState(r.activity, r.state);
    }
}
</code></pre><p>接着看 callActivityOnSaveInstanceState 方法，里面直接 调用了 activity.performSaveInstanceState(outState)， 再回到Activity看performSaveInstanceState，</p>
<pre><code>final void performSaveInstanceState(Bundle outState) {
    onSaveInstanceState(outState);
    saveManagedDialogs(outState);
    mActivityTransitionState.saveState(outState);
    storeHasCurrentPermissionRequest(outState);
    if (DEBUG_LIFECYCLE) Slog.v(TAG, &quot;onSaveInstanceState &quot; + this + &quot;: &quot; + outState);
}
</code></pre><p>调用了 onSaveInstanceState 这个就是前文分析的入口了，除了前文分析的保存的状态还保存了，dialog ，activity transaction, 权限相关的信息 ，这些信息都被存入了outState当中。而这个正是ActivityClientRecrod的成员变量之一，ActivityClientRecrod有最终被存在了 ActivityThread 的 mActivities 集合当中。</p>
<p>这里需要注意</p>
<p>现在保存的信息都分析完了，后面用户再回来的时候就需要将保存的信息再传给Activity，启动Acitivty在ActivityThread中的 performLaunchActivity 方法，<br>在这个方法当有如下代码 </p>
<pre><code>if (r.isPersistable()) {
    mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);
} else {
    mInstrumentation.callActivityOnCreate(activity, r.state);
}
</code></pre><p>这里最终将ActivityClientRecord对象中保存的 state 在传递给 activity的 onCreate 方法，这样就可以在onCreate的时候实现对上一个Activity对象状态的恢复。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/01/20/C-中的静态/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Tom Liu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Learning">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/01/20/C-中的静态/" itemprop="url">C++中的静态</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-01-20T23:14:42+08:00">
                2017-01-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>通过添加static关键字将成员与类结合在一起而不是与特定的对象绑定在一起，这一点和java中static关键字是一样的，而且也可以使用访问修饰符修饰</p>
<p>静态成员函数不和任何对象绑定在一起，他们不包含任何this 指针，作为结果，静态成员函数不能成名成const的，而且不能再静态函数的内部使用this指针。</p>
<p>可以使用作用域运算法直接访问静态成员。例如在Account中定义了静态的rate()函数，可以使用Accout::rate()调用。</p>
<p>和其他的成员函数一样，我们既可以在类的内部也可以在类的外部定义静态成员函数，当在类的外部定义静态成员函数的时候不能重复static关键字。</p>
<p>因为静态数据库成员不属于类的任何一个对象，所以他们不是在创建类的对象的时候被定义的，这意味着他们不是由类的构造函数初始化的，而且一般来说我们不能在类的内部初始化静态成员，相反的，必须在类的外部定义和初始化静态成员，类似于全局变量，静态成员定义于任何函数之外，一旦定义就存于程序的整个生命周期。</p>
<p>下面是一个使用static的例子</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

class MyStatic{

public:
    static void test();
    static string name;
};

void MyStatic::test() {
    cout&lt;&lt;&quot;this is static test method&quot;&lt;&lt;endl;
}

string MyStatic::name = &quot;ssssss&quot;;
int main(void) {
    MyStatic::test();
    cout&lt;&lt;MyStatic::name&lt;&lt;endl;
    return 0;
}
</code></pre><p>静态成员可以用于某些场景而普通成员不能</p>
<ol>
<li><p>静态成员不收不完全类型的限制</p>
<pre><code>class MyStatic{
    private:
        MyStatic *my;
        static MyStatic instance;
    public:
        static void test();
        static string name;
};
</code></pre></li>
</ol>
<p>在上面的例子中，如果去掉 instance 变量前的是static，那么将会编译失败</p>
<p>2.静态成员可以作为默认的实参，而普通成员则不行</p>
<pre><code>class MyStatic{
    private:
        static const int  a = 0;
        int b;
    public:
        MyStatic(int c = a):b(a){

        }
    };
</code></pre><p>如果把常量a 的 static关键字拿到，那么编译将报错。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/01/15/Android-热修复技术/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Tom Liu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Learning">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/01/15/Android-热修复技术/" itemprop="url">Android 热修复技术</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-01-15T10:37:59+08:00">
                2017-01-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>今天动手实践了一下安卓上的热修复机制，现在总结一下、</p>
<p>在Android中要想实现热更新实际上就是对class文件的替换，将目标文件替换成新的class文件即可，但是在Android中并没有直接使用class文件，而是将class重新打包在了一个dex文件中，然后从这个dex文件中去load class.<br>在Android中，系统为我们提供了这么一个类，叫做<a href="http://androidxref.com/7.1.1_r6/xref/libcore/dalvik/src/main/java/dalvik/system/DexClassLoader.java" target="_blank" rel="external">DexClassLoader</a>, 从这个类的注释中我们可以看到这个类可以从包含了dex文件的jar和 apk文件中去载类，但是这个类实际上什么都没有做，只是继承了<a href="http://androidxref.com/7.1.1_r6/xref/libcore/dalvik/src/main/java/dalvik/system/BaseDexClassLoader.java" target="_blank" rel="external">BaseDexClassLoader</a>，BaseDexClassLoader中重写findClass方法</p>
<pre><code>@Override
protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException {
    List&lt;Throwable&gt; suppressedExceptions = new ArrayList&lt;Throwable&gt;();
    Class c = pathList.findClass(name, suppressedExceptions);        
    if (c == null) {
        ClassNotFoundException cnfe = new ClassNotFoundException(&quot;Didn&apos;t find class \&quot;&quot; + name + &quot;\&quot; on path: &quot; + pathList);
        for (Throwable t : suppressedExceptions) {
            cnfe.addSuppressed(t);
        }
        throw cnfe;
    }
    return c;
}
</code></pre><p>从上面的代码可以看出,实际上BaseDexClassLoader自己也什么都没有做，而是交给了已 pathList 这个对象去完成加载的任务，pathList 是一个<a href="http://androidxref.com/7.1.1_r6/xref/libcore/dalvik/src/main/java/dalvik/system/DexPathList.java" target="_blank" rel="external">DexPathList</a> 对象，它的findClass实现如下，</p>
<pre><code> public Class findClass(String name, List&lt;Throwable&gt; suppressed) {
    for (Element element : dexElements) {
        DexFile dex = element.dexFile;

        if (dex != null) {
            Class clazz = dex.loadClassBinaryName(name, definingContext, suppressed);
            if (clazz != null) {
                return clazz;
            }
        }
    }
    if (dexElementsSuppressedExceptions != null) {
        suppressed.addAll(Arrays.asList(dexElementsSuppressedExceptions));
    }
    return null;
}
</code></pre><p>它实际上会先遍历一个内部一个dexElements数组，然后从数组元素Elment中加载class对象，在这里我们最终找到了我们的classd对象是什么时候加载的了，既然知道了是什么时候加载的，我们就可以通过替换的方式来改变class了，在虚拟机加载一个class的时候，如果一个类已经被加载过了那么后面就不会再加载它，所以可以将包含补丁class的 Elment 放在数组的最前面，让虚拟机先加载补丁class, 这样需要被替换的class就不会被加载了，从而实现了更新。</p>
<p>实际上PathClassLoader也是BaseDexClassLoader的子类，系统就是使用了这个类来实现加载，PathClassLoader和上面提到的DexClassLoader区别如下， 在创建BaseDexClassLoader的对象时候需要填一个 optimizedDirectory 参数，optimizedDirectory是用来缓存我们需要加载的dex文件的，并创建一个DexFile对象，如果它为null，那么会直接使用dex文件原有的路径来创建DexFile对象。同时optimizedDirectory必须是一个内部存储路径，无论哪种动态加载，加载的可执行文件一定要存放在内部存储。DexClassLoader可以指定自己的optimizedDirectory，所以它可以加载外部的dex，因为这个dex会被复制到内部路径的optimizedDirectory；而PathClassLoader没有optimizedDirectory，所以它只能加载内部的dex，这些大都是存在系统中已经安装过的apk里面的。</p>
<p>因为这些类和变量我们在SDK中都无法直接的获取，所以只能通过反射的方式来获取。<br>下面是核心代码：</p>
<pre><code>package com.baidu.myhotfix;

import android.content.Context;
import android.util.Log;

import java.lang.reflect.Array;
import java.lang.reflect.Field;

import dalvik.system.BaseDexClassLoader;
import dalvik.system.DexClassLoader;

/**
 * Created by liuwei64 on 2017/1/14.
 */

public class HotFixUtil {

    private static final String TAG = &quot;HotFixUtil&quot;;

    public static void init(Context context) {
        ClassLoader classLoader = context.getClassLoader();
        try {
            if (classLoader instanceof BaseDexClassLoader) {
                Log.i(TAG, &quot;get baseclassloader instance&quot;);
                Field field = BaseDexClassLoader.class.getDeclaredField(&quot;pathList&quot;);
                field.setAccessible(true);
                Object dexPathList = getValue(BaseDexClassLoader.class, classLoader, &quot;pathList&quot;);
                Object dexElements = getValue(dexPathList.getClass(), dexPathList, &quot;dexElements&quot;);

                DexClassLoader cl = new DexClassLoader(&quot;/storage/sdcard0/classex_dex.jar&quot;,
                        context.getCacheDir().getAbsolutePath(),
                        null, context.getClassLoader());

                Object dexPathListNew = getValue(BaseDexClassLoader.class, cl, &quot;pathList&quot;);
                Object dexElementsNew = getValue(dexPathListNew.getClass(), dexPathListNew, &quot;dexElements&quot;);

                Object newElements = combineArray(dexElementsNew, dexElements);
                setValue(dexPathList.getClass(), dexPathList, &quot;dexElements&quot;, newElements);
            }
        } catch (Exception ex) {
            Log.e(TAG, ex.getMessage());
        }
    }

    public static Object getValue(Class clz, Object instance, String fileName) {
        try {
            Field field = clz.getDeclaredField(fileName);
            field.setAccessible(true);
            return field.get(instance);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }

    public static void setValue(Class clz, Object instance, String fileName, Object value) {
        try {
            Field field = clz.getDeclaredField(fileName);
            field.setAccessible(true);
            field.set(instance, value);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public static Object combineArray(Object arrayFirst, Object arraySecond) {
        if (arrayFirst == null || arrayFirst == null) {
            return null;
        }

        int firstLen = Array.getLength(arrayFirst);
        int secondLen = Array.getLength(arraySecond);

        int totalLen =  firstLen + secondLen;
        Object result = Array.newInstance(Array.get(arrayFirst, 0).getClass(), totalLen);
        for (int  i = 0; i &lt; totalLen; i++) {
            if (i &lt; firstLen) {
                Array.set(result, i , Array.get(arrayFirst, i));
            } else {
                Array.set(result, i , Array.get(arraySecond, i - firstLen));
            }
        }

        return result;
    }
}
</code></pre><p>实际上这里还有一个问题要解决，就是<a href="https://mp.weixin.qq.com/s?__biz=MzI1MTA1MzM2Nw==&amp;mid=400118620&amp;idx=1&amp;sn=b4fdd5055731290eef12ad0d17f39d4a&amp;scene=1&amp;srcid=1106Imu9ZgwybID13e7y2nEi#wechat_redirect" target="_blank" rel="external">CLASS_ISPREVERIFIED</a>的问题，后面自己实现了再来更新！</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/12/12/LeakCanary源码分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Tom Liu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Learning">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/12/12/LeakCanary源码分析/" itemprop="url">LeakCanary源码分析(1)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-12-12T22:15:45+08:00">
                2016-12-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>LeakCanary是在Android上一款开源的内存泄露分析工具，通过这款工具你可以实时的观察到当前app中出现的内存泄露情况，并且提供泄露路径方便用户来查找内存泄露的根源，[链接]是GitHub上的项目<a href="https://github.com/square/leakcanary" target="_blank" rel="external">1</a></p>
<p>LeakCanary 项目中，包括了五个模块，分别是</p>
<ul>
<li>leakcanary-analyser(为解析hprof文件，找到泄露的对象)</li>
<li>leakcanry-android(主要包含了暴漏给android使用的接口)</li>
<li>leakcanary-anroid-no-op(没有用到)</li>
<li>leakcanary-smaple(示例代码)</li>
<li>leakcanary-watcher(监视对象，触发GC并且生成hprof文件)</li>
</ul>
<p>下面从示例代码中开始入手看LeakCanary是如何发挥作用的</p>
<h2 id="leakcanary-smaple"><a href="#leakcanary-smaple" class="headerlink" title="leakcanary-smaple"></a>leakcanary-smaple</h2><p>在这个模块当中只有两个类，一个是自定义的ExampleApplication，继承于Application，一个是MainActivity.</p>
<pre><code>@Override
public void onCreate() {
    super.onCreate();
    if (LeakCanary.isInAnalyzerProcess(this)) {
        // This process is dedicated to LeakCanary for heap analysis.
        // You should not init your app in this process.
        return;
    }
    enabledStrictMode();
    LeakCanary.install(this);
}
</code></pre><p>在onCreate方法当中，首先判断当前的进程是不是分析进程，在LeakCanary当中为了避免在用户程序的进程当中占用太多的资源，所以整个分析过程是在一个单独的进程当中。</p>
<p>这个方法最终是调用了LeakCanaryInternals这个类的isInServiceProcess方法，这个方法比较简单，主要是通过比较当前Application所在进程的名字是不是HeapAnalyzerService在AndroidManifest.xml中所指定的名字来判断当前的进程是不是应用所在的进程，如果是应用所在的进程    <em>LeakCanary.isInAnalyzerProcess(this)</em>  最终会返回一个false, 这个时候将会继续往下执行，最后执行到LeakCanary.install(this); 如果当前进程的名字就是HeapAnalyzerService在AndroidManifest.xml中所指定的名字，那么表示当前进程是分析hprof的进程，这个时候就直接返回。</p>
<p>接下来进入到 <em>LeakCanary.install(this)</em> 当中，方法的代码如下</p>
<pre><code>  /**
  * Creates a {@link RefWatcher} that works out of the box, and starts watching activity
  * references (on ICS+).
*/
 public static RefWatcher install(Application application) {
    return refWatcher(application).listenerServiceClass(DisplayLeakService.class)
    .excludedRefs(AndroidExcludedRefs.createAppDefaults().build())
    .buildAndInstall();
    }
</code></pre><p>整个方法中都是用调用了通过调用 LeakCanary中的静态方法refWather返回了一个AndroidRefWatcherBuilder对象，这个对象中采用了建造者模式，来设置我们内存泄露中我们设置的一些参数</p>
<ul>
<li>listenerServiceClass()解析结果处理的IntentService. 这个Service需要继承AbstractAnalysisResultService 并且重写onHeapAnalyzed(HeapDump, AnalysisResult)方法来处理得到的分析结果。</li>
<li>excludedRefs 用来方便用户去掉一些特定的引用，当进行内存泄露分析的时候这些引用将不会被考虑在内。</li>
<li><p>buildAndInstall() 创建了RefWatcher实例，并且开始监听Activity的引用。</p>
<pre><code>public RefWatcher buildAndInstall() {
    RefWatcher refWatcher = build();
    if (refWatcher != DISABLED) {
        LeakCanary.enableDisplayLeakActivity(context);
        ActivityRefWatcher.installOnIcsPlus((Application) context, refWatcher);
    }
    return refWatcher;
}
</code></pre></li>
</ul>
<p>从上面代码不难看出其中最重要的方法调用是ActivityRefWatcher.installOnIcsPlus。</p>
<pre><code>@TargetApi(ICE_CREAM_SANDWICH)
public final class ActivityRefWatcher {

    public static void installOnIcsPlus(Application application, RefWatcher refWatcher) {
        if (SDK_INT &lt; ICE_CREAM_SANDWICH) {
            // If you need to support Android &lt; ICS, override onDestroy() in your base activity.
            return;
        }
        ActivityRefWatcher activityRefWatcher = new ActivityRefWatcher(application, refWatcher);
        activityRefWatcher.watchActivities();
    }

    private final Application.ActivityLifecycleCallbacks lifecycleCallbacks =
            new Application.ActivityLifecycleCallbacks() {
                @Override
                public void onActivityCreated(Activity activity, Bundle savedInstanceState) {
                }

                @Override
                public void onActivityStarted(Activity activity) {
                }

                @Override
                public void onActivityResumed(Activity activity) {
                }

                @Override
                public void onActivityPaused(Activity activity) {
                }

                @Override
                public void onActivityStopped(Activity activity) {
                }

                @Override
                public void onActivitySaveInstanceState(Activity activity, Bundle outState) {
                }

                @Override
                public void onActivityDestroyed(Activity activity) {
                    ActivityRefWatcher.this.onActivityDestroyed(activity);
                }
            };

    private final Application application;
    private final RefWatcher refWatcher;

    /**
     * Constructs an {@link ActivityRefWatcher} that will make sure the activities are not leaking
     * after they have been destroyed.
     */
    public ActivityRefWatcher(Application application, final RefWatcher refWatcher) {
        this.application = checkNotNull(application, &quot;application&quot;);
        this.refWatcher = checkNotNull(refWatcher, &quot;refWatcher&quot;);
    }

    void onActivityDestroyed(Activity activity) {
        refWatcher.watch(activity);
    }

    public void watchActivities() {
        // Make sure you don&apos;t get installed twice.
        stopWatchingActivities();
        application.registerActivityLifecycleCallbacks(lifecycleCallbacks);
    }

    public void stopWatchingActivities() {
        application.unregisterActivityLifecycleCallbacks(lifecycleCallbacks);
    }
}
</code></pre><p>看到 lifecycleCallbacks 变量的类型的类型，就应该恍然大悟了，<strong>LeakCanary就是通过在Application当中注册了Activity 生命周期的监听器来实现对Acitivity 引用泄露的分析。</strong> , 每当一个调用一个Activity onDestroy方法之前会调用lifecycleCallbacks的onActivityDestroyed方法。<br>最终会进入到RefWatcher实例的watch(Object ref, String reference Name)方法当中，代码如下：</p>
<pre><code>/**
 * Watches the provided references and checks if it can be GCed. This method is non blocking,
 * the check is done on the {@link WatchExecutor} this {@link RefWatcher} has been constructed
 * with.
 *
 * @param referenceName An logical identifier for the watched object.
 */
public void watch(Object watchedReference, String referenceName) {
    if (this == DISABLED) {
        return;
    }
    checkNotNull(watchedReference, &quot;watchedReference&quot;);
    checkNotNull(referenceName, &quot;referenceName&quot;);
    final long watchStartNanoTime = System.nanoTime();
    String key = UUID.randomUUID().toString();
    retainedKeys.add(key);
    final KeyedWeakReference reference =
            new KeyedWeakReference(watchedReference, key, referenceName, queue);

    ensureGoneAsync(watchStartNanoTime, reference);
}
</code></pre><p>在解释这段代码之前简单的说一下判断一个对象有没有被回收的原理：</p>
<p><strong>在Java中，当我们使用WeakReference指向一个对象的时候，如果这个对象已经被回收了，那么WeakReference 将会被添加到一个指定的队列当中去</strong></p>
<p>在这个方法中，LeakCanary 创建了一个指向Activity的弱引用KeyedWeakReference 对象，KeyedWeakReference继承于WeakReference 但是做了一定的扩展就是添加了两个字符串类型的字段name 和 key。这个key 也就是通过UUID生成的字符串。然后把这个key 添加到了 retainedKeys 代表的字符串集合当中去，只要key还在retainedKeys 当中就表示和 key 绑定的weakreference所指向的对象还没有被回收。</p>
<p>ensureGoneAsync()只是把分析方法通过异步的方式来处理（里面还有很多内容可以分析），在里面最终的调用的方法是 <em>ensureGone(final KeyedWeakReference reference, final long watchStartNanoTime)</em> 方法</p>
<p>放代码</p>
<pre><code>Retryable.Result ensureGone(final KeyedWeakReference reference, final long watchStartNanoTime) {
    ....

    removeWeaklyReachableReferences();

    ...
    if (gone(reference)) {
        return DONE;
    }
    gcTrigger.runGc();
    removeWeaklyReachableReferences();
    if (!gone(reference)) {
        File heapDumpFile = heapDumper.dumpHeap();
        if (heapDumpFile == RETRY_LATER) {
            // Could not dump the heap.
            return RETRY;
        }

        heapdumpListener.analyze(
                new HeapDump(heapDumpFile, reference.key, reference.name, excludedRefs, watchDurationMs,
                        gcDurationMs, heapDumpDurationMs));
    }
    return DONE;
}
</code></pre><p>首先进入removeWeaklyReachableReferences() 方法</p>
<pre><code>private void removeWeaklyReachableReferences() {
    // WeakReferences are enqueued as soon as the object to which they point to becomes weakly
    // reachable. This is before finalization or garbage collection has actually happened.
    KeyedWeakReference ref;
    while ((ref = (KeyedWeakReference) queue.poll()) != null) {
        retainedKeys.remove(ref.key);
    }
}
</code></pre><p>在方法的注释当中我们可以清楚的明白方法的含义：<br>一个对象如果变得只有一个弱引用指向它，那么它就会被添加到指定的队列当中去，就是在前面提到过的queue，这个时候我们可以通过KeyedWeakReference 来找出当初匹配的weakference , name , key，然后将key 从集合中移除，表明key对应引用所指向的对象已经被回收。</p>
<p>接下来这个时候我们在判断一下引用的所指向的对象是不是被回收了，这个判断还是通过判断key 在不在集合当中，如果不在表示这个对象已经完全被回收，可以直接返回。</p>
<p>接下来会触发一次GC. 之所以这样做是为了尽可能的避免进行内存的dump和分析操作。有些对象在这个时候本应该是只有weakreference 可达，但是却不在对队列当中，这个时候触发一次GC并且再进行一次引用分析可以有效地避免一些误判。</p>
<p>这里触发GC的代码如下</p>
<pre><code>// System.gc() does not garbage collect every time. Runtime.gc() is
  // more likely to perfom a gc.
  Runtime.getRuntime().gc();
</code></pre><p>GC完成之后，接下来再进行一次引用的检查，如果这个时候对象还是没有回收那么接下来就要开始内存的dump 操作了。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Tom Liu" />
          <p class="site-author-name" itemprop="name">Tom Liu</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">32</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">39</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Tom Liu</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  

  

  

  

  

</body>
</html>
