<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta property="og:type" content="website">
<meta property="og:title" content="Learning">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="Learning">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Learning">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/3/"/>





  <title>Learning</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  















  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Learning</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/03/Google-MVVM-示例代码分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Tom Liu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Learning">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/03/Google-MVVM-示例代码分析/" itemprop="url">Google MVVM 示例代码分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-02-03T22:54:03+08:00">
                2017-02-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>项目的代码位于 <a href="https://github.com/googlesamples/android-architecture/tree/dev-todo-mvvm-databinding/" target="_blank" rel="external">github</a> 上</p>
<p>项目中采用了MVVM方式进行开发，与之前的MVP项目模式相比，直接去掉了MVP模式中的Presenter，数据加载的操作直接用ViewModel中开始. 在获取到了数据之后，通过databiding 来完成数据的展示。</p>
<p>在to-do中，有几个部分，下面是主界面的分析内容。</p>
<p>在TasksViewModel 这个类当中，封装了数据所有的操作，包括数据的加载，判空（isEmpty），清除， 添加过滤条件。</p>
<p>同时应该注意到TasksViewModel 继承了 BaseObservable 这个对象，BaseObservable 最终实现了Observable 接口， 这个接口提供了让数据绑定的UI接受数据变化的通知。<br>同时 BaseObservable 还有其他的类型的子类，例如 ObservableField 等。</p>
<p>在 TasksViewModel 我们也可以找到 BaseObservable 类型的属性，通过这些属性，可以监听到具体属性值 的变化。</p>
<p>除了属性值之外，还可以将方法转可以监听的对象，做法就是给方法加上  @Bindable 注解。<br>下面是这个注解的说明</p>
<p><em>The Bindable annotation should be applied to any getter accessor method of an<br> {@link Observable} class. Bindable will generate a field in the BR class to identify<br> the field that has changed.</em></p>
<p>它用来修饰任意一个get method，被这个注解修饰的方法会在 BR.java这个类中生成对应的属性，例如如果定义了 String getName()方法，那么就会在BR中添加一个name的常量字段。当数据发生变化我们需要通过getName来获取最新的数据的时候，调用 BaseObserverable 的 notifyPropertyChanged(BR.name)，之后getName将再次被调用。</p>
<p>同时也可以看到这个被 @Bindable 注解修饰的方法，可以在 布局文件中直接通过 xxx.name 的方式来访问。</p>
<p>上面说到数据加载操作也是在TasksViewModel中完成的，在loadTasks方法中 调用了 mTasksRepository 的 getTasks， 然后在callback中将数据 添加到了 items当中去，<br>item 是一个 ObservableList </p>
<pre><code>public final ObservableList&lt;Task&gt; items = new ObservableArrayList&lt;&gt;();
</code></pre><p>当调用了 <em>items.addAll(tasksToShow);</em> 方法之后，数据就被绑定到界面上去了。</p>
<p>下面跟踪一下，数据绑定是如何实现的。</p>
<p>在TasksViewModel当中，有一个 ObservableBoolean类型的成员变量dataLoading.在这个类中提供了一个set方法，在改变了value的值之后，它调用了notifyChange(); </p>
<p>notifyChange 是一个定义在其父类 BaseObservable 中的一个同步的方法， 这个方法当中简单调用了PropertyChangeRegistry 这个类的 notifyCallbacks 方法 ，进入到notifyCallbacks 方法，实际上这个方法又是定义在其父类CallbackRegistry之中，通过CallbackRegistry的说明可知，这个类是用来存放callback和进行各种回调的，但是CallbackRegistry对于回调的处理实际上只是对回调的集合进行了管理，它通过递归的方式来通知集合中所有的回调，这里之所以采用递归的方式，文档之中给出的说明是避免在堆上进行临时状态的分配（但是采用递归需要每次都在栈上分配内存，并且堆上同样会有内存的分配，这里还不清楚），既然CallbackRegistry只是集合回调的管理，那么真正的回调应该如何处理实际上 是通过其内部类 NotifierCallback 来完成。</p>
<pre><code>/**
 * Class used to notify events from CallbackRegistry.
 *
 * @param &lt;C&gt; The callback type.
 * @param &lt;T&gt; The notification sender type. Typically this is the containing class.
 * @param &lt;A&gt; An opaque argument to pass to the notifier
 */
public abstract static class NotifierCallback&lt;C, T, A&gt; {
    /**
     * Called by CallbackRegistry during
     * {@link CallbackRegistry#notifyCallbacks(Object, int, Object)}} to notify the callback.
     *
     * @param callback The callback to notify.
     * @param sender The opaque sender object.
     * @param arg The opaque notification parameter.
     * @param arg2 An opaque argument passed in
     *        {@link CallbackRegistry#notifyCallbacks}
     * @see CallbackRegistry#CallbackRegistry(CallbackRegistry.NotifierCallback)
     */
    public abstract void onNotifyCallback(C callback, T sender, int arg, A arg2);
}
</code></pre><p>通过实际上在CallbackRegistry 处理回调的时候就是调用了其 onNotifyCallback来处理。</p>
<p>所以在CallbackRegistry 的说明中可以看到 一句话 ：<em>A subclass of CallbackRegistry.NotifierCallback must be passed to the constructor to define how notifications should be called</em></p>
<p>简单说就是由 NotifierCallback的子类来处理notification。</p>
<p>回到 PropertyChangeRegistry 当中看 NOTIFIER_CALLBACK</p>
<pre><code>private static final CallbackRegistry.NotifierCallback&lt;Observable.OnPropertyChangedCallback, Observable, Void&gt; NOTIFIER_CALLBACK = new CallbackRegistry.NotifierCallback&lt;Observable.OnPropertyChangedCallback, Observable, Void&gt;() {
    @Override
    public void onNotifyCallback(Observable.OnPropertyChangedCallback callback, Observable sender,
            int arg, Void notUsed) {
        callback.onPropertyChanged(sender, arg);
    }
};
</code></pre><p>在接收到通知之后，实际上会调用Observable.OnPropertyChangedCallback的 onPropertyChanged 方法。</p>
<p>从上面的分析可以看来，CallbackRegistry 实际上是一个事件分发中心和订阅中，所有的事件回调都是通过CallbackRegistry来处理，但是真正对事件的处理，却是通过自定义的 NotifierCallback来完成的。</p>
<p>在android的databinding中，同样是通过这样一套机制来工作的，在ViewDataBinding中，定义了WeakPropertyListener，通过重写 onPropertyChanged  方法完成对数据的重新绑定。</p>
<p>回到 TasksFragBinding.java 这个类是tasks_frag_xml这个文件生成的。<br>在其中定义了一个变量， mViewmodel ，因此在这个类中，也为我们生成了一个setViewmodel 方法，在这个方法当中，完成了对数据的mViewmodel 的赋值，然后调用了notifyPropertyChanged 方法，这个方法在前面提到过，定义BaseObservable 当中，所以可以简单的推断 ViewDataBinding 也是继承于BaseObservable。</p>
<p>通过mViewmodel 同样可以推断出，如果我们只是修改了 mViewmodel 的内部属性是无法导致试图被刷新的（已经验证），所以在TaskViewModel 这个类中，我们可以看到，在定义了 private final ObservableField<task> mTaskObservable = new ObservableField&lt;&gt;();之后有这么一段代码 </task></p>
<pre><code>mTaskObservable.addOnPropertyChangedCallback(new OnPropertyChangedCallback() {
        @Override
        public void onPropertyChanged(Observable observable, int i) {
            Task task = mTaskObservable.get();
            if (task != null) {
                title.set(task.getTitle());
                description.set(task.getDescription());
            } else {
                title.set(mContext.getString(R.string.no_data));
                description.set(mContext.getString(R.string.no_data_description));
            }
        }
    });
</code></pre><p>需要自己手动去添加一个监听器来数据的更新。</p>
<p>参照这个例子，如果需要一个更新了成员变量也会刷新对应试图的对象，应该这么定义 </p>
<pre><code>public class Task {
    public final ObservableField&lt;String&gt; title = new ObservableField();
    public final ObservableField&lt;String&gt; content = new ObservableField();

    public Task(String title, String content) {
        this.title.set(title);
        this.content.set(content);
    }

    public void setContent(String content) {
        this.content.set(content);
    }
}
</code></pre><p>对应的布局文件如下</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;layout  xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;
    &lt;data&gt;
        &lt;variable
            name=&quot;task&quot;
            type=&quot;com.devtom.databindingtest.Task&quot;/&gt;
    &lt;/data&gt;

    &lt;RelativeLayout
        xmlns:tools=&quot;http://schemas.android.com/tools&quot;
        android:id=&quot;@+id/activity_main&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;
        android:paddingBottom=&quot;@dimen/activity_vertical_margin&quot;
        android:paddingLeft=&quot;@dimen/activity_horizontal_margin&quot;
        android:paddingRight=&quot;@dimen/activity_horizontal_margin&quot;
        android:paddingTop=&quot;@dimen/activity_vertical_margin&quot;
        tools:context=&quot;com.devtom.databindingtest.MainActivity&quot;&gt;

        &lt;TextView
            android:id=&quot;@+id/title&quot;
            android:layout_width=&quot;wrap_content&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:layout_centerHorizontal=&quot;true&quot;
            android:text=&quot;@{task.title}&quot; /&gt;

        &lt;TextView
            android:id=&quot;@+id/content&quot;
            android:layout_width=&quot;wrap_content&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:layout_centerInParent=&quot;true&quot;
            android:text=&quot;@{task.content}&quot; /&gt;

        &lt;Button
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:text=&quot;Change&quot;
            android:onClick=&quot;change&quot;
            android:layout_alignParentBottom=&quot;true&quot;
            /&gt;
    &lt;/RelativeLayout&gt;
&lt;/layout&gt;
</code></pre><p>Activity 代码如下</p>
<pre><code>public class MainActivity extends AppCompatActivity {
        private Task task;
        @Override
        protected void onCreate(Bundle savedInstanceState) {
            super.onCreate(savedInstanceState);
            setContentView(R.layout.activity_main);
            View view = this.findViewById(R.id.activity_main);
            ActivityMainBinding mainBinding = DataBindingUtil.bind(view);
            task = new Task(&quot;this is title&quot;,&quot;kai gong da ji&quot;);
            mainBinding.setTask(task);
        }

        public void change(View view) {
            task.setContent(&quot;this is chinese new year&quot;);
        }
}
</code></pre><p>当手动的去改变task的某一个属性的时候，也会去刷新对应的试图。</p>
<p>这里需要注意的是Task其中的两个成员变量可以定义为public的也可以定义为private 然后给他添加对应的private 方法。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/01/28/Android中AIDL的理解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Tom Liu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Learning">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/01/28/Android中AIDL的理解/" itemprop="url">Android中AIDL的理解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-01-28T19:39:45+08:00">
                2017-01-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>首先定义 </p>
<pre><code>// IMyService.aidl
package com.devtom.myservice;

interface IMyService {
    void printLog(String message);
}
</code></pre><p>定义完成了之后，编译工具会自动帮我们生成接口相关的文件。<br>生成的代码文件如下</p>
<pre><code>package com.devtom.myservice;

public interface IMyService extends android.os.IInterface {
    /**
     * Local-side IPC implementation stub class.
     */
    public static abstract class Stub extends android.os.Binder implements com.devtom.myservice.IMyService {
        private static final java.lang.String DESCRIPTOR = &quot;com.devtom.myservice.IMyService&quot;;

        /**
         * Construct the stub at attach it to the interface.
         */
        public Stub() {
            this.attachInterface(this, DESCRIPTOR);
        }

        /**
         * Cast an IBinder object into an com.devtom.myservice.IMyService interface,
         * generating a proxy if needed.
         */
        public static com.devtom.myservice.IMyService asInterface(android.os.IBinder obj) {
            if ((obj == null)) {
                return null;
            }
            android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);
            if (((iin != null) &amp;&amp; (iin instanceof com.devtom.myservice.IMyService))) {
                return ((com.devtom.myservice.IMyService) iin);
            }
            return new com.devtom.myservice.IMyService.Stub.Proxy(obj);
        }

        @Override
        public android.os.IBinder asBinder() {
            return this;
        }

        @Override
        public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException {
            switch (code) {
                case INTERFACE_TRANSACTION: {
                    reply.writeString(DESCRIPTOR);
                    return true;
                }
                case TRANSACTION_printLog: {
                    data.enforceInterface(DESCRIPTOR);
                    java.lang.String _arg0;
                    _arg0 = data.readString();
                    this.printLog(_arg0);
                    reply.writeNoException();
                    return true;
                }
            }
            return super.onTransact(code, data, reply, flags);
        }

        private static class Proxy implements com.devtom.myservice.IMyService {
            private android.os.IBinder mRemote;

            Proxy(android.os.IBinder remote) {
                mRemote = remote;
            }

            @Override
            public android.os.IBinder asBinder() {
                return mRemote;
            }

            public java.lang.String getInterfaceDescriptor() {
                return DESCRIPTOR;
            }

            @Override
            public void printLog(java.lang.String message) throws android.os.RemoteException {
                android.os.Parcel _data = android.os.Parcel.obtain();
                android.os.Parcel _reply = android.os.Parcel.obtain();
                try {
                    _data.writeInterfaceToken(DESCRIPTOR);
                    _data.writeString(message);
                    mRemote.transact(Stub.TRANSACTION_printLog, _data, _reply, 0);
                    _reply.readException();
                } finally {
                    _reply.recycle();
                    _data.recycle();
                }
            }
        }

        static final int TRANSACTION_printLog = (android.os.IBinder.FIRST_CALL_TRANSACTION + 0);
    }

    public void printLog(java.lang.String message) throws android.os.RemoteException;
}
</code></pre><p>再来看看service相关的实现</p>
<pre><code>public class MyRemoteService extends Service {

    private static final String TAG = &quot;MyRemoteService&quot;;

    public static class MyServiceBinder extends IMyService.Stub {
        @Override
        public void printLog(String message) throws RemoteException {
            Log.e(TAG, &quot;this is message from remote &quot; + message);
        }
    }

    private MyServiceBinder binder;

    @Override
    public void onCreate() {
        super.onCreate();
        binder = new MyServiceBinder();
    }

    @Nullable
    @Override
    public IBinder onBind(Intent intent) {
        return binder;
    }
}
</code></pre><p>客户端调用的代码如下 </p>
<pre><code>public class MainActivity extends Activity {

    private IMyService binder;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        Intent intent = new Intent(this, MyRemoteService.class);
        bindService(intent, serviceConnection, Service.BIND_AUTO_CREATE);
        this.findViewById(R.id.test).setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                try {
                    binder.printLog(&quot;this is message from client&quot;);
                } catch (RemoteException e) {
                    e.printStackTrace();
                }
            }
        });
    }

    private ServiceConnection serviceConnection = new ServiceConnection() {
        @Override
        public void onServiceConnected(ComponentName name, IBinder service) {
            binder = MyRemoteService.MyServiceBinder.asInterface(service);
        }

        @Override
        public void onServiceDisconnected(ComponentName name) {
            binder = null;
        }
    };
}
</code></pre><p>目前按照个人理解 </p>
<ol>
<li><p>MainActivity当中通过ServiceConnect 拿到的对象实际上是IMyService 当中的Proxy 对象的引用，之所以会有这个代理对象的存在，目前的理解是，系统为了方便我们调用，通过这个代理对象完成了调用远程服务数据的封装，所以我们在Proxy当中可以看到代理对printLog的实现：</p>
<pre><code>@Override
public void printLog(java.lang.String message) throws android.os.RemoteException {
    android.os.Parcel _data = android.os.Parcel.obtain();
    android.os.Parcel _reply = android.os.Parcel.obtain();
    try {
        _data.writeInterfaceToken(DESCRIPTOR);
        _data.writeString(message);
        mRemote.transact(Stub.TRANSACTION_printLog, _data, _reply, 0);
        _reply.readException();
    } finally {
        _reply.recycle();
        _data.recycle();
    }
}
</code></pre></li>
</ol>
<p>在Proxy的实现中，主要是完成了对数据的封装，并没有实现其他的逻辑，完成数据的封装之后，然后调用了 mRemote的transact方法。</p>
<ol>
<li><p>Proxy 中成员变量 mRemote 所指向的对象是 IMyService.Stub ,因为Stub 是一个抽象类，所以最终mRemote指向的实例也就是IMyService.Stub 的实现类了</p>
<pre><code> @Override
public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException {
    switch (code) {
        case INTERFACE_TRANSACTION: {
            reply.writeString(DESCRIPTOR);
            return true;
        }
        case TRANSACTION_printLog: {
            data.enforceInterface(DESCRIPTOR);
            java.lang.String _arg0;
            _arg0 = data.readString();
            this.printLog(_arg0);
            reply.writeNoException();
            return true;
        }
    }
    return super.onTransact(code, data, reply, flags);
}
</code></pre><p> 在onTransact 方法当中实现了对数据的解析，将获取到的数据传给自己定义的方法当中去，最终调用了自己实现的方法。</p>
</li>
</ol>
<p>３.通过这个例子，最重要的还是里面的Binder， 数据的传递，解析都是Binder这个对象来完成的。</p>
<p>知道AIDL 的套路之后，可以自己手写一个实现。</p>
<pre><code>public class MyServiceBinderImpl extends Binder implements MyServiceInterface, IInterface{

    public static final String TAG  = &quot;MyServiceBinderImpl&quot;;

    public static final String DESCRIPTOR = &quot;com.devtom.myservice.MyServiceBinderImpl&quot;;

    @Override
    protected boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException {
        switch (code) {
            case INTERFACE_TRANSACTION:
                reply.writeString(DESCRIPTOR);
                break;
            case Binder.FIRST_CALL_TRANSACTION + 0:
                data.enforceInterface(DESCRIPTOR);
                String strData = data.readString();
                printLog(strData);
                reply.writeNoException();
                break;
        }
        return super.onTransact(code, data, reply, flags);
    }

    @Override
    public void printLog(String message) {
        Log.e(TAG, &quot;this message is &quot; + message);
    }

    @Override
    public IBinder asBinder() {
        return this;
    }
}
</code></pre><p>这个实际上就是自己动手去解析数据。</p>
<p>调用了也很简单 ，</p>
<pre><code>android.os.Parcel _data = android.os.Parcel.obtain();
           android.os.Parcel _reply = android.os.Parcel.obtain();
           try {
               _data.writeInterfaceToken(MyServiceBinderImpl.DESCRIPTOR);
               _data.writeString(&quot;this my own aidl implement&quot;);
               binder.transact(IMyService.Stub.TRANSACTION_printLog, _data, _reply, 0);
               _reply.readException();
           } catch (RemoteException e) {

           } finally {
               _reply.recycle();
               _data.recycle();
           }
</code></pre><p>此处的binder对象就是从ServiceConnection的onServiceConnected 方法参数中获取的，因为我们去掉了代理帮帮我们封装数据，所以这里就只能自己手动的去封装数据了。</p>
<p>其实从上面自己手动实现AIDL 的功能可以看出，我们新建的service只是为了方便我们自己调用，我们完全可以去掉了这些方法（printLog）在onTrasaction里面来实现各种功能,当然这个只是扯淡。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/01/22/Android中的状态保存/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Tom Liu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Learning">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/01/22/Android中的状态保存/" itemprop="url">Android中的状态保存</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-01-22T23:07:38+08:00">
                2017-01-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在Android中，当我们的Acitivity 被系统干掉的时候，会给我们一次保存数据的机会，我们通过可以通过这个机会来将需要的数据保存下来，然后在用户从新打开APP的时候，把这个数据恢复。</p>
<p>先来看一下Activity是怎么保存数据的 </p>
<p>先来看一下onSaveInstanceState()方法 </p>
<pre><code>protected void onSaveInstanceState(Bundle outState) {
    outState.putBundle(WINDOW_HIERARCHY_TAG, mWindow.saveHierarchyState());
    Parcelable p = mFragments.saveAllState();
    if (p != null) {
        outState.putParcelable(FRAGMENTS_TAG, p);
    }
    getApplication().dispatchActivitySaveInstanceState(this, outState);
}
</code></pre><p>代码非常的简单，保存了3个对象的状态，分别是mWindow, mFragments和 Application 对象<br>mWindow的实际实现对象是PhoneWindow, 我们进入到 saveHierarchyState() 方法看看 </p>
<pre><code>    /** {@inheritDoc} */
@Override
public Bundle saveHierarchyState() {
    Bundle outState = new Bundle();
    if (mContentParent == null) {
        return outState;
    }

    SparseArray&lt;Parcelable&gt; states = new SparseArray&lt;Parcelable&gt;();
    mContentParent.saveHierarchyState(states);
    outState.putSparseParcelableArray(VIEWS_TAG, states);

    // Save the focused view ID.
    final View focusedView = mContentParent.findFocus();
    if (focusedView != null &amp;&amp; focusedView.getId() != View.NO_ID) {
        outState.putInt(FOCUSED_ID_TAG, focusedView.getId());
    }

    // save the panels
    SparseArray&lt;Parcelable&gt; panelStates = new SparseArray&lt;Parcelable&gt;();
    savePanelState(panelStates);
    if (panelStates.size() &gt; 0) {
        outState.putSparseParcelableArray(PANELS_TAG, panelStates);
    }

    if (mDecorContentParent != null) {
        SparseArray&lt;Parcelable&gt; actionBarStates = new SparseArray&lt;Parcelable&gt;();
        mDecorContentParent.saveToolbarHierarchyState(actionBarStates);
        outState.putSparseParcelableArray(ACTION_BAR_TAG, actionBarStates);
    }
    return outState;
}
</code></pre><p>首先是尝试去保存 mContentParent 的状态， 这个mContentParent 实际上就是在DecorView中 id 为 content的 ViewGroup, 我们setContetnView中添加的View就是放在了它的下面。mContentParent 是FrameLayout， 最终类型就是ViewGroup。先看看ViewGroup的父类 View怎么实现 saveHierarchyState .saveHierarchyState 调用了 dispatchSaveInstanceState，而这个方法是View中的方法，</p>
<pre><code>protected void dispatchSaveInstanceState(SparseArray&lt;Parcelable&gt; container) {
    if (mID != NO_ID &amp;&amp; (mViewFlags &amp; SAVE_DISABLED_MASK) == 0) {
        mPrivateFlags &amp;= ~PFLAG_SAVE_STATE_CALLED;
        Parcelable state = onSaveInstanceState();
        if ((mPrivateFlags &amp; PFLAG_SAVE_STATE_CALLED) == 0) {
            throw new IllegalStateException(
                    &quot;Derived class did not call super.onSaveInstanceState()&quot;);
        }
        if (state != null) {
            // Log.i(&quot;View&quot;, &quot;Freezing #&quot; + Integer.toHexString(mID)
            // + &quot;: &quot; + state);
            container.put(mID, state);
        }
    }
}
</code></pre><p>实际上就是把onSaveInstanceState 放的返回值 保存了起来，在这里我们可以看到，这里是根据mID 也就是我们在布局文件为View指定的id来保存状态的，同时因为 SparseArray 是一个key ,value的键值对集合，所以这里，如果指定了相同的key,前面的key对应的view状态会被后来的覆盖掉，所以要尽量避免key的重复。</p>
<p>再来看 ViewGroup的 dispatchSaveInstanceState 方法。</p>
<pre><code>@Override
protected void dispatchSaveInstanceState(SparseArray&lt;Parcelable&gt; container) {
    super.dispatchSaveInstanceState(container);
    final int count = mChildrenCount;
    final View[] children = mChildren;
    for (int i = 0; i &lt; count; i++) {
        View c = children[i];
        if ((c.mViewFlags &amp; PARENT_SAVE_DISABLED_MASK) != PARENT_SAVE_DISABLED) {
            c.dispatchSaveInstanceState(container);
        }
    }
}
</code></pre><p>ViewGroup 首先调用了View的dispatchSaveInstanceState 方法来保存自身的状态，然后调用了其子View 的dispatchSaveInstanceState 方法来保存 子view的 状态。这样最终的ViewTree的状态就被保存下来了。</p>
<p>Activity 把View的状态都存下来了之后，再开始存Fragment的状态<br>Fragment状态的保存实在FragmentManager的saveAllState()方法来完成的，在这个方法当中调用了<br>saveFragmentBasicState()方法，</p>
<pre><code> Bundle saveFragmentBasicState(Fragment f) {
    Bundle result = null;

    if (mStateBundle == null) {
        mStateBundle = new Bundle();
    }
    f.performSaveInstanceState(mStateBundle);
    if (!mStateBundle.isEmpty()) {
        result = mStateBundle;
        mStateBundle = null;
    }

    if (f.mView != null) {
        saveFragmentViewState(f);
    }
    if (f.mSavedViewState != null) {
        if (result == null) {
            result = new Bundle();
        }
        result.putSparseParcelableArray(
                FragmentManagerImpl.VIEW_STATE_TAG, f.mSavedViewState);
    }
    if (!f.mUserVisibleHint) {
        if (result == null) {
            result = new Bundle();
        }
        // Only add this if it&apos;s not the default value
        result.putBoolean(FragmentManagerImpl.USER_VISIBLE_HINT_TAG, f.mUserVisibleHint);
    }

    return result;
}
</code></pre><p>performSaveInstanceState 的代码如下 </p>
<pre><code>void performSaveInstanceState(Bundle outState) {
    onSaveInstanceState(outState);
    if (mChildFragmentManager != null) {
        Parcelable p = mChildFragmentManager.saveAllState();
        if (p != null) {
            outState.putParcelable(Activity.FRAGMENTS_TAG, p);
        }
    }
}
</code></pre><p>performSaveInstanceState onSaveInstanceState 方法，在这个方法里面我们可以保存自己想要保存的信息，之后又开始调用FragmentManamager 的 saveAllState()方法，就是递归调用了。跳出这个方法，接着看 saveFragmentViewState()</p>
<pre><code>    void saveFragmentViewState(Fragment f) {
    if (f.mView == null) {
        return;
    }
    if (mStateArray == null) {
        mStateArray = new SparseArray&lt;Parcelable&gt;();
    } else {
        mStateArray.clear();
    }
    f.mView.saveHierarchyState(mStateArray);
    if (mStateArray.size() &gt; 0) {
        f.mSavedViewState = mStateArray;
        mStateArray = null;
    }
}
</code></pre><p>关键的代码是  f.mView.saveHierarchyState(mStateArray);这个方法保存开始保存View的信息， 这个就是在开始分析的保存ViewTree那一部分的内容了。</p>
<p>在上面的内容保存完了还要保存当前已经添加的Fragment的信息，和回退栈的信息。</p>
<pre><code>// Build list of currently added fragments.
   if (mAdded != null) {
       N = mAdded.size();
       if (N &gt; 0) {
           added = new int[N];
           for (int i=0; i&lt;N; i++) {
               added[i] = mAdded.get(i).mIndex;
               if (added[i] &lt; 0) {
                   throwException(new IllegalStateException(
                           &quot;Failure saving state: active &quot; + mAdded.get(i)
                           + &quot; has cleared index: &quot; + added[i]));
               }
               if (DEBUG) Log.v(TAG, &quot;saveAllState: adding fragment #&quot; + i
                       + &quot;: &quot; + mAdded.get(i));
           }
       }
   }

   // Now save back stack.
   if (mBackStack != null) {
       N = mBackStack.size();
       if (N &gt; 0) {
           backStack = new BackStackState[N];
           for (int i=0; i&lt;N; i++) {
               backStack[i] = new BackStackState(this, mBackStack.get(i));
               if (DEBUG) Log.v(TAG, &quot;saveAllState: adding back stack #&quot; + i
                       + &quot;: &quot; + mBackStack.get(i));
           }
       }
   }
</code></pre><p><strong>所以在Fragment保存的内容当中一共是当前active fragment的信息，已经添加的fragment 信息，和回退栈的信息，三部分</strong></p>
<p>在回到Activity 的onSaveInstanceState 方法当中去，最后一步就是通知注册在Application当中的Activity 生命周期的回调。</p>
<p>onSaveInstanceState() 一般在onStop之前调用，再到ActivityThread的performStopActivity方法看看</p>
<pre><code>final void performStopActivity(IBinder token, boolean saveState, String reason) {
    ActivityClientRecord r = mActivities.get(token);
    performStopActivityInner(r, null, false, saveState, reason);
}
</code></pre><p>首先获取了了 一个 ActivityClientRecord 对象，然后在 performStopActivityInner 方法当中，根据saveState的值，会去调用 callCallActivityOnSaveInstanceState 方法</p>
<p>代码如下</p>
<pre><code> private void callCallActivityOnSaveInstanceState(ActivityClientRecord r) {
    r.state = new Bundle();
    r.state.setAllowFds(false);
    if (r.isPersistable()) {
        r.persistentState = new PersistableBundle();
        mInstrumentation.callActivityOnSaveInstanceState(r.activity, r.state,
                r.persistentState);
    } else {
        mInstrumentation.callActivityOnSaveInstanceState(r.activity, r.state);
    }
}
</code></pre><p>接着看 callActivityOnSaveInstanceState 方法，里面直接 调用了 activity.performSaveInstanceState(outState)， 再回到Activity看performSaveInstanceState，</p>
<pre><code>final void performSaveInstanceState(Bundle outState) {
    onSaveInstanceState(outState);
    saveManagedDialogs(outState);
    mActivityTransitionState.saveState(outState);
    storeHasCurrentPermissionRequest(outState);
    if (DEBUG_LIFECYCLE) Slog.v(TAG, &quot;onSaveInstanceState &quot; + this + &quot;: &quot; + outState);
}
</code></pre><p>调用了 onSaveInstanceState 这个就是前文分析的入口了，除了前文分析的保存的状态还保存了，dialog ，activity transaction, 权限相关的信息 ，这些信息都被存入了outState当中。而这个正是ActivityClientRecrod的成员变量之一，ActivityClientRecrod有最终被存在了 ActivityThread 的 mActivities 集合当中。</p>
<p>这里需要注意</p>
<p>现在保存的信息都分析完了，后面用户再回来的时候就需要将保存的信息再传给Activity，启动Acitivty在ActivityThread中的 performLaunchActivity 方法，<br>在这个方法当有如下代码 </p>
<pre><code>if (r.isPersistable()) {
    mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);
} else {
    mInstrumentation.callActivityOnCreate(activity, r.state);
}
</code></pre><p>这里最终将ActivityClientRecord对象中保存的 state 在传递给 activity的 onCreate 方法，这样就可以在onCreate的时候实现对上一个Activity对象状态的恢复。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/01/20/C-中的静态/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Tom Liu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Learning">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/01/20/C-中的静态/" itemprop="url">C++中的静态</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-01-20T23:14:42+08:00">
                2017-01-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>通过添加static关键字将成员与类结合在一起而不是与特定的对象绑定在一起，这一点和java中static关键字是一样的，而且也可以使用访问修饰符修饰</p>
<p>静态成员函数不和任何对象绑定在一起，他们不包含任何this 指针，作为结果，静态成员函数不能成名成const的，而且不能再静态函数的内部使用this指针。</p>
<p>可以使用作用域运算法直接访问静态成员。例如在Account中定义了静态的rate()函数，可以使用Accout::rate()调用。</p>
<p>和其他的成员函数一样，我们既可以在类的内部也可以在类的外部定义静态成员函数，当在类的外部定义静态成员函数的时候不能重复static关键字。</p>
<p>因为静态数据库成员不属于类的任何一个对象，所以他们不是在创建类的对象的时候被定义的，这意味着他们不是由类的构造函数初始化的，而且一般来说我们不能在类的内部初始化静态成员，相反的，必须在类的外部定义和初始化静态成员，类似于全局变量，静态成员定义于任何函数之外，一旦定义就存于程序的整个生命周期。</p>
<p>下面是一个使用static的例子</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

class MyStatic{

public:
    static void test();
    static string name;
};

void MyStatic::test() {
    cout&lt;&lt;&quot;this is static test method&quot;&lt;&lt;endl;
}

string MyStatic::name = &quot;ssssss&quot;;
int main(void) {
    MyStatic::test();
    cout&lt;&lt;MyStatic::name&lt;&lt;endl;
    return 0;
}
</code></pre><p>静态成员可以用于某些场景而普通成员不能</p>
<ol>
<li><p>静态成员不收不完全类型的限制</p>
<pre><code>class MyStatic{
    private:
        MyStatic *my;
        static MyStatic instance;
    public:
        static void test();
        static string name;
};
</code></pre></li>
</ol>
<p>在上面的例子中，如果去掉 instance 变量前的是static，那么将会编译失败</p>
<p>2.静态成员可以作为默认的实参，而普通成员则不行</p>
<pre><code>class MyStatic{
    private:
        static const int  a = 0;
        int b;
    public:
        MyStatic(int c = a):b(a){

        }
    };
</code></pre><p>如果把常量a 的 static关键字拿到，那么编译将报错。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/01/15/Android-热修复技术/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Tom Liu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Learning">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/01/15/Android-热修复技术/" itemprop="url">Android 热修复技术</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-01-15T10:37:59+08:00">
                2017-01-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>今天动手实践了一下安卓上的热修复机制，现在总结一下、</p>
<p>在Android中要想实现热更新实际上就是对class文件的替换，将目标文件替换成新的class文件即可，但是在Android中并没有直接使用class文件，而是将class重新打包在了一个dex文件中，然后从这个dex文件中去load class.<br>在Android中，系统为我们提供了这么一个类，叫做<a href="http://androidxref.com/7.1.1_r6/xref/libcore/dalvik/src/main/java/dalvik/system/DexClassLoader.java" target="_blank" rel="external">DexClassLoader</a>, 从这个类的注释中我们可以看到这个类可以从包含了dex文件的jar和 apk文件中去载类，但是这个类实际上什么都没有做，只是继承了<a href="http://androidxref.com/7.1.1_r6/xref/libcore/dalvik/src/main/java/dalvik/system/BaseDexClassLoader.java" target="_blank" rel="external">BaseDexClassLoader</a>，BaseDexClassLoader中重写findClass方法</p>
<pre><code>@Override
protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException {
    List&lt;Throwable&gt; suppressedExceptions = new ArrayList&lt;Throwable&gt;();
    Class c = pathList.findClass(name, suppressedExceptions);        
    if (c == null) {
        ClassNotFoundException cnfe = new ClassNotFoundException(&quot;Didn&apos;t find class \&quot;&quot; + name + &quot;\&quot; on path: &quot; + pathList);
        for (Throwable t : suppressedExceptions) {
            cnfe.addSuppressed(t);
        }
        throw cnfe;
    }
    return c;
}
</code></pre><p>从上面的代码可以看出,实际上BaseDexClassLoader自己也什么都没有做，而是交给了已 pathList 这个对象去完成加载的任务，pathList 是一个<a href="http://androidxref.com/7.1.1_r6/xref/libcore/dalvik/src/main/java/dalvik/system/DexPathList.java" target="_blank" rel="external">DexPathList</a> 对象，它的findClass实现如下，</p>
<pre><code> public Class findClass(String name, List&lt;Throwable&gt; suppressed) {
    for (Element element : dexElements) {
        DexFile dex = element.dexFile;

        if (dex != null) {
            Class clazz = dex.loadClassBinaryName(name, definingContext, suppressed);
            if (clazz != null) {
                return clazz;
            }
        }
    }
    if (dexElementsSuppressedExceptions != null) {
        suppressed.addAll(Arrays.asList(dexElementsSuppressedExceptions));
    }
    return null;
}
</code></pre><p>它实际上会先遍历一个内部一个dexElements数组，然后从数组元素Elment中加载class对象，在这里我们最终找到了我们的classd对象是什么时候加载的了，既然知道了是什么时候加载的，我们就可以通过替换的方式来改变class了，在虚拟机加载一个class的时候，如果一个类已经被加载过了那么后面就不会再加载它，所以可以将包含补丁class的 Elment 放在数组的最前面，让虚拟机先加载补丁class, 这样需要被替换的class就不会被加载了，从而实现了更新。</p>
<p>实际上PathClassLoader也是BaseDexClassLoader的子类，系统就是使用了这个类来实现加载，PathClassLoader和上面提到的DexClassLoader区别如下， 在创建BaseDexClassLoader的对象时候需要填一个 optimizedDirectory 参数，optimizedDirectory是用来缓存我们需要加载的dex文件的，并创建一个DexFile对象，如果它为null，那么会直接使用dex文件原有的路径来创建DexFile对象。同时optimizedDirectory必须是一个内部存储路径，无论哪种动态加载，加载的可执行文件一定要存放在内部存储。DexClassLoader可以指定自己的optimizedDirectory，所以它可以加载外部的dex，因为这个dex会被复制到内部路径的optimizedDirectory；而PathClassLoader没有optimizedDirectory，所以它只能加载内部的dex，这些大都是存在系统中已经安装过的apk里面的。</p>
<p>因为这些类和变量我们在SDK中都无法直接的获取，所以只能通过反射的方式来获取。<br>下面是核心代码：</p>
<pre><code>package com.baidu.myhotfix;

import android.content.Context;
import android.util.Log;

import java.lang.reflect.Array;
import java.lang.reflect.Field;

import dalvik.system.BaseDexClassLoader;
import dalvik.system.DexClassLoader;

/**
 * Created by liuwei64 on 2017/1/14.
 */

public class HotFixUtil {

    private static final String TAG = &quot;HotFixUtil&quot;;

    public static void init(Context context) {
        ClassLoader classLoader = context.getClassLoader();
        try {
            if (classLoader instanceof BaseDexClassLoader) {
                Log.i(TAG, &quot;get baseclassloader instance&quot;);
                Field field = BaseDexClassLoader.class.getDeclaredField(&quot;pathList&quot;);
                field.setAccessible(true);
                Object dexPathList = getValue(BaseDexClassLoader.class, classLoader, &quot;pathList&quot;);
                Object dexElements = getValue(dexPathList.getClass(), dexPathList, &quot;dexElements&quot;);

                DexClassLoader cl = new DexClassLoader(&quot;/storage/sdcard0/classex_dex.jar&quot;,
                        context.getCacheDir().getAbsolutePath(),
                        null, context.getClassLoader());

                Object dexPathListNew = getValue(BaseDexClassLoader.class, cl, &quot;pathList&quot;);
                Object dexElementsNew = getValue(dexPathListNew.getClass(), dexPathListNew, &quot;dexElements&quot;);

                Object newElements = combineArray(dexElementsNew, dexElements);
                setValue(dexPathList.getClass(), dexPathList, &quot;dexElements&quot;, newElements);
            }
        } catch (Exception ex) {
            Log.e(TAG, ex.getMessage());
        }
    }

    public static Object getValue(Class clz, Object instance, String fileName) {
        try {
            Field field = clz.getDeclaredField(fileName);
            field.setAccessible(true);
            return field.get(instance);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }

    public static void setValue(Class clz, Object instance, String fileName, Object value) {
        try {
            Field field = clz.getDeclaredField(fileName);
            field.setAccessible(true);
            field.set(instance, value);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public static Object combineArray(Object arrayFirst, Object arraySecond) {
        if (arrayFirst == null || arrayFirst == null) {
            return null;
        }

        int firstLen = Array.getLength(arrayFirst);
        int secondLen = Array.getLength(arraySecond);

        int totalLen =  firstLen + secondLen;
        Object result = Array.newInstance(Array.get(arrayFirst, 0).getClass(), totalLen);
        for (int  i = 0; i &lt; totalLen; i++) {
            if (i &lt; firstLen) {
                Array.set(result, i , Array.get(arrayFirst, i));
            } else {
                Array.set(result, i , Array.get(arraySecond, i - firstLen));
            }
        }

        return result;
    }
}
</code></pre><p>实际上这里还有一个问题要解决，就是<a href="https://mp.weixin.qq.com/s?__biz=MzI1MTA1MzM2Nw==&amp;mid=400118620&amp;idx=1&amp;sn=b4fdd5055731290eef12ad0d17f39d4a&amp;scene=1&amp;srcid=1106Imu9ZgwybID13e7y2nEi#wechat_redirect" target="_blank" rel="external">CLASS_ISPREVERIFIED</a>的问题，后面自己实现了再来更新！</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/12/12/LeakCanary源码分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Tom Liu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Learning">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/12/12/LeakCanary源码分析/" itemprop="url">LeakCanary源码分析(1)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-12-12T22:15:45+08:00">
                2016-12-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>LeakCanary是在Android上一款开源的内存泄露分析工具，通过这款工具你可以实时的观察到当前app中出现的内存泄露情况，并且提供泄露路径方便用户来查找内存泄露的根源，[链接]是GitHub上的项目<a href="https://github.com/square/leakcanary" target="_blank" rel="external">1</a></p>
<p>LeakCanary 项目中，包括了五个模块，分别是</p>
<ul>
<li>leakcanary-analyser(为解析hprof文件，找到泄露的对象)</li>
<li>leakcanry-android(主要包含了暴漏给android使用的接口)</li>
<li>leakcanary-anroid-no-op(没有用到)</li>
<li>leakcanary-smaple(示例代码)</li>
<li>leakcanary-watcher(监视对象，触发GC并且生成hprof文件)</li>
</ul>
<p>下面从示例代码中开始入手看LeakCanary是如何发挥作用的</p>
<h2 id="leakcanary-smaple"><a href="#leakcanary-smaple" class="headerlink" title="leakcanary-smaple"></a>leakcanary-smaple</h2><p>在这个模块当中只有两个类，一个是自定义的ExampleApplication，继承于Application，一个是MainActivity.</p>
<pre><code>@Override
public void onCreate() {
    super.onCreate();
    if (LeakCanary.isInAnalyzerProcess(this)) {
        // This process is dedicated to LeakCanary for heap analysis.
        // You should not init your app in this process.
        return;
    }
    enabledStrictMode();
    LeakCanary.install(this);
}
</code></pre><p>在onCreate方法当中，首先判断当前的进程是不是分析进程，在LeakCanary当中为了避免在用户程序的进程当中占用太多的资源，所以整个分析过程是在一个单独的进程当中。</p>
<p>这个方法最终是调用了LeakCanaryInternals这个类的isInServiceProcess方法，这个方法比较简单，主要是通过比较当前Application所在进程的名字是不是HeapAnalyzerService在AndroidManifest.xml中所指定的名字来判断当前的进程是不是应用所在的进程，如果是应用所在的进程    <em>LeakCanary.isInAnalyzerProcess(this)</em>  最终会返回一个false, 这个时候将会继续往下执行，最后执行到LeakCanary.install(this); 如果当前进程的名字就是HeapAnalyzerService在AndroidManifest.xml中所指定的名字，那么表示当前进程是分析hprof的进程，这个时候就直接返回。</p>
<p>接下来进入到 <em>LeakCanary.install(this)</em> 当中，方法的代码如下</p>
<pre><code>  /**
  * Creates a {@link RefWatcher} that works out of the box, and starts watching activity
  * references (on ICS+).
*/
 public static RefWatcher install(Application application) {
    return refWatcher(application).listenerServiceClass(DisplayLeakService.class)
    .excludedRefs(AndroidExcludedRefs.createAppDefaults().build())
    .buildAndInstall();
    }
</code></pre><p>整个方法中都是用调用了通过调用 LeakCanary中的静态方法refWather返回了一个AndroidRefWatcherBuilder对象，这个对象中采用了建造者模式，来设置我们内存泄露中我们设置的一些参数</p>
<ul>
<li>listenerServiceClass()解析结果处理的IntentService. 这个Service需要继承AbstractAnalysisResultService 并且重写onHeapAnalyzed(HeapDump, AnalysisResult)方法来处理得到的分析结果。</li>
<li>excludedRefs 用来方便用户去掉一些特定的引用，当进行内存泄露分析的时候这些引用将不会被考虑在内。</li>
<li><p>buildAndInstall() 创建了RefWatcher实例，并且开始监听Activity的引用。</p>
<pre><code>public RefWatcher buildAndInstall() {
    RefWatcher refWatcher = build();
    if (refWatcher != DISABLED) {
        LeakCanary.enableDisplayLeakActivity(context);
        ActivityRefWatcher.installOnIcsPlus((Application) context, refWatcher);
    }
    return refWatcher;
}
</code></pre></li>
</ul>
<p>从上面代码不难看出其中最重要的方法调用是ActivityRefWatcher.installOnIcsPlus。</p>
<pre><code>@TargetApi(ICE_CREAM_SANDWICH)
public final class ActivityRefWatcher {

    public static void installOnIcsPlus(Application application, RefWatcher refWatcher) {
        if (SDK_INT &lt; ICE_CREAM_SANDWICH) {
            // If you need to support Android &lt; ICS, override onDestroy() in your base activity.
            return;
        }
        ActivityRefWatcher activityRefWatcher = new ActivityRefWatcher(application, refWatcher);
        activityRefWatcher.watchActivities();
    }

    private final Application.ActivityLifecycleCallbacks lifecycleCallbacks =
            new Application.ActivityLifecycleCallbacks() {
                @Override
                public void onActivityCreated(Activity activity, Bundle savedInstanceState) {
                }

                @Override
                public void onActivityStarted(Activity activity) {
                }

                @Override
                public void onActivityResumed(Activity activity) {
                }

                @Override
                public void onActivityPaused(Activity activity) {
                }

                @Override
                public void onActivityStopped(Activity activity) {
                }

                @Override
                public void onActivitySaveInstanceState(Activity activity, Bundle outState) {
                }

                @Override
                public void onActivityDestroyed(Activity activity) {
                    ActivityRefWatcher.this.onActivityDestroyed(activity);
                }
            };

    private final Application application;
    private final RefWatcher refWatcher;

    /**
     * Constructs an {@link ActivityRefWatcher} that will make sure the activities are not leaking
     * after they have been destroyed.
     */
    public ActivityRefWatcher(Application application, final RefWatcher refWatcher) {
        this.application = checkNotNull(application, &quot;application&quot;);
        this.refWatcher = checkNotNull(refWatcher, &quot;refWatcher&quot;);
    }

    void onActivityDestroyed(Activity activity) {
        refWatcher.watch(activity);
    }

    public void watchActivities() {
        // Make sure you don&apos;t get installed twice.
        stopWatchingActivities();
        application.registerActivityLifecycleCallbacks(lifecycleCallbacks);
    }

    public void stopWatchingActivities() {
        application.unregisterActivityLifecycleCallbacks(lifecycleCallbacks);
    }
}
</code></pre><p>看到 lifecycleCallbacks 变量的类型的类型，就应该恍然大悟了，<strong>LeakCanary就是通过在Application当中注册了Activity 生命周期的监听器来实现对Acitivity 引用泄露的分析。</strong> , 每当一个调用一个Activity onDestroy方法之前会调用lifecycleCallbacks的onActivityDestroyed方法。<br>最终会进入到RefWatcher实例的watch(Object ref, String reference Name)方法当中，代码如下：</p>
<pre><code>/**
 * Watches the provided references and checks if it can be GCed. This method is non blocking,
 * the check is done on the {@link WatchExecutor} this {@link RefWatcher} has been constructed
 * with.
 *
 * @param referenceName An logical identifier for the watched object.
 */
public void watch(Object watchedReference, String referenceName) {
    if (this == DISABLED) {
        return;
    }
    checkNotNull(watchedReference, &quot;watchedReference&quot;);
    checkNotNull(referenceName, &quot;referenceName&quot;);
    final long watchStartNanoTime = System.nanoTime();
    String key = UUID.randomUUID().toString();
    retainedKeys.add(key);
    final KeyedWeakReference reference =
            new KeyedWeakReference(watchedReference, key, referenceName, queue);

    ensureGoneAsync(watchStartNanoTime, reference);
}
</code></pre><p>在解释这段代码之前简单的说一下判断一个对象有没有被回收的原理：</p>
<p><strong>在Java中，当我们使用WeakReference指向一个对象的时候，如果这个对象已经被回收了，那么WeakReference 将会被添加到一个指定的队列当中去</strong></p>
<p>在这个方法中，LeakCanary 创建了一个指向Activity的弱引用KeyedWeakReference 对象，KeyedWeakReference继承于WeakReference 但是做了一定的扩展就是添加了两个字符串类型的字段name 和 key。这个key 也就是通过UUID生成的字符串。然后把这个key 添加到了 retainedKeys 代表的字符串集合当中去，只要key还在retainedKeys 当中就表示和 key 绑定的weakreference所指向的对象还没有被回收。</p>
<p>ensureGoneAsync()只是把分析方法通过异步的方式来处理（里面还有很多内容可以分析），在里面最终的调用的方法是 <em>ensureGone(final KeyedWeakReference reference, final long watchStartNanoTime)</em> 方法</p>
<p>放代码</p>
<pre><code>Retryable.Result ensureGone(final KeyedWeakReference reference, final long watchStartNanoTime) {
    ....

    removeWeaklyReachableReferences();

    ...
    if (gone(reference)) {
        return DONE;
    }
    gcTrigger.runGc();
    removeWeaklyReachableReferences();
    if (!gone(reference)) {
        File heapDumpFile = heapDumper.dumpHeap();
        if (heapDumpFile == RETRY_LATER) {
            // Could not dump the heap.
            return RETRY;
        }

        heapdumpListener.analyze(
                new HeapDump(heapDumpFile, reference.key, reference.name, excludedRefs, watchDurationMs,
                        gcDurationMs, heapDumpDurationMs));
    }
    return DONE;
}
</code></pre><p>首先进入removeWeaklyReachableReferences() 方法</p>
<pre><code>private void removeWeaklyReachableReferences() {
    // WeakReferences are enqueued as soon as the object to which they point to becomes weakly
    // reachable. This is before finalization or garbage collection has actually happened.
    KeyedWeakReference ref;
    while ((ref = (KeyedWeakReference) queue.poll()) != null) {
        retainedKeys.remove(ref.key);
    }
}
</code></pre><p>在方法的注释当中我们可以清楚的明白方法的含义：<br>一个对象如果变得只有一个弱引用指向它，那么它就会被添加到指定的队列当中去，就是在前面提到过的queue，这个时候我们可以通过KeyedWeakReference 来找出当初匹配的weakference , name , key，然后将key 从集合中移除，表明key对应引用所指向的对象已经被回收。</p>
<p>接下来这个时候我们在判断一下引用的所指向的对象是不是被回收了，这个判断还是通过判断key 在不在集合当中，如果不在表示这个对象已经完全被回收，可以直接返回。</p>
<p>接下来会触发一次GC. 之所以这样做是为了尽可能的避免进行内存的dump和分析操作。有些对象在这个时候本应该是只有weakreference 可达，但是却不在对队列当中，这个时候触发一次GC并且再进行一次引用分析可以有效地避免一些误判。</p>
<p>这里触发GC的代码如下</p>
<pre><code>// System.gc() does not garbage collect every time. Runtime.gc() is
  // more likely to perfom a gc.
  Runtime.getRuntime().gc();
</code></pre><p>GC完成之后，接下来再进行一次引用的检查，如果这个时候对象还是没有回收那么接下来就要开始内存的dump 操作了。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/12/10/C-显式类型转换/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Tom Liu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Learning">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/12/10/C-显式类型转换/" itemprop="url">C++显式类型转换</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-12-10T21:58:26+08:00">
                2016-12-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>static_cast</strong><br>任何具有明确定义的类型转换，只要不包含底层const，都可以使用static_cast,例如将一个整形的运算对象强制转换为doule类型。static_cast常见的用法有以下两种：</p>
<ul>
<li>类型之间的转换，例如 doule 转为 int.</li>
<li><p>可以用于编译器无法自动执行的类型转换也非常有用，可以使用static_cast找回存在于void* 指针中的值，例如</p>
<p> void<em> p =&d;<br> double </em>dp = static_cast<double*>(p);</double*></p>
</li>
</ul>
<p>当我们把指针保存在void<em>当中，并且使用static_cast找回转换的值得时候，应该保证void</em> 指针的值不变，如果一旦类型发生了变换，那么将产生未定义的后果。</p>
<p>static_cast作类型转换的时候需要我们自己去确保转换的类型是匹配的，static_cast可以用在指针和引用上，还可以用在基础数据和对象上,用static_cast来处理的转换就需要两者具有”一定的关系”了,实际上继承关系是可以被static_cast接受的，其他情况的指针和引用转换都会被static_cast直接扔出编译错误，而这层关系上的转换又几乎都可以被dynamic_cast所代替</p>
<p><strong>const_cast</strong><br>const_cast 只能改变运算对象底层的const修饰、<br>对于将常量对象转为非常量对象的行为，我们一般称之为去掉const性质，一旦我们去掉了某个对象的const性质，编译器就不在阻止我们对该对象进行修改了，虽然我们可以获取修改对象的权限，但是这样的操作时未定义的。<a href="http://www.cnblogs.com/ider/archive/2011/07/22/cpp_cast_operator_part2.html" target="_blank" rel="external">阅读</a></p>
<p><strong>reinterpret_cast</strong><br>reinterpret_cast运算符用来处理无关类型之间的转换，他会产生一个新值，这个值会与原始参数有完全相同的bit位。<br>IBM的C++指南里倒是明确告诉了我们reinterpret_cast可以，或者说应该在什么地方用来作为转换运算符：</p>
<ul>
<li>从指针类型到一个足够大的整数类型</li>
<li>从整数类型或者枚举类型到指针类型</li>
<li>从一个指向函数的指针到另一个不同类型的指向函数的指针</li>
<li>从一个指向对象的指针到另一个不同类型的指向对象的指针</li>
<li>从一个指向类函数成员的指针到另一个指向不同类型的函数成员的指针</li>
<li>从一个指向类数据成员的指针到另一个指向不同类型的数据成员的指针</li>
</ul>
<p><strong>dynamic_cast</strong><br>与static_cast一样，dynamic_cast的转换也需要目标类型和源对象有一定的关系：继承关系。 更准确的说，dynamic_cast是用来检查两者是否有继承关系。因此该运算符实际上只接受基于类对象的指针和引用的类转换。</p>
<p>对于从子类到基类的指针转换，static_cast和dynamic_cast都是成功并且正确的（所谓成功是说转换没有编译错误或者运行异常；所谓正确是指方法的调用和数据的访问输出是期望的结果），这是面向对象多态性的完美体现。</p>
<p>而从基类到子类的转换，static_cast和dynamic_cast都是成功的，但是正确性方面，我对两者的结果都先进行了是否非空的判别：dynamic_cast的结果显示是空指针，而static_cast则是非空指针。但很显然，static_cast的结果应该算是错误的。</p>
<p>如果基类或者子类没有任何虚函数（如果基类有虚函数表，子类当然是自动继承了该表），当他们作为dynamic_cast的源类型进行转换时，编译也会失败。</p>
<p>这种情况是有可能存在的，因为在设计的时候，我们可能不需要让子类重写任何基类的方法。但实际上，这是不合理的，<br>如果要用继承，那么一定要让析构函数是虚函数；如果一个函数是虚函数，那么在子类中也要是虚函数。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/12/08/Java中弱引用的理解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Tom Liu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Learning">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/12/08/Java中弱引用的理解/" itemprop="url">Java中弱引用的理解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-12-08T14:05:24+08:00">
                2016-12-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>弱引用也是用来描述非必需的对象，但是他的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前，当垃圾收集工作时，无论当前内存是否足够，都会回收掉被弱引用关联的对象，在JDK1.2之后，提供了WeakReference类实现弱引用。</p>
<p>看下面的代码</p>
<pre><code>public class TestClient {
        public static void main(String[] args) throws Exception {
                int count = 5;
    System.out.println(&quot;before create object the current memory size = &quot; +                 Runtime.getRuntime().freeMemory());
    Test test = new Test();
    System.out.println(&quot;after create object the current memory size = &quot; + Runtime.getRuntime().freeMemory());
    WeakReference&lt;Test&gt; weakReference = new WeakReference&lt;Test&gt;(test);
    while(true) {
        count--;
        System.gc();
        Thread.sleep(5000);
        if(weakReference.get() == null) {
            System.out.println(&quot;the test has been recycled and the free memory is &quot; + Runtime.getRuntime().freeMemory());
        } else {
            System.out.println(&quot;the test has not been recycled and the free memory is &quot; + Runtime.getRuntime().freeMemory());
            if(count == 0) {
                test = null;
            }
        }
    }
    }
}
class Test  {
    byte data [] = new byte[10 * 1024 * 1024];
}
</code></pre><p>上述代码运行的结果如下</p>
<pre><code>before create object the current memory size = 122179856
after create object the current memory size = 111694080
the test has not been recycled and the free memory is 112663384
the test has not been recycled and the free memory is 112666448
the test has not been recycled and the free memory is 113316792
the test has not been recycled and the free memory is 113316792
the test has not been recycled and the free memory is 113316792
the test has been recycled and the free memory is 123802584
the test has been recycled and the free memory is 123802440
the test has been recycled and the free memory is 123802440
</code></pre><p>我们可以发现我们通过WeakReference 引用到了 Test 对象，但是一旦我们把test这个强引用置为null之后，test对象马上就被回收了。</p>
<p>如果把弱引用改为软引用，那么会发现即使把test置为空，这个对象依然被软引用引用到了，不会不会被垃圾回收器回收。在Java虚拟机中，被软引用引用到的对象只会在内存不够用的情况下才会回收这一部分内存。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/10/15/Android-View测量模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Tom Liu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Learning">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/10/15/Android-View测量模式/" itemprop="url">Android View测量模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-10-15T17:24:43+08:00">
                2016-10-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>今天看android源码的时候无意中发现了源码中关于测量模式的解释，简单的记录一下，一看就是恍然大悟了。</p>
<pre><code>  int result = desiredSize;
int specMode = MeasureSpec.getMode(measureSpec);
int specSize =  MeasureSpec.getSize(measureSpec);
switch (specMode) {
    case MeasureSpec.UNSPECIFIED:
        /* Parent says we can be as big as we want. Just don&apos;t be larger
           than max size imposed on ourselves.
        */
        result = Math.min(desiredSize, maxSize);
        break;
    case MeasureSpec.AT_MOST:
        // Parent says we can be as big as we want, up to specSize. 
        // Don&apos;t be larger than specSize, and don&apos;t be larger than 
        // the max size imposed on ourselves.
        result = Math.min(Math.min(desiredSize, specSize), maxSize);
        break;
    case MeasureSpec.EXACTLY:
        // No choice. Do what we are told.
        result = specSize;
        break;
}
return result;
</code></pre><p>看着代码中的注释应该很容易明白以后测量模式应该怎么用了。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/10/08/C-多态/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Tom Liu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Learning">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/10/08/C-多态/" itemprop="url">C++多态</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-10-08T08:46:44+08:00">
                2016-10-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在函数定义中有vitural关键字的函数就是虚函数，不能用在构造函数和静态函数上面。</p>
<p>虚函数只能借助于指针或者引用来达到多态的效果。</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;cstring&gt;

using namespace std;

class  A {

private:
    string name;    
public:

    A(string n):name(n) {

    }

    string getName() {
        return name;
    }

    void print() {
        cout&lt;&lt;&quot;A&quot;&lt;&lt;endl; 
    }

    virtual void hutrted() {
        cout&lt;&lt;name&lt;&lt;&quot; get hurted&quot;&lt;&lt;endl;
    }

    virtual void attack(A* a) {
        cout&lt;&lt;name&lt;&lt;&quot;attack &quot; &lt;&lt; a-&gt;getName()&lt;&lt;endl;
        a-&gt;hutrted();
    }
};

class B:public A{

public:
    B(string n):A(n) {

    } 

     void hutrted() {
        A::hutrted();
        cout&lt;&lt;&quot;this is b override hutrted&quot;&lt;&lt;endl;
    }

     void attack(A* a) {
        A::attack(a);
        cout&lt;&lt;&quot;this is b override attack&quot;&lt;&lt;endl;
    }

};

int main() {
    A* a = new A(&quot;A&quot;);
    A* b = new B(&quot;B&quot;);

    b-&gt;attack(a);

    cout&lt;&lt;&quot;---------------------&quot;&lt;&lt;endl;
    a-&gt;attack(b); 

    delete a;
    delete b;
    return 0; 
} 
</code></pre><p>在上面的例子中就实现了多态，如果将基类A 方法中的virtual关键字去掉，那么这个时候将无法实现多态。</p>
<p>虚函数的作用在于实现了动态关联，即一个类的函数调用在编译的时候并不能确定而需要在程序运行的时候决定。</p>
<p>如果将A 中的virtual关键字去掉，那么函数的调用在编译的时候即决定。无法实现多态。</p>
<p><strong>与java对比的话，在java当中只需要通过继承并且重写父类的方法即可实现多态</strong></p>
<p>在构造函数和析构函数中不会形成多态，因为这个是在编译期间就确定了其行为。在构造函数和析构函数中调用虚函数，调用的是本类中定义的函数（如果没有定义就从父类中去找）。<em>之所以这么设计是因为如果在父类的构造器中调用了虚函数，在构造子类的时候会先调用父类的构造器这个时候虚函数如果是多态，那么会调用子类的方法，但是这个时候子类还没有生成对象，这个时候调用会产生错误，析构函数同理，子类对象会先于父类对象被析构。这个时候如果在父类的析构函数中调用了虚函数，即在一个已经析构的对象上调用方法，也会产生错误</em></p>
<p><strong>虚析构函数</strong><br>看下面的这段代码</p>
<pre><code>class Super{
public:
~Super(){
    cout&lt;&lt;&quot;~Super invoked&quot;&lt;&lt;endl;
} 
};

class Son : public Super {
    ~Son(){
        cout&lt;&lt;&quot;~Son invoked&quot;&lt;&lt;endl;
    } 
}; 

int main() {
    Super* son = new Son;
    delete son; 
    return 0;
} 
</code></pre><p>当我们动态的分配内存空间给son的时候，如果使用delete删除掉son，这个时候只会调用Super的析构函数，这个时候Son的构造函数并没有得到调用，那么这就有可能造成内存泄露，为了解决这种问题，就出现了<em>虚析构函数</em></p>
<pre><code>class Super{

public:
    virtual~Super(){
        cout&lt;&lt;&quot;~Super invoked&quot;&lt;&lt;endl;
    } 
};

class Son : public Super {
    ~Son(){
        cout&lt;&lt;&quot;~Son invoked&quot;&lt;&lt;endl;
    } 
}; 
int main() {
    Super* son = new Son;
    delete son; 
    return 0;
} 
</code></pre><p>即在在父类的析构函数前加上virtual关键字。这样当我们再次调用delete son的时候，会先调用Son的析构函数在调用Super的析构函数。</p>
<p><strong>C++多态实现的原理</strong><br>在C++当中，如果一个类中包含了虚函数，那么这个类中就会存在虚函数表。并且该类的任何对象中都存在这虚函数表的指针</p>
<pre><code>class Super{
public:
    int a;
    virtual~Super(){
        cout&lt;&lt;&quot;~Super invoked&quot;&lt;&lt;endl;
    } 
};
</code></pre><p>所以当我们输出sizeof(Super)的时候，会输出16(在64位的dev C++中)，这就说明了函数表中存在其他的内容，而这个内容就是虚函数表，多态的函数调用语句被编译成一系列根据基类指针所指向对象中存放的虚函数表的地址，在虚函数表中查找虚函数的地址，并调用虚函数的指令。</p>
<p><strong>纯虚函数和抽象类</strong><br>纯虚函数是指没有函数体的虚函数，那么包含了纯虚函数的类就是抽象类了，抽象类不能生成对象（但是可以使用抽象的指针指向基类），只能作为派生类的基类来使用，并且在类的构造方法和析构函数中不能调用纯虚函数。</p>
<p>一个子类只有实现了父类当中定义的所有纯虚函数才能变成非抽象类，否则还是一个抽象类。</p>
<pre><code>class Super{
public:
    int a;
    virtual~Super(){
        cout&lt;&lt;&quot;~Super invoked&quot;&lt;&lt;endl;
    } 

    virtual void method() = 0; //纯虚函数
};

class Son : public Super {
    int b;
    ~Son(){
        cout&lt;&lt;&quot;~Son invoked&quot;&lt;&lt;endl;
    } 

    void method() { //纯虚函数实现

    }
}; 

int main() {
    Super* son = new Son;
    delete son; 
    return 0;
} 
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Tom Liu" />
          <p class="site-author-name" itemprop="name">Tom Liu</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">38</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">44</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Tom Liu</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  

  

  

  

  

</body>
</html>
