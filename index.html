<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta property="og:type" content="website">
<meta property="og:title" content="Learning">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Learning">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Learning">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>Learning</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  















  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Learning</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/20/性能优化/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Tom Liu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Learning">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/20/性能优化/" itemprop="url">性能优化</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-20T22:15:15+08:00">
                2017-08-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近在做一个相机的的APP，其中涉及到了很多以前没有接触过的知识，APP做到现在功能也都基本完成了，现在有心思把精力放在一些以前比较奇怪的代码上。</p>
<h2 id="内存优化"><a href="#内存优化" class="headerlink" title="内存优化"></a>内存优化</h2><p>在目前的实现中，相机的预览页采用了open GL 的方式来展示摄像头采集的数据，但是在根据人脸识别后的添加的sticker上还是采用了Bitmap和 canvas 实现的方式，看到了bitmap就知道内存抖动这块一定是跟它有关了</p>
<ol>
<li>问题一：sticker 资源的加载<br>在优化前实现中，采用的是通过glide同步的获取bitmap对象，同时通过一个队列来缓存加载的图片，但是这样面对的一个问题是在一个动态的sticker中，如果出现的sticker过多，那么很可能造成这个队列不够用，那么实际上造成的效果是bitmap对象根本没有办法复用。例如实际上这个队列的最大容量是 10， 但是我们有40张图片需要加载的时候，这个队列根本起不到缓存的作用，并且在sticker较大的时候还是比较大的OOM 风险。</li>
</ol>
<p>1.1 减少bitmap.<br>   首先切换了思路，我们并没有采用队列的方式来缓存所有的图片，而是针对每一个类型的sticker资源都只缓存2个bitmap，这样就内存里面关于sticker的bitmap数量最大为10个（有些类型的sticker只有一个图片资源），这样大大的减少了sticker的内存占用，在这种情况下，也基本上不会出现OOM 的风险，虽然这个时候可能会出现sticker加载慢导致的sticker掉帧情况，但是实际上这个对视觉上的影响并不大，同时加载本地资源的时候，sticker加载的速度还是很快的，并且因为在子线程执行所以这个优化方法是可以采纳的。</p>
<p>1.2 使用option.inBitmap 和 option.inMutable</p>
<p>   option.inBitmap 是ANDROID 11  之后推出的属性，通过这个属性在加载bitmap时候可以复用inBItmap 所指向对象的内存而不用重新开辟内存的占用，这个属性在不同的sdk基本上有不同的限制要求，使用的时候需要注意，因为我们的同类型的sticker序列的图片大小都是相同的，所以在使用的时候不用担心这个限制问题。</p>
<p>  option.inMutable 通过这个属性我们可以让每次返回的bitmap都是之前的同一个对象</p>
<p> 这里引用一下一篇<a href="https://juejin.im/entry/57cd1c7cbf22ec006c2e2261" target="_blank" rel="external">博客</a>的内容</p>
<blockquote>
<p>inBitmap<br>Android在API11添加的属性，用于重用已有的Bitmap，这样可以减少内存的分配与回收，提高性能。但是使用该属性存在很多限制： 在API19及以上，存在两个限制条件：<br>被复用的Bitmap必须是Mutable。违反此限制，不会抛出异常，且会返回新申请内存的Bitmap。<br>被复用的Bitmap的内存大小（通过Bitmap.getAllocationByteCount方法获得，API19及以上才有）必须大于等于被加载的Bitmap的内存大小。违反此限制，将会导致复用失败，抛出异常IllegalArgumentException(Problem decoding into existing bitmap）<br>在API11 ~ API19之间，还存在额外的限制：<br>被复用的Bitmap的宽高必须等于被加载的Bitmap的原始宽高。（注意这里是指原始宽高，即没进行缩放之前的宽高）<br>被加载Bitmap的Options.inSampleSize必须明确指定为1。<br>被加载Bitmap的Options.inPreferredConfig字段设置无效，因为会被被复用的Bitmap的inPreferredConfig值所覆盖（不然，所占内存可能就不一样了）</p>
</blockquote>
<p>1.3 使用bitmap pool</p>
<p>因为在最终的绘制到canvas的时候使用的是一个bitmap，在优化前每次都重新创建了一个bitmap对象，实际上这是没有必要的，在使用完了bitmap之后可以通过bitmap pool 缓存起来，然后再次使用，在再次使用之前通过btimap.erase() 方法来擦除之前的数据信息即可，这样就避免了每次都重复创建新的bitmap对象。</p>
<h2 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h2><p>在多线程的环境下锁的使用的确是避不开的，但是在一定条件下，是可以避免锁的使用的。例如在这次开发的APP中，摄像头的数据通过回调的方式传递过来（主线程），同时通过人脸识别的子线程对这个数据进行人脸识别的数据的处理。因为摄像头数据存放在一个类的成员变量中，主线程会进行写操作，而子线程会进行读写两个操作，在优化前两个线程操作这个数据都加上了锁。但是实际上分析一下会发现加锁的情况是可以避免的。锁的作用就是让两个操作在多线程的情况下不会交叉进行，既然是多线程的情况，我们把这个情况变成单线程的即可,在单线程的情况下就不会有这个问题了。</p>
<p>所以优化操作中，直接把子线程读写操作放到了主线程当中，这样数据的操作就避免加锁的情况。</p>
<p>通过对比前后的操作，一个方法的平均执行时间从32ms降低到了 0.4ms,优化有极大的提升。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/25/锁的可重入/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Tom Liu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Learning">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/25/锁的可重入/" itemprop="url">锁的可重入</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-25T21:50:53+08:00">
                2017-06-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>当一个线程正在请求一个被其他线程持有的锁的时候，会被挂起。但是因为锁的可重入性，一个线程再次请求被自己持有的锁，这个请求会成功。锁的可重入性意味着锁的占有是基于线程的而不是基于调用次数的。</p>
<p>锁的可重入性通过一个锁的占用计数和当前占用线程来实现，当占用计数是零的时候，这个锁会被认为是一个未被占用的锁，当一个线程请求一个未占用的锁的时候，JVM会记录占用锁的当前线程，然后设置占用计数为1. 如果当前持有线程再次请求这个锁，那么计数器将会加1. 如果当前线程退出同步块，那么锁占用计数将会减1，如果最后的占用计数为零，那么锁将会被释放</p>
<p>锁的可重入性极大的简化了面向对象编程的代码，如果没有锁的可重入性，那么一些即使看起来很简单的代码也会出错。</p>
<pre><code>public class Base {
    public synchronized void method() {

    }
}   
public class Sub extends Base {
    public synchronized void method() {
        //do something 
        super.method();
    }
}
</code></pre><p>在上面的代码中，如果没有锁的可重入性，当一个线程执行Sub的 method 方法时，首先会获取Sub当前实例的锁，当时在调用super的时候，同样需要当前实例的锁，但是这个时候第一次取得的锁并没有释放，所以这样便形成了死锁。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/25/TCP学习笔记2-滑动窗口/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Tom Liu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Learning">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/25/TCP学习笔记2-滑动窗口/" itemprop="url">TCP学习笔记2 滑动窗口</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-25T17:58:54+08:00">
                2017-06-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>TCP连接的每一端都可以收发数据，这些收发数据的管理是通过滑动窗口的结构来来维护的</p>
<h2 id="发送窗口"><a href="#发送窗口" class="headerlink" title="发送窗口"></a>发送窗口</h2><p>TCP协议以字节为单位来维护窗口，其中可以为分为三个部分</p>
<ol>
<li>已经发送并且已经收到ACK 的部分</li>
<li>已经发送但是未收到ACK 和 即将发送的部分</li>
<li>窗口移到该位置前都不可以发送的部分</li>
</ol>
<p>随着时间的推移，发送端不断的发送和接收到ACK，并且接收到接收端的窗口通告，发送端的窗口会不算的往右移动，</p>
<p>下面的三个属于描述了窗口的移动情况</p>
<ol>
<li>关闭 窗口的左边界右移，当接收到已经发送数据的ACK的时候，窗口会减小</li>
<li>打开 即窗口的右边界右移，使得可以发送的数量增大，这通常是因为接收端的处理了数据，缓存区变大，发送了一个更大的窗口通告。</li>
<li>收缩 即窗口的右边界左移，</li>
</ol>
<p>TCP的每个报文都包含ack号和窗口通告信息，TCP发送端可以根据这些信息调节窗口的大小，窗口的左边界不能向左移动，因为左边界记录的是接收端的确认信息，具有累计性不能返回。</p>
<h2 id="接收窗口"><a href="#接收窗口" class="headerlink" title="接收窗口"></a>接收窗口</h2><p>接收端也维护了一个接收窗口，窗口记录了已经接收并且确认的数据，以及能接收到的最大序列号，接收端希望避免存储重复接收的数据和已经确认的数据，并且避免存储不应该接收的数据(超过右边界的数据）</p>
<p>如果接收到了窗口左边界以左的数据，接收到的数据将会被丢弃，因为这些数据已经被确认接受过，超过了右边界的数据被认为无法处理也会被丢弃。只有当接收数据的序列号到等于左边界的时候，数据才会被接收处理，窗口才会向前滑动，对于使用了SACK的报文来说，这个窗口内的其他的报文也能被接收，但是只有接收到等于左边的数据时，窗口才会移动。</p>
<h2 id="窗口通告"><a href="#窗口通告" class="headerlink" title="窗口通告"></a>窗口通告</h2><p>通过窗口通告，TCP 的接收方可以有效的控制发送端的发送速率，当当前的窗口为零的时候，可以有效的阻止发送端发送新的数据。当接收端已经成功处理了接收到的数据，有重新可用的缓存空间的时候，就可以发送一个窗口通告给发送方，来恢复发送。这样的窗口通告通常都不包括数据，成为纯ACK，窗口通告通常采用不可靠的方式传输。</p>
<p>在接收端发送一个窗口通告的同时，发送方还可以通过窗口探测的方式查询当前可用窗口，发送方发送的窗口探测包括一个有效的字节，采用TCP的可靠传输（丢失重传），这样就避免了由窗口通告丢失导致的零窗口死锁。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/24/FFMPEG记录/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Tom Liu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Learning">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/24/FFMPEG记录/" itemprop="url">FFMPEG记录</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-24T20:50:21+08:00">
                2017-06-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>使用的两个关键命令 </p>
<pre><code>ffmpeg 
    -framerate 10 
    -start_number 1 
    -i app_imagecache/3461686%04d.png 
    -i logo.png 
    -i pa.png 
    -vframes 44 
    -filter_complex &quot;[1:v]scale=50:50[water];[0:v][water]overlay=0:0[x];[x][2:v] paletteuse,reverse&quot; 
    -y logo.gif
</code></pre><p>下面来简单的解析一下这段命令 </p>
<ul>
<li>framerate 指定生成gif的 帧率，目前ffmpeg 最快支持为 20ms/每帧，所以这里的帧率最大0为 50</li>
<li>start_number 指定图片输入序列的启示位置</li>
<li>-i  app_imagecache/3461686%04d.png 指定生成gif的 图片序列</li>
<li>-i logo.png 指定水印</li>
<li>vframes 指定帧数</li>
<li>-filter_complex “[1:v]scale=50:50[water];[0:v] [water]overlay=0:0[x];[x][2:v]paletteuse,reverse”</li>
</ul>
<p>这一段指定对输入的处理 [1:v]实际上指定了命令的中的输入参数，这里的 1 表示参数的序号，序号是基于0开始的，这里实际上指向了第二个输入参数也就是 logo.png. scale说明对这个水印的大小，这里指定了高宽为 50、接下来跟着了一个[water]这个就表示对上一个步骤处理结果的重命名，在后续的操作中就可以用这个重命名来指代。接下来使用[water] 表示上一步指定为 50:50 的这个水印 偏移量 为0:0； 接下来是[x][2:v] 这两个单独的意思都能理解，放在一起的理解应该是对将[2:v]所致的结果应用到[x]上面去，[2:v] 执行了第三个输入参数即pa.png， 后面跟着了paletteuse，加上这个是为了提升了gif图像的质量，为gif制定了一个全局的调色盘。</p>
<p>再接下来的reverse 制定了整个gif按照倒序的方式生成。</p>
<p>刚刚说到了gif的调色盘，生成的方式如下</p>
<pre><code>ffmpeg
-i source
-vf palettegen
-y palettegen.png
</code></pre><p>-i 即我们制定的生成调色盘的源文件，在项目中，我们的gif来源于视频，所以在生成调色盘的时候，这里制定为 视频的路径。</p>
<p>开发的时候遇到一个问题， 从制定的时间开始取视频帧的时候，非常的慢，因为需要从头开始解析，所以后来的做法就是先截取视频，然后截取后的视频中开始取帧。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/12/TCP学习笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Tom Liu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Learning">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/12/TCP学习笔记/" itemprop="url">TCP学习笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-12T23:47:20+08:00">
                2017-06-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>TCP 和UDP 都是运行在IP层之上的协议，但是和UDP协议很大的一个不同点是，TCP面向连接的可靠协议。面向连接是指在TCP开始传输数据之前，传输的端点之间需要先建立一条连接，然后再开始传输数据，可靠是指TCP协议中对数据的可达性作出了保证，如果在传输的过程中出现了数据丢失的情况，那么会对数据进行重传，正是因为这两个不同点，所以TCP协议比UDP协议会复杂很多，在TCP/IP协议详解一书中，花了六个章节来讲解其中的知识。其中的基本知识点包括：连接的建立，超时和重传，数据流和窗口管理，拥塞和控制.</p>
<h2 id="TCP-数据格式"><a href="#TCP-数据格式" class="headerlink" title="TCP 数据格式"></a>TCP 数据格式</h2><p>TCP的数据格式如下图所示</p>
<p><img src="http://docs.52im.net/extend/docs/book/tcpip/vol1/17/images2/52im_net_2.png" alt="此处输入图片的描述"></p>
<ol>
<li>每个TCP的头部都包含了目的地的端口号和源端口号，TCP层的端口号和IP成的ip地址，组成了一个四元组，这个四元组唯一标识一个连接。 </li>
<li>32位的序列号代表了该数据中包中第一个字节的编号。</li>
<li>32对确认号是指该数据包的发送方希望接收的下一个序列号，这个值是对当前已经接收的序列号加一所得。</li>
<li>4位的头部长度标识tcp头部的长度，这个值最大位15，每位标识32位的长度，所以TCP头部长度限制为 15 * 32(bit) = 60字节，在不带选项的情况下，头部长度为20字节。</li>
<li>当前TCP协议当中还有8位字段，分别标识 1.拥塞窗口减 2.ECN回显 3.URG 4.ACK 5.PSH 6.RST 7.SYN 8.FIN 这些置位分别在连接的不同阶段起作用</li>
</ol>
<h2 id="TCP连接的建立"><a href="#TCP连接的建立" class="headerlink" title="TCP连接的建立"></a>TCP连接的建立</h2><p>TCP连接的建立需要经典的三次握手的过程。过程如下</p>
<p><img src="http://docs.52im.net/extend/docs/book/tcpip/vol1/19/images2/52im_net_1.png" alt="此处输入图片的描述"></p>
<ol>
<li>客户端首先发送一个SYN报文(TCP头部中的SYN被置位)，并且指明自己想要连接的端口号和给定一个初始化的序列号SYN(c)。（第一次握手）</li>
<li>服务端收到这个客户端的SYN 报文之后给出一个响应，在这个响应当中，服务器给出了自己的初始化序列号SYN(s)，此时为了对确认客户端的请求，服务端会将客户端发送的序列号加一之后放在TCP头部的确认号字段当中ACK(c+1)，因此每发送一个syn，序列号都会加1.（第二次握手）</li>
<li>为了确认服务器端SYN（S），客户端会将服务器端的S + 1之后放在ACK(S+1)中，发送给服务端。（第三次握手）</li>
</ol>
<p>三次握手的过程不仅让通信的双方了解到一个连接正在建立，同时也在利用数据包的选项来交换初始序列号。</p>
<h2 id="TCP连接的断开"><a href="#TCP连接的断开" class="headerlink" title="TCP连接的断开"></a>TCP连接的断开</h2><p>与TCP 连接的建立相比，TCP 连接的断开多了一步，一共需要四个步骤。</p>
<ol>
<li>连接的主动关闭者（Client），发送一个FIN报文来表示自己想关闭连接，同时这个报文里面还包括一个ACK来确认对方最近一次发来的数据。</li>
<li>服务端接收到客户端断开的请求之后，发送一个ACK对客户端的FIN 报文做出响应，这个时候连接处于半关闭状态。</li>
<li>服务端在发送完数据之后，同样发送一个FIN给客户端，来关闭连接。</li>
<li>客户端接收到了FIN之后，对服务端的FIN做出一个响应，至此连接关闭。</li>
</ol>
<h2 id="初始化序列号"><a href="#初始化序列号" class="headerlink" title="初始化序列号"></a>初始化序列号</h2><p>TCP建立的连接的时候需要选择一个初始化序列号，这个初始化序列号随着时间的变化而变化，所以每个连接的初始化序列号都不一样。</p>
<p>TCP连接是由双方的端口和IP地址这个四元组组成，选择有效的初始化序列号可以有效避免连接超时重连后，无效的数据重新到达目的主机导致的数据混乱问题，这个时候选择有效的初始化序列号可以最大限度的避免这一问题。在双方通信的过程中，一个TCP报文只有同时具备连接四元组和当前活动窗口的序列号才会被通信双方接受。</p>
<h2 id="TCP选项"><a href="#TCP选项" class="headerlink" title="TCP选项"></a>TCP选项</h2><p>TCP的头部可以包含多个选项，常用的选项如下</p>
<ol>
<li>最大段大小选项 指的是允许从对方接收到的最大报文段，这个报文段大小只记录器数据的厂区而不包括TCP和IP包头的长度。</li>
<li>选择确认选项 这个可以帮助TCP实现快速重传，并且帮助发送方了解到接收方的空洞，</li>
<li>窗口缩放选项（待补充）</li>
<li>时间戳选项和防回绕序列 这个选项要求发送方在每一个报文中添加2-4个字节的时间戳数字，接收方会在响应中反映这些数字，这也允许发送方来测量一个RTT</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/12/JNI相关的知识点/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Tom Liu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Learning">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/12/JNI相关的知识点/" itemprop="url">JNI相关的知识点</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-12T22:24:17+08:00">
                2017-05-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="extern-“C”"><a href="#extern-“C”" class="headerlink" title="extern “C”"></a>extern “C”</h2><ol>
<li>extern是C/C++语言中表明<strong>函数和全局变量作用范围（可见性）的关键字，该关键字告诉编译器，其声明的函数和变量可以在本模块或其它模块中使用</strong>。通常，在模块的头文件中对本模块提供给其它模块引用的函数和全局变量以关键字extern声明。例如，如果模块B欲引用该模块A中定义的全局变量和函数时只需包含模块A的头文件即可。这样，模块B中调用模块A中的函数时，在编译阶段，模块B虽然找不到该函数，但是并不会报错；它会在连接阶段中从模块A编译生成的目标代码中找到此函数。</li>
</ol>
<p>与extern对应的关键字是 static，被它<strong>修饰的全局变量和函数只能在本模块中</strong>使用。因此，一个函数或变量只可能被本模块使用时，其不可能被extern “C”修饰。</p>
<ol>
<li>典型的，一个C++程序包含其它语言编写的部分代码。类似的，C++编写的代码片段可能被使用在其它语言编写的代码中。不同语言编写的代码互相调用是困难的，甚至是同一种编写的代码但不同的编译器编译的代码。例如，不同语言和同种语言的不同实现可能会在注册变量保持参数和参数在栈上的布局，这个方面不一样。</li>
</ol>
<p>为了使它们遵守统一规则，可以使用extern指定一个编译和连接规约。例如，声明C和C++标准库函数strcyp()，并指定它应该根据C的编译和连接规约来链接：</p>
<p><a href="https://pqpo.me/2017/05/31/system-loadlibrary/" target="_blank" rel="external">JNI技术</a></p>
<p>动态加载的几个知识点：</p>
<ol>
<li>System.loadLibrary会优先查找apk中的so目录，再查找系统目录，系统目录包括：/vendor/lib(64)，/system/lib(64)</li>
<li>不能使用不同的ClassLoader加载同一个动态库</li>
<li>System.loadLibrary加载过程中会调用目标库的JNI_OnLoad方法，我们可以在动态库中加一个JNI_OnLoad方法用于动态注册如果加了JNI_OnLoad方法，其的返回值为JNI_VERSION_1_2，JNI_VERSION_1_4，JNI_VERSION_1_6其一。我们一般使用JNI_VERSION_1_4即可</li>
<li>Android动态库的加载与Linux一致使用dlopen系列函数，通过动态库的句柄和函数名称来调用动态库的函数</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/06/Retrofit-源码学习/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Tom Liu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Learning">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/04/06/Retrofit-源码学习/" itemprop="url">Retrofit 源码学习</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-06T22:12:43+08:00">
                2017-04-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Retrofit的对象是通过建造者模式构建出来的</p>
<pre><code>public Retrofit build() {
  if (baseUrl == null) { //检查baseurl
    throw new IllegalStateException(&quot;Base URL required.&quot;);
  }

  okhttp3.Call.Factory callFactory = this.callFactory;
  if (callFactory == null) {
    // 如果未设置Okhttp 对象，那么使用默认的
    callFactory = new OkHttpClient(); 
  }
  Executor callbackExecutor = this.callbackExecutor;
  if (callbackExecutor == null) {
    callbackExecutor = platform.defaultCallbackExecutor();
  }
  // Make a defensive copy of the adapters and add the default Call adapter.
  List&lt;CallAdapter.Factory&gt; adapterFactories = new ArrayList&lt;&gt;(this.adapterFactories);
  adapterFactories.add(platform.defaultCallAdapterFactory(callbackExecutor));

  // Make a defensive copy of the converters.
  List&lt;Converter.Factory&gt; converterFactories = new ArrayList&lt;&gt;(this.converterFactories);

  return new Retrofit(callFactory, baseUrl, converterFactories, adapterFactories,
      callbackExecutor, validateEagerly);
}
</code></pre><p>在项目中我们定义了 TestService 这个接口</p>
<pre><code>public interface TestService {
    @GET(&quot;xxxx/{path}/data&quot;)
    Call&lt;String&gt; getData(@Path(&quot;path&quot;) String path);
}
</code></pre><p>当我们需要使用TestService 的时候只需要调用  retrofit.create 方法。</p>
<pre><code>service = retrofit.create(TestService.class);
</code></pre><p>就会得到一个TestService 的实例。</p>
<p>进入create 方法 </p>
<pre><code>public &lt;T&gt; T create(final Class&lt;T&gt; service) {
// 检查是否是一个有效的接口， 同时限定这个类只能是接口，并且没有继承其他的接口。
Utils.validateServiceInterface(service);  
if (validateEagerly) {
  eagerlyValidateMethods(service);
}
return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[] { service },
    new InvocationHandler() {
      private final Platform platform = Platform.get();

      @Override public Object invoke(Object proxy, Method method, Object... args)
          throws Throwable {
        // If the method is a method from Object then defer to normal invocation.
        if (method.getDeclaringClass() == Object.class) {
          return method.invoke(this, args);
        }
        if (platform.isDefaultMethod(method)) { // 源码中始终返回false.
          return platform.invokeDefaultMethod(method, service, proxy, args);
        }

        ServiceMethod serviceMethod = loadServiceMethod(method);
        OkHttpCall okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args);
        return serviceMethod.callAdapter.adapt(okHttpCall);
      }
    });
}
</code></pre><p> eagerlyValidateMethods(service); </p>
<p>这个方法会把service中所有的方法放在 Retrofit 实例的 Map serviceMethodCache 对象当中，供以后的调用。validateEagerly 这个参数的作用就是判断是否在首次创建Retrofit 的时候就把所有的方法都放到这个map当中，如果不是就是使用到的时候再放进去</p>
<p>这个Map 中的key 是 Method 对象，而key 是SerivceMethod 这个对象中包含了很多东西，例如baseURL, relativeUrl, headrs 等信息，可以看看源码，ServiceMethod 对象同样是通过建造者模式创建的，创建的过程如下</p>
<ol>
<li>创建一个 CallAdapter  对象</li>
<li>检查返回值类型，如果没有给定泛型中的具体类型，那么会抛出异常，例如直接返回Call 会抛出一个异常。</li>
<li>设置Response body 的转换器。</li>
<li>开始解析添加在方法上的注解，其中的注解包括了Http Method, Path, Header等信息，如果其中还包含Query Sring ,还会检查query string 是否不正确的使用@Path 注解。</li>
<li>然后再次检查是否没有添加表示Http Method的注解</li>
<li>检查是否有请求体，如果没有请求体，但是请求需要提交表单 那么会抛异常。</li>
<li>检查参数的类型，参数不能为表示泛型的通配符，必须是具体的类型</li>
<li>检查方法参数的注解，如果没有添加方法参数的注解会抛异常。</li>
<li>检查注解和方法参数注解的匹配，和使用规范注解(例如一个参数只能有一个注解)</li>
</ol>
<p>方法的最后通过<strong>动态代理</strong>的方式返回了一个实现了 service 代表接口的类。</p>
<p>这里说一下动态代理匿名内部类中 Platform， 这个对象实际上表示了不同平台，目前里面默认的有Java, Android，IOS, 根据不同的平台会有一些不同地方，例如默认的回调池， CallAdapter 如何创建（后面分析）等等。</p>
<pre><code>ServiceMethod serviceMethod = loadServiceMethod(method);
</code></pre><p>这一行代码就是前面提到的从 serviceMethodCache 这个map 对象中去取对应的方法。<br>之后创建了一个OkHttpCall 对象，OkHttpCall 实现了 Call 这个interface，进入到Call 这个interface中，上面有一段对这个类的注释：</p>
<blockquote>
<p>Call最终代表了Retrofit 发送请求到服务器然后从服务器接受一个响应，每一个call产生自己的请求和和响应，可以通过clone方法来多次实现多次请求，通过这种方式可以实现轮询或者请求失败的重试。Call 通过enqueue方法来实现异步的调用，也可以使用 execute() 来实现同步的调用，当call正在读响应或者发请求的时候可能会有IOException.</p>
</blockquote>
<p>读完这段之后，我们再来看 OkHttpCall 就会明白 OkHttpCall 只是 使用OkHttp来实现发送请求，所以Retrofit 并不是一个真正发送网络请求的库，真正实现网络请求的是okhttp，Retroif 只是在在上面实现了一层封装，提供了接口。</p>
<p>我们接着看 return serviceMethod.callAdapter.adapt(okHttpCall); </p>
<p>这里调用CallAdpater的adapt 方法返回了一个对象。</p>
<p>CallAdapter 是一个接口。</p>
<pre><code>public interface CallAdapter&lt;T&gt; {
      Type responseType();
      &lt;R&gt; T adapt(Call&lt;R&gt; call);
}
</code></pre><p>其中定义两个方法，从方法的文档中可以知道 responseType 返回响应泛型的具体类型，在TestService中就是String, 而 adapt 方法就是真正产生返回值 Call<string>的， 在文档里面说：这个方法实际上产生了 参数 call 的 一个代理。我们可以通过自定义自己的CallAdapter并且在retrofit对象构建的过程中传入，Retrofit 提供了一个默认的CallAdapter.</string></p>
<p>这个 callAdapter 对象创建的关键是在retrofit build过程中的 adapterFactories， 这是一个 CallAdapter 对象的List. </p>
<p>我们再回到Retrofit 的 build 方法当中</p>
<pre><code>Executor callbackExecutor = this.callbackExecutor;
  if (callbackExecutor == null) {
    callbackExecutor = platform.defaultCallbackExecutor();
  }

  List&lt;CallAdapter.Factory&gt; adapterFactories = new ArrayList&lt;&gt;(this.adapterFactories);
  adapterFactories.add(platform.defaultCallAdapterFactory(callbackExecutor));
</code></pre><p>callbackExecutor 这里返回对象不为空，会返回一个 MainThreadExecutor </p>
<pre><code>static class MainThreadExecutor implements Executor {
    private final Handler handler = new Handler(Looper.getMainLooper());
    @Override 
    public void execute(Runnable r) {
        handler.post(r);
    }
 }
</code></pre><p>这个熟悉android Handler 的一看就知道了</p>
<p>接下来看 platform 对象的 defaultCallAdapterFactory 方法， 传入了 callbackExecutor</p>
<p>这里 platform 对象实际上 是 Android</p>
<pre><code>static class Android extends Platform {
    ....    
    @Override 
    CallAdapter.Factory defaultCallAdapterFactory(Executor callbackExecutor) {
      return new ExecutorCallAdapterFactory(callbackExecutor);
    }
    ....
}
</code></pre><p>所以真正的 CallAdaterFactory （工厂模式创建CallAdater）在这里被构造出来。接着看 ExecutorCallAdapterFactory</p>
<p>贴关键代码</p>
<pre><code>class ExecutorCallAdapterFactory extends CallAdapter.Factory {
    ...
  @Override
  public CallAdapter&lt;Call&lt;?&gt;&gt; get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
    ...
    final Type responseType = Utils.getCallResponseType(returnType);
    return new CallAdapter&lt;Call&lt;?&gt;&gt;() {
    ...
      @Override public &lt;R&gt; Call&lt;R&gt; adapt(Call&lt;R&gt; call) {
        return new ExecutorCallbackCall&lt;&gt;(callbackExecutor, call);
      }
    };
  }
</code></pre><p>这里又是一个匿名内部类，关键的adapt 方法返回了 ExecutorCallbackCall 对象。</p>
<p>接着看 ExecutorCallbackCall， 继续部分关键代码 </p>
<pre><code>static final class ExecutorCallbackCall&lt;T&gt; implements Call&lt;T&gt; {
    final Executor callbackExecutor;
    final Call&lt;T&gt; delegate;

    ExecutorCallbackCall(Executor callbackExecutor, Call&lt;T&gt; delegate) {
      this.callbackExecutor = callbackExecutor;
      this.delegate = delegate;
    }

@Override 
public void enqueue(final Callback&lt;T&gt; callback) {
  if (callback == null) throw new NullPointerException(&quot;callback == null&quot;);
  delegate.enqueue(new Callback&lt;T&gt;() {
    @Override public void onResponse(Call&lt;T&gt; call, final Response&lt;T&gt; response) {
      callbackExecutor.execute(new Runnable() {
        @Override public void run() {
          if (delegate.isCanceled()) {
            callback.onFailure(ExecutorCallbackCall.this, new IOException(&quot;Canceled&quot;));
          } else {
            callback.onResponse(ExecutorCallbackCall.this, response);
          }
        }
      });
    }

    @Override public void onFailure(Call&lt;T&gt; call, final Throwable t) {
      callbackExecutor.execute(new Runnable() {
        @Override public void run() {
          callback.onFailure(ExecutorCallbackCall.this, t);
        }
      });
    }
  });
}
....
</code></pre><p>首先 ExecutorCallbackCall 这个类也是一个Call对象，只用看enqueue 方法，方法的实现全部都是用调用了delegate，所以这里就知道了之前CallAdapter 接口文档里面写的 adapt 方法返回的只是 adapt 方法参数 call, 的一个包装类，这里的 delegate 就是call 对象。在这个回调里面也通过 callbackExecutor （MainThreadExecutor）实现了将callback 放到主线程里面来调用。</p>
<p>分析完了callAdapter.adapt 的方法，知道他返回的是一个 OkhttpCall的包装类。</p>
<p>再接着看OkhttpCall,  看异步发送请求的实现，</p>
<pre><code>@Override
public void enqueue(final Callback&lt;T&gt; callback) {
    checkNotNull(callback, &quot;callback == null&quot;);

    okhttp3.Call call;
    Throwable failure;

    synchronized (this) {
        if (executed) // 一个请求不能重复执行
            throw new IllegalStateException(&quot;Already executed.&quot;);
        executed = true;

        call = rawCall;
        failure = creationFailure;
        if (call == null &amp;&amp; failure == null) {
            try {
                call = rawCall = createRawCall();  // ①
            } catch (Throwable t) {
                failure = creationFailure = t;
            }
        }
    }

    if (failure != null) {
        callback.onFailure(this, failure);
        return;
    }

    if (canceled) {
        call.cancel();
    }

    call.enqueue(new okhttp3.Callback() {
        .....
    });
}
</code></pre><p>① 首次执行的时候，rawCall 和 creationFailure 都为空，这个是需要创建 rawCall ， 也就是okhttp3.Call 的对象，进入到 createRawCall() 方法</p>
<pre><code>private okhttp3.Call createRawCall() throws IOException {
    Request request = serviceMethod.toRequest(args);
    okhttp3.Call call = serviceMethod.callFactory.newCall(request);
    if (call == null) {
      throw new NullPointerException(&quot;Call.Factory returned null.&quot;);
    }
    return call;
</code></pre><p>  }</p>
<p>先通过serviceMethod 创建了一个 Request 对象，</p>
<pre><code>Request toRequest(Object... args) throws IOException {
RequestBuilder requestBuilder = new RequestBuilder(httpMethod, baseUrl, relativeUrl, headers, contentType, hasBody, isFormEncoded, isMultipart);
@SuppressWarnings(&quot;unchecked&quot;) // It is an error to invoke a method with the wrong arg types.
ParameterHandler&lt;Object&gt;[] handlers = (ParameterHandler&lt;Object&gt;[]) parameterHandlers;
int argumentCount = args != null ? args.length : 0;
if (argumentCount != handlers.length) {
  throw new IllegalArgumentException(&quot;Argument count (&quot; + argumentCount
      + &quot;) doesn&apos;t match expected count (&quot; + handlers.length + &quot;)&quot;);
}
for (int p = 0; p &lt; argumentCount; p++) {
  handlers[p].apply(requestBuilder, args[p]);
}
return requestBuilder.build();
}
</code></pre><p>实际上在这里，根据我们自定义service中的方法的参数来创建了一个Okhttp 中的请求对象Requestd，其中需要注意的是， 这个构造其中的过程中完成了对配置的各项参数的处理，其中ParameterHandler 是一个抽象类，继承这个类的类需要实现</p>
<pre><code>abstract void apply(RequestBuilder builder, T value) throws IOException;
</code></pre><p>看一下Path 参数是如何被处理的，代码如下</p>
<pre><code>static final class Path&lt;T&gt; extends ParameterHandler&lt;T&gt; {
    ....
    @Override 
    void apply(RequestBuilder builder, T value) throws IOException {
      if (value == null) {
        throw new IllegalArgumentException(
            &quot;Path parameter \&quot;&quot; + name + &quot;\&quot; value must not be null.&quot;);
      }
      builder.addPathParam(name, valueConverter.convert(value), encoded);
    }
}
</code></pre><p> 最终是在 builder.addPathParam(name, valueConverter.convert(value), encoded);完成了对name(定义在url中的{name})替换。</p>
<p>最后调用requestBuilder.build() 完成了okhttp request 对象的创建。</p>
<p>在看到 createRawCall 方法当中，接下来需要用 okhttp 的 request 对象创建一个Call 对象，<br>接下来进入到 service.callFactory 的 newCall方法当中，这个方法最终的实现在OkHttpClient 这个类中，newCall直接创建了 RealCall 对象。</p>
<pre><code>final class RealCall implements Call {...}
</code></pre><p>看到 RealCall 这个对象的声明，可以看出来实际上 OkHttpCall 是一个包装类，最终实现请求的是 RealCall。</p>
<p>那么实际上OkHttpCall实现的Call的各种方法实际上都是调用RealCall的实现来完成的。</p>
<p>再回到OkhttpCall 的enqueue 方法当中，如果上述的创建请求对象的过程中出错了，那么直接调用回调的onFailure 方法。</p>
<p>接下来 会调用call的 enqueue 方法，从上面的分析可以知道 call 实际上是 RealCall的一个对象，我们直接到RealCall中去看 enqueue 方法的实现。</p>
<p>RealCall 内部重载了enqueue </p>
<pre><code>void enqueue(Callback responseCallback, boolean forWebSocket) {
    synchronized (this) {
      if (executed) throw new IllegalStateException(&quot;Already Executed&quot;);
      executed = true;
    }
    client.dispatcher().enqueue(new AsyncCall(responseCallback, forWebSocket));}
</code></pre><p>关键是调用 client.dispatcher().enqueue() 这个方法，</p>
<p>因为这个里面就涉及到 okHtpp 源码的分析，就不再深入的分析，只是简单的看下里面的代码：</p>
<pre><code>synchronized void enqueue(AsyncCall call) {
    if (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) {
      runningAsyncCalls.add(call);
      executorService().execute(call);
    } else {
      readyAsyncCalls.add(call);
    }
</code></pre><p>  }</p>
<p>AsyncCall 是一个Runnable 的对象，最终放到通过executorService方法得到的线程池中来执行。<br>不过放进去之前先判断一下当前正在执行的请求是否超过了限制，还有判断当前运行的请求队列是否有过多（大于maxRequestsPerHost）的request 请求同一个host ,如果不满足就放到等待队列中。</p>
<p>当请求完成的代码，是在AsyncCall当中。</p>
<pre><code>Override 
protected void execute() {
  boolean signalledCallback = false;
  try {
    Response response = getResponseWithInterceptorChain(forWebSocket); // ①
    if (canceled) {
      signalledCallback = true;
      responseCallback.onFailure(RealCall.this, new IOException(&quot;Canceled&quot;));
    } else {
      signalledCallback = true;
      responseCallback.onResponse(RealCall.this, response);
    }
  } catch (IOException e) {
    if (signalledCallback) {
      // Do not signal the callback twice!
      Platform.get().log(INFO, &quot;Callback failure for &quot; + toLoggableString(), e);
    } else {
      responseCallback.onFailure(RealCall.this, e);
    }
  } finally {
    client.dispatcher().finished(this);
  }
}
</code></pre><p>① 在这里我们有机会通过自己Interceptor 来处理请求和响应， 在Retrofit 中默认定义了一个 ApplicationInterceptorChain，请求从这里开始处理。</p>
<pre><code> @Override 
 public Response proceed(Request request) throws IOException {
  // If there&apos;s another interceptor in the chain, call that.
  if (index &lt; client.interceptors().size()) {
    Interceptor.Chain chain = new ApplicationInterceptorChain(index + 1, request, forWebSocket);
    Interceptor interceptor = client.interceptors().get(index);
    Response interceptedResponse interceptor.intercept(chain);

    if (interceptedResponse == null) {
      throw new NullPointerException(&quot;application interceptor &quot; + interceptor
          + &quot; returned null&quot;);
    }
    return interceptedResponse;
  }
  // No more interceptors. Do HTTP.
  return getResponse(request, forWebSocket);
}
</code></pre><p>这里实际上有一个类似递归的调用，通过不断的 改变 ApplicationInterceptorChain 的 index, 来使每个interceptor的intercept 方法调用，并且通过request 这个引用，来使request 所指向的对象得到每个拦截器的处理。这里拦截器可以想想java Web 中Servlet 中拦截器的处理。</p>
<p>接下来getResponse() 方法 就是真正发送Http请求的地方，这个里面涉及到较多okHttp 的使用，这里就不分析了，等后面看了okhttp 的源码再来说。</p>
<p>在getResponse() 中会得到一个okhttp response 的对象，根据请求的结果来回调  responseCallback 的 onFailure 和 onResponse 方法。</p>
<p>responseCallback 这个对象就是在OkHttpCall 的 enequeue 方法中 调用 RealCall enequeue 方法传入的，那么接下来在回到 OkHttpCall 的  enqueue 方法。</p>
<pre><code>public void enqueue(final Callback&lt;T&gt; callback) {
    ....

    call.enqueue(new okhttp3.Callback() {
  @Override public void onResponse(okhttp3.Call call, okhttp3.Response rawResponse)
      throws IOException {
    Response&lt;T&gt; response;
    try {
      response = parseResponse(rawResponse);
    } catch (Throwable e) {
      callFailure(e);
      return;
    }
    callSuccess(response);
  }

  @Override public void onFailure(okhttp3.Call call, IOException e) {
    try {
      callback.onFailure(OkHttpCall.this, e);
    } catch (Throwable t) {
      t.printStackTrace();
    }
  }

  private void callFailure(Throwable e) {
    try {
      callback.onFailure(OkHttpCall.this, e);
    } catch (Throwable t) {
      t.printStackTrace();
    }
  }

  private void callSuccess(Response&lt;T&gt; response) {
    try {
      callback.onResponse(OkHttpCall.this, response);
    } catch (Throwable t) {
      t.printStackTrace();
    }
  }
});
}
</code></pre><p>从这里调用我们可以简单的看出这里实际上又是Callback的一个包装，拿到okhttp3.Response 对象之后调用 parseResponse 方法，将OkHtt Response 转换为一个 Retrofit 的 Response.<br>然后调用 callSuccess 最终来回调我们使用时传入的callback.</p>
<p>到这里我们使用Retrofit 实现一个异步请求的过程就分析完成了。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/29/Java-异常处理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Tom Liu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Learning">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/03/29/Java-异常处理/" itemprop="url">Java 异常处理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-29T23:28:32+08:00">
                2017-03-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近在看Effective Java 看到了更异常相关的章节，虽然里面道理都看的懂，但是一旦要自己操作起来的时候就懵逼了，后来发现了一篇博文感觉里面写的还不错，现在翻译出来如下，附上原文的链接 <a href="http://www.javaworld.com/article/2076721/core-java/designing-with-exceptions.html?page=1" target="_blank" rel="external">Desiging with exceptions</a> </p>
<p><strong>异常的好处</strong></p>
<p>异常有不少优点，首先它可以让你将异常处理的代码和正常的代码分离，在99.9%的情况下，你可以用try 代码块来包裹你想执行的代码，然后将异常处理的代码放在catch代码块中，这样的写法将避免使你的代码看起来杂乱无章。</p>
<p>如果你觉得一个方法无法处理一个特定的错误，那么你可以通过抛出一个异常，让其他人来处理这个问题。如果你抛出了一个编译时期的异常，那么Java编译器将迫使调用者来处理指定的异常，要么通过try catch ，要么调用者自己也声明抛出异常，Java编译器对编译期间异常的强制处理，使得Java程序更加的健壮。</p>
<p><strong>什么时候抛异常</strong></p>
<p>什么时候应该抛出一个异常呢？ 可以用下面的一句话来总结</p>
<blockquote>
<p>如果你的方法遇到了无法处理的异常条件，那么抛出一个异常</p>
</blockquote>
<p>(看到这句话一定会想MDZZ….)</p>
<p>不幸的是，尽管这一句总结很好记忆，但是它并没有让你更清楚的明白这个问题，它实际上引出了另外一个问题：什么是异常条件？</p>
<p>事实上判断一个特定的事件是不是一个异常条件是一个主观上的问题，这个判断并不是总是清晰。</p>
<p>一个更加有用的总结应该是下面这句：</p>
<blockquote>
<p>在可以正常处理逻辑的情况下，不要使用异常（原文：Avoid using exceptions to indicate conditions that can reasonably be expected as part of the typical functioning of the method.）</p>
</blockquote>
<p>因此不正常的条件可以理解为一个方法中无法正常处理的部分。为了更好的理解这句话，请看下面的例子，</p>
<p><strong>示例</strong></p>
<p>作为示例，请看java.io中的两个类，FileInputStream  和 DataInputStream ，下面这段代码用FileOutputStream 来输出一个文本文件。</p>
<pre><code>import java.io.*;
class Example9a {
    public static void main(String[] args)
        throws IOException {
        if (args.length == 0) {
            System.out.println(&quot;Must give filename as first arg.&quot;);
            return;
        }
        FileInputStream in;
        try {
            in = new FileInputStream(args[0]);
        }
        catch (FileNotFoundException e) {
            System.out.println(&quot;Can&apos;t find file: &quot; + args[0]);
            return;
        }
        int ch;
        while ((ch = in.read()) != -1) {
            System.out.print((char) ch);
        }
        System.out.println();
        in.close();
    }
}
</code></pre><p>在这个示例中，read()方法没有通过使用异常来表示读取文件已经到达了文件的末尾，而是通过返回了一个特定的值 -1， 在这个方法中，到达文件的末尾是一种正常的使用场景。正常读取字节的方式就是一直读直到读到文件的末尾。</p>
<p>再来看看DataInputStream 这个类，采用不同的方式来表明到达了文件的末尾。</p>
<pre><code>import java.io.*;
class Example9b {
    public static void main(String[] args)
        throws IOException {
        if (args.length == 0) {
            System.out.println(&quot;Must give filename as first arg.&quot;);
            return;
        }
        FileInputStream fin;
        try {
            fin = new FileInputStream(args[0]);
        }
        catch (FileNotFoundException e) {
            System.out.println(&quot;Can&apos;t find file: &quot; + args[0]);
            return;
        }
        DataInputStream din = new DataInputStream(fin);
        try {
            int i;
            for (;;) {
                i = din.readInt();
                System.out.println(i);
            }
        }
        catch (EOFException e) {
        }
        fin.close();
    }
}
</code></pre><p>每次调用readInt的时候，它从流中读取四个字节，当读取到文件的末尾的时候，抛出了一个EOFException, 对于这个方法来说，抛出异常是一个合理的选择，原因如下</p>
<ul>
<li>首先，readInt()不能返回一个特定的值，因为任何一个数字都可能是一个合理的返回值，因此无法用一个特殊的数字来表明读取到了文件的末尾。</li>
<li>第二，如果readInt读到了文件的末尾，但是只有三个字节，因此抛出一个编译期异常让调用者来处理是使用这个类的一部分。因此这个类的设计者抛出了一个编译期异常让迫使调用者来处理这个异常。</li>
</ul>
<p>还有另外一种方法来表明”数据已经到达了结尾”，下面看StringTokenizer 和Stack 的例子。</p>
<pre><code>import java.io.*;
import java.util.*;
class Example9c {
    public static void main(String[] args)
        throws IOException {
        if (args.length == 0) {
            System.out.println(&quot;Must give filename as first arg.&quot;);
            return;
        }
        FileInputStream in = null;
        try {
            in = new FileInputStream(args[0]);
        }
        catch (FileNotFoundException e) {
            System.out.println(&quot;Can&apos;t find file: &quot; + args[0]);
            return;
        }
        // Read file into a StringBuffer
        StringBuffer buf = new StringBuffer();
        try {
            int ch;
            while ((ch = in.read()) != -1) {
                buf.append((char) ch);
            }
        }
        finally {
            in.close();
        }
        // Separate StringBuffer into tokens and
        // push each token into a Stack
        StringTokenizer tok = new StringTokenizer(buf.toString());
        Stack stack = new Stack();
        while (tok.hasMoreTokens()) {
            stack.push(tok.nextToken());
        }
        // Print out tokens in reverse order.
        while (!stack.empty()) {
            System.out.println((String) stack.pop());
        }
    }
}
</code></pre><p>在上面这个例子中，从一个文件中读取字节，然后将字节转换为char, 放到一个StringBuffer中，之后让StringTokenizer 使用默认的分隔符来分割字符串，并且将字符串放入到一个栈中， 下一步是用pop操作将栈中数据全部取出，因为栈是一个FILO结构，数据将会倒序输出。StringTokenizer 和Stack 都有一个条件来判断数据是否已经到达末尾。每次调用 nextToken的时候都会返回一个String, 当所有的String 对象都被返回的时候，StringTokenizer 必须表明所有的数据都被取完了，在这个示例中，null 本来可以被用作一个数据已经被取完的返回值，但是这个类的设计者采用了另外一种方式，用 hasMoreTokens() 这个方法来判断当前是否还有数据未被取完，在每次调用nextToken之前，你都需要调用hasMoreTokens() 方法。</p>
<p>在这个设计之中，类的设计者认为到达数据结构的末尾是一种正常的情况(<strong><em>原文：This approach shows that the designer did not consider reaching the end of tokens an abnormal condition， 个人理解：数据结构为空实际上是一种正常的情况，但是从一个为空的数据结构中获取数据则是处于不正常的条件，在后面会马上提到已经实际上是违反了使用这个方法的约定</em></strong>），如果你在在使用nextToken之前没有检查hasMoreTokens(), 你会遇到 NoSuchElementException，尽管这个是在已经到达数据结构末尾这种情况下抛出的，它更多的是表明了你使用这个类的方式不对， 而不是表示没有更多数据了。</p>
<p>类似的，Stack 同样有一个方法 empty(), 它表示栈中是否还有其他的元素，在你使用pop方法之前，你都需要使用empty 来判断栈中是否还有元素，如果你在使用pop()之前没有调用empty(), 如果栈中没有了其他的元素，那么你将遇到 EmptyStackException(), 尽管这个异常只会在栈为空的情况下发生，但是这个运行时异常更多的是用来表明客户端代码中出了问题，而不是提示你这个栈为空。</p>
<p><strong>异常实际上表明违反了使用约定</strong></p>
<p>上面的例子可能会让你觉得，你应该使用异常来传递一个信息而不是用其他的方式。如果从另外一个角度来思考异常，可能会让你更加清楚什么时候应该使用他们</p>
<blockquote>
<p>异常实际上表明了违反了使用的约定 （原文：Exceptions indicate a broken contract）</p>
</blockquote>
<p>在面向对象编程中，我们经常谈到的一点是Design by Contract approach. 在软件设计中，一个方法实际上代表了调用者和设计者 之间的一种约定，这种约定包括调用者必须满足前置条件，而方法本身必须满足后置条件（个人理解：调用者使用方法的时机应该正确，方法的参数应该传对，而方法本身应该能按照约定正常的处理输入然后给出输出） </p>
<p><strong>前置条件</strong></p>
<p>以String对象的charAt(int index) 为例，这个方法要求index 必须在 0 和 length -1 之间。 例如string的长度为5， 那么你的输入应该是 0 - 4.</p>
<p><strong>后置条件（Postcondition）</strong><br>String chatAt方法的后置条件是 返回index指定位置的字符，并且string本身保持不变。</p>
<p>如果调用者传入了 -1 或者大于等于 length 的参数，那么实际上是调用者 违反了约定，那么这个时候会抛出一个 StringIndexOutOfBoundsException ， 这个异常表明调用者代码有bug。</p>
<p>如果charAt 方法本身接收到了一个合法的输入，但是由于这个方法本身无法返回指定位置的字符（无法满足后置条件），同样应该抛出异常，这个异常表明了这个方法有bug或者无法处理运行时资源。</p>
<p><strong>What to Throw</strong></p>
<p>一旦你决定要抛出一个异常，那么你需要选择应该抛出哪一种异常。</p>
<p><strong>Exceptions VS errors</strong></p>
<p>一般说来你应该要使用异常而不是Error, Error 也是 Throwable的子类。有时表明JVM出了某些问题例如 OOM Error，有使用JAVA API会抛出错误，例如 java.awt.AWTError, 但是在你的代码中，应该只是用异常。</p>
<p><strong>编译期异常 VS 运行期异常</strong></p>
<p>这个问题才是一个大问题，到底是编译期异常还是运行时异常，编译期是Exception 及其子类，但是子类部分中要把RuntimeException 和 其子类排除，Error 及其子类同样也不是编译期异常。</p>
<p>如果你抛出了一个编译期异常但是并没有捕获，那么你需要在你的方法声明中加上throws， 这样调用者在使用你的代码时必须使用try catch 来处理异常或者将他自己的方法添加异常的声明，使用编译期异常将迫使调用者来处理方法可能抛出的异常。</p>
<p>如果你抛出的是一个运行期异常，那么调用者可以使用try catch 来捕获异常或者直接忽略掉异常。编译期将不会迫使调用者去处理这个异常，实际上调用者可能都不知道这个方法会抛出哪些异常。</p>
<p>简单的区别方式如下：</p>
<blockquote>
<p>如果你抛出了一个异常，并且你觉得客户端程序员可以有意识的处理这个异常，那么应该使用编译期异常</p>
</blockquote>
<p>一般来说，如果异常是想表明类的使用方式出了问题，那么这个异常因该是运行期异常。String charAt 抛出的StringIndexOutOfBoundsException 是运行期异常。String 的设计者不希望迫使调用者每次使用charAt的时候都去处理可能的错误。</p>
<p>但是 java.io.FileInputStream  的 read方法 抛出一个编译期异常，这个异常表明在读取文件的期间出现了某些问题，这个问题并不是由于客户端使用的方式不对而引起，它只是表明这个方法本身无法按照约定从文件中读取字节，类的设计者认为这种这种不正常的条件是十分普遍的。并且住够重要让调用者去处理这种情况。</p>
<p>通过上面的对比，基本上可以得出以下的结论，如果异常条件的发生是方法本身无法满足约定并且重要程度足够到需要调用者去处理，那么这个时候需要抛出一个编译器异常，迫使调用者去处理，否则抛出一个运行期异常。</p>
<p><strong>定义具体的异常</strong></p>
<p>最终你需要决定使用哪个异常类，在这里规则非常的具体，不要直接使用Exception，你应该选择现有的已经存在的可以说明你异常情况的异常类。这样调用者可以有选择的处理各种异常情况。</p>
<p>同时你可以在这些异常中嵌入你想添加的信息，但是不要靠这些信息来区分发生了什么异常。</p>
<p><strong>总结</strong></p>
<p>这篇文章最重要的一点在于，异常是用来处理不正常的条件的，当程序可以用一个正常的返回值来标志时，就不应该使用异常。 尽管异常可以可以帮助你去将异常处理代码和处理正常逻辑的代码区分开，但是不恰当的使用只会让你的代码更加难以阅读。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/28/Java-泛型/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Tom Liu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Learning">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/03/28/Java-泛型/" itemprop="url">Java 泛型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-28T22:21:52+08:00">
                2017-03-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Java中的泛型是在编译器这个级别实现的，在生成的Java字节码当中是没有泛型中的类型信息的，使用泛型的时候加上的类型参数会在编译的时候去掉，这个过程称作为类型擦除，如在代码中定义的List<object> 和 List<string>， 在编译之后都变成了List, JVM看到的只有List （所以这一点和C++中的模板是不同的，在C++中为每一个模板类生成一个类， 此外在Java中，泛型中还不支持基本类型） 而由泛型附加的类型信息对JVM来说是不可见的，Java编译器会在编译的时候尽可能发现出错的地方，但是仍然无法避免运行时刻出现的强制类型转换异常，类型擦除也是Java的泛型实现方式与C++模板机制实现方式之间的重要区别。</string></object></p>
<p>泛型的很多奇怪特性都与类型擦除有关：</p>
<ul>
<li>泛型没有自己独有的Class类对象，比如不存在List<string>.class ，只有List.class;</string></li>
<li>静态变量被泛型类所有的实例共享，例如MyClass<t> 中定义静态变量 var , 访问这个静态变量的方式任然是MyClass.var。</t></li>
<li>泛型的参数类型不能用在Java的异常处理中，以为异常处理是由JVM的 Runtime 来处理的，但是由于类型擦除，所以JVM是不知道这个类型信息的存在的，对于JVM来说都是MyException.也就无法执行对应的catche语句。(目前在Intelij IDE中，定义的一个泛型的异常直接报错(Generic class may not extends java.lang.Throwable))</li>
</ul>
<p>这些原因的根源都是泛型的类型信息只是在编译期存在的，而在程序执行的时候无法找到的。</p>
<p>但是这里又有另外一个问题了，我们在程序运行的时候明明是可以通过API 拿到另一个类的泛型信息的，<br>class 对象由这两个方法 </p>
<ul>
<li>getGenericSuperclass()</li>
<li>getGenericInterface()</li>
</ul>
<p>那么这两个类拿到的泛型信息又是从哪里获取的呢？<br>Java文件在编译之后会生成字节码文件，字节码文件的结构如下图所示</p>
<p><img src="http://img.my.csdn.net/uploads/201209/04/1346768613_6175.png" alt="此处输入图片的描述"></p>
<p>接下来，先定义两个类型， </p>
<pre><code>public class MyClass  {
    List data;
    public void setData(List data) {
        this.data = data;
    }
}
public class MyClassString {
    List&lt;String&gt; data;
    public void setData(List&lt;String&gt; data) {
        this.data = data;
    }
}
</code></pre><p>在编译完成之后，我们可以通过javap 来获取两者生成的字节码</p>
<p>运行 javap -c MyClassString 结果如下</p>
<pre><code>public class com.baidu.accweather.MyClassString {
  java.util.List&lt;java.lang.String&gt; data;
  public com.baidu.accweather.MyClassString();
    Code:
       0: aload_0
       1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V
       4: return

  public void setData(java.util.List&lt;java.lang.String&gt;);
    Code:
       0: aload_0
       1: aload_1
       2: putfield      #2                  // Field data:Ljava/util/List;
       5: return
}
</code></pre><p>运行javap  -c MyClass  结果如下</p>
<pre><code>public class com.baidu.accweather.MyClass {
  java.util.List data;
  public com.baidu.accweather.MyClass();
    Code:
       0: aload_0
       1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V
       4: return

  public void setData(java.util.List);
    Code:
       0: aload_0
       1: aload_1
       2: putfield      #2                  // Field data:Ljava/util/List;
       5: return
}
</code></pre><p>这个时候通过对比发现出列data 的声明不同之外其他的地方完全一样，特别需要注意的是在setData当中，从注释来看 data， 它的类型信息里面已经没有了泛型类型的信息。</p>
<p>接下来我们需要用 -verbose 参数打印堆栈大小、各方法的locals及args参数，以及class文件的编译版本</p>
<p>运行javap -verbose MyClassString , 其常量池的信息输出如下（MyClass 的就不贴出来了）</p>
<pre><code>   Classfile /D:/javaworkspace/AccWeather/out/production/AccWeather/com/baidu/accweather/MyClassString.class
  Last modified 2017-3-27; size 610 bytes
  MD5 checksum caaccea4d689459e3464f2088a3efb34
  Compiled from &quot;MyClassString.java&quot;
public class com.baidu.accweather.MyClassString
  SourceFile: &quot;MyClassString.java&quot;
  minor version: 0
  major version: 51
  flags: ACC_PUBLIC, ACC_SUPER
Constant pool:
   #1 = Methodref          #4.#22         //  java/lang/Object.&quot;&lt;init&gt;&quot;:()V
   #2 = Fieldref           #3.#23         //  com/baidu/accweather/MyClassString.data:Ljava/util/List;
   #3 = Class              #24            //  com/baidu/accweather/MyClassString
   #4 = Class              #25            //  java/lang/Object
   #5 = Utf8               data
   #6 = Utf8               Ljava/util/List;
   #7 = Utf8               Signature
   #8 = Utf8               Ljava/util/List&lt;Ljava/lang/String;&gt;;
   #9 = Utf8               &lt;init&gt;
  #10 = Utf8               ()V
  #11 = Utf8               Code
  #12 = Utf8               LineNumberTable
  #13 = Utf8               LocalVariableTable
  #14 = Utf8               this
  #15 = Utf8               Lcom/baidu/accweather/MyClassString;
  #16 = Utf8               setData
  #17 = Utf8               (Ljava/util/List;)V
  #18 = Utf8               LocalVariableTypeTable
  #19 = Utf8               (Ljava/util/List&lt;Ljava/lang/String;&gt;;)V
  #20 = Utf8               SourceFile
  #21 = Utf8               MyClassString.java
  #22 = NameAndType        #9:#10         //  &quot;&lt;init&gt;&quot;:()V
  #23 = NameAndType        #5:#6          //  data:Ljava/util/List;
  #24 = Utf8               com/baidu/accweather/MyClassString
  #25 = Utf8               java/lang/Object
{
  java.util.List&lt;java.lang.String&gt; data;
    flags:
    Signature: #8                           // Ljava/util/List&lt;Ljava/lang/String;&gt;;

  public com.baidu.accweather.MyClassString();
    flags: ACC_PUBLIC
    Code:
      stack=1, locals=1, args_size=1
         0: aload_0
         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V
         4: return
      LineNumberTable:
        line 8: 0
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
        0       5      0      this   Lcom/baidu/accweather/MyClassString;

  public void setData(java.util.List&lt;java.lang.String&gt;);
    flags: ACC_PUBLIC
    Code:
      stack=2, locals=2, args_size=2
         0: aload_0
         1: aload_1
         2: putfield      #2                  // Field data:Ljava/util/List;
         5: return
      LineNumberTable:
        line 12: 0
        line 13: 5
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
          0       6     0    this   Lcom/baidu/accweather/MyClassString;
          0       6     1    data   Ljava/util/List;
      LocalVariableTypeTable:
        Start  Length  Slot  Name   Signature
          0       6     1    data   Ljava/util/List&lt;Ljava/lang/String;&gt;;
    Signature: #19                          // (Ljava/util/List&lt;Ljava/lang/String;&gt;;)V
}
</code></pre><p>从setData 方法输出的信息来看， 里面有两张表，一个本地变量表，一个是变量类型表，从 LocalVariableTypeTable 中可以看出来 变量 data 的类型信息是 java/util/List<ljava lang="" string;=""><br>而最后 Signature 的属性在这里具体指明了是常量池中的#19，这里具体说明了这个方法的信息。</ljava></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/26/C-拷贝控制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Tom Liu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Learning">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/03/26/C-拷贝控制/" itemprop="url">C++拷贝控制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-26T14:50:26+08:00">
                2017-03-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>当定义一个类的时候，我们显示或者隐式的制定这个类的对象在拷贝，移动，赋值或者销毁的时候做什么，一个类通过定义五中特殊的成员函数来控制这些操作，包括 <strong>拷贝构造函数， 拷贝赋值运算符，移动构造函数，移动赋值运算符和析构函数</strong></p>
<p>拷贝和移动构造函数定义了当用同类型的另一个对象初始化本对象时做什么。<br>拷贝和移动赋值运算符定义了将一个对象赋予同类型的另一个对象时做什么。<br>析构函数定义了此类型对象销毁的时候做什么。</p>
<p><strong>拷贝构造函数</strong><br>如果一个构造函数的第一个参数子自身类型的引用，并且任何额外类型的参数都有默认值，则此构造函数是拷贝构造参数。</p>
<pre><code>class Foo {
    Foo(); // 默认构造参数
    Foo(Foo&amp; f); // 拷贝构造参数
}
</code></pre><p>一般而言，合成的拷贝构造函数会将其参数的成员逐个拷贝到正在创建的对象中，编译器从给定对象中依次将每个非 static的成员拷贝到正在创建的对象中。</p>
<p>每个成员的类型决定了它是如何拷贝的：类类型的成员会使用其拷贝构造函数，内置类型则是直接拷贝，虽然我们<strong>不能拷贝一个数组</strong>，但是合成拷贝函数会逐元素的拷贝一个数组类型的成员，如果数组元素是类类型，则使用元素的拷贝构造函数来拷贝。</p>
<p>拷贝初始化不仅发生在使用 = 定义变量的时候发生，还有以下情况 </p>
<ul>
<li>将对象作为一个实参传递给一个非引用类型的形参</li>
<li>从一个返回类型为非引用类型的函数返回一个对象(方法不能返回一个方法内对象的引用)</li>
<li>用花括号列表初始化一个数组中的元素或者一个聚合类中的成员。</li>
</ul>
<p>拷贝构造参数被从来初始化非引用类型参数，这一特性解释了为什么拷贝构造函数自己的参数必须是引用类型。如果不是，那么调用拷贝构造函数的时候，其参数有需要拷贝初始化，这样就陷入了死循环</p>
<p><em>拷贝构造函数必须是存在且可以访问的（例如不能是private）</em></p>
<pre><code>Point foo(Point p) { // 传递参数调用一次
    Point local = p;  // = 调用一次
    Point* heap = new Point(p); // 调用一次
    *heap = p; // 不会调用拷贝构造函数
    Point pa[4] = {local, *heap}; // 调用两次
    return local;
}
</code></pre><p><strong>拷贝赋值运算符（ = 操作符 ）</strong><br>与类控制其对象如何初始化一样， 类也可以控制其对象如何赋值<br>与处理拷贝构造函数一样，如果一个类未定义自己的拷贝赋值运算符，编译器会为它生成一个合成拷贝赋值运算符，合成拷贝赋值运算符返回一个指向其左侧运算对象的引用。</p>
<p><strong>析构函数</strong><br>析构函数执行与构造函数相反的工作，析构函数释放对象使用的资源，并且销毁对象的非static成员数据，析构函数是一个类的成员函数，名字由 ~ 加上类名构成，它没有返回值也没有参数，所以析构函数不能被重载。</p>
<p>在一个析构函数中首先执行函数体然后销毁成员，成员按照初始化的顺序逆序销毁。销毁类类型的成员需要执行成员自己的析构函数，内置类型没有析构函数，因此销毁内置类型成员什么也不需要做，需要注意的是，当隐式的销毁一个内置类型的成员不会delete 它所指向的对象。</p>
<p>与普通指针不同，智能指针是类类型，所有具有析构函数，只能指针成员在析构阶段会被自动销毁。</p>
<p><strong>合成析构函数</strong><br>当一个类未定义自己的析构函数时，编译器会为它定义一个合成析构函数，类似拷贝构造函数和拷贝赋值运算符，对于某些类，合成析构函数被用来阻止该类型的对象被销毁。</p>
<p>成员是在析构函数之后隐含的析构阶段被销毁的，在整个对象被销毁的过程中，析构函数作为成员销毁步骤之外的另一部分而进行鍀</p>
<p><strong>三/五法则</strong></p>
<ul>
<li>需要析构函数的类需要拷贝和赋值操作</li>
<li>需要拷贝操作的类也需要赋值操作，反之亦然</li>
</ul>
<p><strong>阻止拷贝</strong></p>
<ul>
<li>定义删除的函数，在函数的参数列表后面加上=delete,来指出我们希望将它定义为删除的。=delete通知编译器以及我们代码的读者，我们不希望定义这些成员，因此可以使用 = delete 放在拷贝参数的后面来阻止拷贝。但是需要注意的是析构函数不能使用=delete. 如果析构函数被删除，那么久无法销毁此类型的对象了，对于一个删除了析构函数的类型，编译器将不允许定义该类型的变量或者创建该类型的变量和是临时对象。对于定义了析构函数的类型，虽然我们不能定义这种类型的变量或者成员，但是可以动态的分配这种类型的对象。<br><em>本质上，当含有不可能拷贝，赋值或者销毁的成员时，类的合成拷贝控制函数就被定义成删除的、</em></li>
<li>在新的标准发布之前，类是通过将其拷贝函数和拷贝赋值运算符定义为private 来阻止拷贝。</li>
</ul>
<p><em>希望阻止拷贝的类应该使用=delete 来定义他们自己的拷贝构造函数和拷贝赋值运算符、</em></p>
<h2 id="拷贝控制和资源管理"><a href="#拷贝控制和资源管理" class="headerlink" title="拷贝控制和资源管理"></a>拷贝控制和资源管理</h2><p>通常定义类外管理资源的类，都必须定义拷贝控制成员，为了定义这些成员，我们必须定义此类对象的拷贝语义，一般来说有两种选择，可以定义拷贝操作使类的类型看起来像一个值或者像一个指针，类的行为像一个值意味着它应该有自己的状态，副本和对象完全是独立的，改变副本也不会对原有的对象由任何影响，反之亦然。 行为像指针的类则共享状态，当我们拷贝这类的对象时，副本和对象使用相同的底层数据，改变副本也会改变对象，反之亦然。</p>
<p><strong>赋值运算符</strong><br>当编写赋值运算符的时候有两点需要注意</p>
<ul>
<li>如果将一个对象赋予它自身，赋值运算符必须能正确的工作</li>
<li>大多数赋值运算符组合了析构函数和拷贝构函数的工作。</li>
</ul>
<p>当编写一个赋值运算符的饿时候，一个好的模式是现将右侧运算对象拷贝到一个局部临时变量中，当完成拷贝之后销毁左侧运算对象的现有成员就是安全的了，完成之后就可以将剩下的数据拷贝到左侧对象的成员中了。</p>
<p><strong>定义行为像指针的类</strong></p>
<p>对行为类似指针的类，我们需要为期定义拷贝构造函数和拷贝赋值运算符，来拷贝指针成员本身而不是其指向的对象，自定义的类任然需要自己的析构函数来释放接受构造函数所指向的内存，但是析构函数不能单方面的释放内存，只有当最后一个指针被销毁的时候才能释放所指向的内存。令一个类展现类似指针最好的方法就是使用shared_ptr。但是如果我们希望自己直接来管理，那么使用引用计数会是一个很好的选择。</p>
<p><em>引用计数</em><br> 引用计数的工作方式如下：</p>
<ul>
<li>除了初始化对象，每个构造函数都要创建一个引用计数，用来记录有多少对象与正在创建的对象共享状态，当我们创建一个对象的时候，只有一个对象共享状态，因此计数器的值为1</li>
<li>拷贝构造函数不分配新的计数器，而是与拷贝给定对象的数据成员，包括计数器。拷贝构造函数递增共享的计数器。</li>
<li>析构函数递减计数器，表示共享状态的对象少了一个，当一个计数器为零的时候，析构函数需要释放对象。</li>
<li>拷贝赋值运算符递增右侧运算对象的计算器，递减左侧运算对象的计数器，如果左侧运算对象的计数器为零，那么拷贝赋值运算符需要销毁对象。</li>
</ul>
<p><strong>C++ swap 函数</strong></p>
<p>在大多数时候，使用默认的swap函数就足够了， 但是对于一些自定义的类型来说就不是了，因为在默认的实现中，交换两个对象需要一次拷贝和两次赋值，但是对于某些类型来说，拷贝的代价太大，所以需要尽可能的避免拷贝，同时，在自定义的类型的成员变量中，存在成员指针，这个时候我们只需要交换指针即可，而不需要拷贝指针所指向的对象。</p>
<p><strong>移动函数</strong><br>在C++的新特性中，一个很重要的特性就是移动而非拷贝的能力，因为在很多情况下，我们在完成了拷贝之后马上就将拷贝对象原来所占用的内存销毁掉了，如果这个时候使用移动而非拷贝就可以避免一部分开销，有助于性能的提升。</p>
<p><strong>右值引用</strong></p>
<p>在新的C++标准中为了支持移动操作，添加了这一种新的引用类型，右值引用。所谓的右值引用就是必须绑定到右值上， 可以通过&amp;&amp; 来绑定到一个右值上。左值引用这右值引用有明显的区别：左值有持久的状态，而右值要么是常亮要么是求值过程中临时创建的对象。右值引用只能绑定到临时对象，那么右值引用的对象即将被销毁，而且该对象没有其他的用户=。</p>
<p>变量是一个左值，变量可以看做只有一个运算对象而没有运算符的表达式。因此我们不能将右值引用绑定到一个对象上，即使这个变量是右值引用类型也不行。</p>
<p>虽然不能直接将一个右值引用绑定到一个左值上，但是可以使用std::move() 函数来显示的将一个左值引用转换为一个右值引用。但是需要注意的一点是：调用move就意味着除了对传入的引用的赋值或者销毁外，将不再使用这个引用。在调用move之后，不能对对象的状态作任何假设。</p>
<p><strong>移动构造函数</strong><br>移动构造函数的第一个参数是该类类型的一个右值引用，除此之外所有其他的参数都应该有默认值除了完成资源的移动，移动构函数还必须保证对移动源对象的销毁操作是无害的。特别需要注意的是，一旦资源完成移动，源对象就不在只想被移动的资源。</p>
<p><strong>移动操作，标准库容器和异常</strong><br>由于移动构造函数通常只是移动资源而不分配任何资源，所以移动操作通常不会抛出任何异常。当我们需要定义一个不抛出异常的函数时，我们需要在函数声明的后面手动加上<em>noexcept</em>,如果我们不这样做，那么标准库会认为移动自定义的对象可能会抛出异常，并且为了处理这种可能性而做一些额外的工作。</p>
<p>为什么需要noexcept:</p>
<ul>
<li>虽然移动操作通常不会抛出异常，但是抛出异常是允许的</li>
<li>标准库容器能对异常发生时自身的行为提供保障</li>
</ul>
<p>比如有以下情况的存在，自定义类 </p>
<pre><code>class A {
    void * data1;
    void * data2;
}
</code></pre><p> 当需要完成移动构造函数时，如果在移动了data1 之后出现了异常，无法完成data2的移动，那么这个时候将无法满足A 自身保持不变的情况（data1已经被改变）。 另一方面，如果使用拷贝构造函数，那么这个时候无论拷贝有没有出现异常，原来的A都不会受到影响。</p>
<p> 因此为了避免这种潜在的问题，除非标准库知道元素类型在移动构造函数不会抛异常，否则在重新分配内存的过程中，它就必须使用拷贝构造函数而不是移动构造函数。如果希望标准库容器在重新分配内存的情况使用自定义的移动构造函数而不是拷贝构造函数就必须将移动构造函数声明为noexcept。</p>
<p> <strong>移动赋值运算符</strong><br> 移动赋值运算符执行与析构函数和移动构造函数相同的工作，与移动构造函数一样，如果移动赋值运算符不抛出任何异常，应该将其标记为noexcept，类似拷贝赋值运算符，移动赋值运算符必须正确处理自赋值的情况。</p>
<p> 下面是使用移动构造函数和移动赋值运算符的一个示例、</p>
<pre><code>#include &lt;string&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;utility&gt;

using namespace std;
class MyClass {

private:
    string* name;

public:
    MyClass(string * name_ = new string(&quot;MyClass....&quot;)) : name(name_) {

    }   

    MyClass(const MyClass &amp; other) {
        this-&gt;name = new string(*other.name);
        cout&lt;&lt;&quot;copy construct is invoked&quot;&lt;&lt;endl;
    }

    MyClass(MyClass &amp;&amp; right) noexcept {
        if (this != &amp;right) {
            delete name;
            this-&gt;name = right.name;
            right.name = nullptr;
        }
        cout&lt;&lt;&quot;move construct is invoked&quot;&lt;&lt;endl;
    }

    ~MyClass() {
        if (name) {
            delete name;
        }
    }

    string getString() const {
        return *name;
    }

    MyClass&amp; operator=(MyClass &amp;&amp; right) noexcept {
        if (this != &amp;right) {
            delete name;
            this-&gt;name = right.name;
            right.name = nullptr;
        }
        cout&lt;&lt;&quot;move assigment is invoked&quot;&lt;&lt;endl;
        return *this;
    }
};

int main() {
    string name = &quot;xxxxxx&quot;;
    MyClass test(&amp;name);
    MyClass test1;
    test1 = std::move(test);
    cout&lt;&lt;test1.getString()&lt;&lt;endl;
}
</code></pre><p><strong>移动后源对象必须可析够</strong></p>
<p>从一个源对象移动数据并不会销毁这个对象，但是有时候在完成移动操作之后，源对象会被销毁，因此当我们编写一个移动操作时，必须确保一个源对象进入可析够状态。</p>
<p><em>所有五个拷贝控制成员应该看做一个整体:一般说来，如果一个类定义了任何一个拷贝操作，它就应该定义所有的五个操作，如前所述，这些类必须定义拷贝构造函数，拷贝赋值运算符和析构函数才能正确工作，这些类通常拥有一个资源，而拷贝成员必须拷贝此资源，一般说来，拷贝一个资源会导致一些额外开销，在这种拷贝非必要的情况下，定义了移动构造函数和赋值运算符的类就可以避免此问题。</em></p>
<p>需要注意的是，不建议随意使用移动操作，由于一个移动源对象具有不确定状态，对其调用std::move是危险的，当调用std::move的时候，必须确定移动后源对象没有其他的用户，通过在类代码中小心使用move可以大幅提升性能。</p>
<p><strong>右值和左值引用成员函数</strong><br>在旧的标准中，不能阻止对对右值进行赋值，为了维持向后兼容性，新的标准库任然允许想右值赋值，但是在自定义的类中，可以阻止这种情况的出现。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Tom Liu" />
          <p class="site-author-name" itemprop="name">Tom Liu</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">32</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">39</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Tom Liu</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  

  

  

  

  

</body>
</html>
