<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta property="og:type" content="website">
<meta property="og:title" content="Learning">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Learning">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Learning">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>Learning</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  















  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Learning</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/22/液化效果的心得/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Tom Liu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Learning">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/22/液化效果的心得/" itemprop="url">OpenGL 片段着色器理解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-22T21:44:46+08:00">
                2017-11-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最新在做使用opengl 来实现图片的液化效果，从而为静态图片添加动态的效果。</p>
<p>可以通过一句话来总结一下实现的原理:通过片段着色器来来计算每一个像素点应该显示的颜色在纹理上的位置，从而实现修改渲染像素颜色的功能。</p>
<p>实现可以看下面的函数:</p>
<p>​            vec2 curveStretchFun(vec2 curCoord, vec2 originPosition, float radius)</p>
<p>{</p>
<p>  float currentDistance = distance(curCoord, originPosition);</p>
<p>  if (currentDistance &lt; radius) {</p>
<p>​      vec2 currentDirection = (curCoord - originPosition) / length(curCoord - originPosition);</p>
<p>​      float angle = dot(currentDirection, vec2(1, 0));</p>
<p>​      float value45 = sin(-90.0);</p>
<p>​      float value135 = sin(90.0);</p>
<p>​      if (angle &gt; value45 &amp;&amp; angle &lt; value135 &amp;&amp; currentDirection.y &gt; 0.0) {</p>
<p>​          curCoord = originPosition;</p>
<p>​          return curCoord ;</p>
<p>​      } else {</p>
<p>​        return curCoord - vec2(0, 0);</p>
<p>​      }</p>
<p>  } else {</p>
<p>​      return curCoord - vec2(0, 0);</p>
<p>  }        </p>
<p>这里传进来的curCoord 实际上是当前像素点的坐标，我们通过计算originPosition(液化作用的起始点)和当前坐标的距离判断当前像素点是否在作用范围之内，如果不在，那么就不会修改当前像素的坐标，(通过修改坐标来影响在纹理上取像素最终修改当前坐标显示的颜色)。在这个简单的方法中，我们通过吧一个范围的所有颜色全部显示为originPosition 在纹理上对应的颜色。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/23/Android实时滤镜实现原理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Tom Liu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Learning">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/23/Android实时滤镜实现原理/" itemprop="url">Android实时滤镜实现原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-23T22:24:56+08:00">
                2017-10-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>##原理##</p>
<p>在Android中，目前可以使用Opengl 来实时的预览相机界面，通过这相机的预览界面我们就可以实现滤镜的基本功能。</p>
<p>使用OpenGL 来实现相机的预览界面网上的代码很多，这里就不说了，主要记录一下使用OpenGL实现滤镜的原理。</p>
<p>在相机的预览界面中，我们通常都是相机的所采集到的数据直接渲染到了屏幕上，而我们渲染的屏幕实际上是系统默认提供的一个叫帧缓冲的地方,英文为Frame Buffer Object （FBO) ， 既然系统提供了一个默认的帧缓冲对象，那么我们也可以创建一个我们自己的帧缓冲对象，将数据绘制到我们创建的帧缓冲对象上。关于<a href="http://blog.csdn.net/xiajun07061225/article/details/7283929" target="_blank" rel="external">FBO</a>的相关概念，可以参见这篇博客。</p>
<p>通过我们自己创建的帧缓冲对象，可以附加一个或者多个纹理在这个帧缓冲区当中，最终渲染到这个Frame buffer中的数据实际上都是渲染到了纹理图像当中，既然有了这个纹理图像，那么就可以通过Fragmetn shader来实现各种滤镜的效果。</p>
<p>##实现及思考##</p>
<p>下面贴一下关键的代码</p>
<p>绘制相机预览界面的代码，在这段代码中，把相机的数据绘制到了自己创建的FBO对象当中。</p>
<pre><code>if (fbo == null) {             
    fbo = FBO.createFBO(width, height);
}

GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER, fbo.framebufferID);

GLES20.glViewport(0, 0, width, height);
GLES20.glClearColor(0, 0, 0, 0);
GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT | GLES20.GL_DEPTH_BUFFER_BIT);

GLES20.glUseProgram(mProgram);
GLES20.glActiveTexture(GLES20.GL_TEXTURE0);
GLES20.glBindTexture(GLES11Ext.GL_TEXTURE_EXTERNAL_OES, texture);

// get handle to vertex shader&apos;s vPosition member
mPositionHandle = GLES20.glGetAttribLocation(mProgram, &quot;vPosition&quot;);
beautyPosition = GLES20.glGetUniformLocation(mProgram, &quot;beauty&quot;);

GLES20.glUniform1i(beautyPosition,  isBeauty ? 1 : 0);

// Enable a handle to the triangle vertices
GLES20.glEnableVertexAttribArray(mPositionHandle);

// Prepare the &lt;insert shape here&gt; coordinate data
GLES20.glVertexAttribPointer(mPositionHandle, COORDS_PER_VERTEX, GLES20.GL_FLOAT, false, vertexStride, vertexBuffer);

mTextureCoordHandle = GLES20.glGetAttribLocation(mProgram, &quot;inputTextureCoordinate&quot;);
GLES20.glEnableVertexAttribArray(mTextureCoordHandle);


GLES20.glVertexAttribPointer(mTextureCoordHandle, COORDS_PER_VERTEX, GLES20.GL_FLOAT, false, vertexStride, textureVerticesBuffer);
GLES20.glDrawElements(GLES20.GL_TRIANGLES, drawOrder.length, GLES20.GL_UNSIGNED_SHORT, drawListBuffer);

// Disable vertex array
GLES20.glDisableVertexAttribArray(mPositionHandle);
GLES20.glDisableVertexAttribArray(mTextureCoordHandle);

// Switch to the default frame buffer
GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER, 0);`
</code></pre><p><strong>创建FBO</strong></p>
<pre><code>public class FBO {
       public int textureID;
    public int renderbuffersID;
    public int framebufferID;

    public static FBO createFBO(int width, int height) {
        FBO  fbo = new FBO();
        int[] texture = new int[1];
        int[] renderbuffersID = new int[1];
        int[] framebufferID = new int[1];

        GLES20.glGenTextures(1, texture, 0);
        GLES20.glGenFramebuffers(1, framebufferID, 0);
        GLES20.glGenRenderbuffers(1, renderbuffersID, 0);

        // renderbuffer
        GLES20.glBindRenderbuffer(GLES20.GL_RENDERBUFFER, renderbuffersID[0]);
        GLES20.glRenderbufferStorage(GLES20.GL_RENDERBUFFER, GLES20.GL_DEPTH_COMPONENT16, width, height);

        // framebuffer
        GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER, framebufferID[0]);
        GLES20.glFramebufferRenderbuffer(GLES20.GL_FRAMEBUFFER, GLES20.GL_DEPTH_ATTACHMENT, GLES20.GL_RENDERBUFFER,
                framebufferID[0]);

        GLES20.glActiveTexture(GLES20.GL_TEXTURE0);
        GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, texture[0]);
        GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_NEAREST);
        GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_LINEAR);
        GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_S, GLES20.GL_CLAMP_TO_EDGE);
        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_T, GLES20.GL_CLAMP_TO_EDGE);
        GLES20.glTexImage2D(GLES20.GL_TEXTURE_2D, 0,
                GLES20.GL_RGBA, width, height, 0,
                GLES20.GL_RGBA, GLES20.GL_UNSIGNED_BYTE,
                null);

        GLES20.glFramebufferTexture2D(GLES20.GL_FRAMEBUFFER,
                GLES20.GL_COLOR_ATTACHMENT0, GLES20.GL_TEXTURE_2D,
                texture[0], 0);
        GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER, 0);

        fbo.textureID = texture[0];
        fbo.framebufferID = framebufferID[0];
        fbo.renderbuffersID = framebufferID[0];

        return fbo;
    }
}
</code></pre><p><strong>滤镜处理</strong></p>
<p>在这一步就是将前面附加的纹理作为纹理参数传递到Fragment shader当中，然后可以实现滤镜的效果了。</p>
<p>Fragment shader代码</p>
<pre><code>precision mediump float;
varying vec2 textureCoordinate;
uniform sampler2D inputImageTexture;

void main() {
    vec4 col = texture2D(inputImageTexture, textureCoordinate);
    float h = dot(col.rgb, vec3(0.3, 0.59, 0.21));
    gl_FragColor = vec4(h, h, h, col.a);
}
</code></pre><p>滤镜代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">public void draw(int texture) &#123;</div><div class="line">    GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT | GLES20.GL_DEPTH_BUFFER_BIT);</div><div class="line"></div><div class="line">    GLES20.glActiveTexture(GLES20.GL_TEXTURE0);</div><div class="line">    GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, texture);</div><div class="line"></div><div class="line">    GLES20.glUseProgram(mProgram);</div><div class="line"></div><div class="line">    // get handle to vertex shader&apos;s vPosition member</div><div class="line">    mPositionHandle = GLES20.glGetAttribLocation(mProgram, &quot;vPosition&quot;);</div><div class="line"></div><div class="line">    // Enable a handle to the triangle vertices</div><div class="line">    GLES20.glEnableVertexAttribArray(mPositionHandle);</div><div class="line"></div><div class="line">    // Prepare the &lt;insert shape here&gt; coordinate data</div><div class="line">    GLES20.glVertexAttribPointer(mPositionHandle, COORDS_PER_VERTEX, GLES20.GL_FLOAT, false, vertexStride, vertexBuffer);</div><div class="line"></div><div class="line">    mTextureCoordHandle = GLES20.glGetAttribLocation(mProgram, &quot;inputTextureCoordinate&quot;);</div><div class="line">    GLES20.glEnableVertexAttribArray(mTextureCoordHandle);</div><div class="line"></div><div class="line">    GLES20.glVertexAttribPointer(mTextureCoordHandle, COORDS_PER_VERTEX, GLES20.GL_FLOAT, false, vertexStride, textureVerticesBuffer);</div><div class="line">    GLES20.glDrawElements(GLES20.GL_TRIANGLES, drawOrder.length, GLES20.GL_UNSIGNED_SHORT, drawListBuffer);</div><div class="line"></div><div class="line">    // Disable vertex array</div><div class="line">    GLES20.glDisableVertexAttribArray(mPositionHandle);</div><div class="line">    GLES20.glDisableVertexAttribArray(mTextureCoordHandle);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>思考</strong></p>
<p>实际上在自己实现的过程中发现应该是可以直接避免到自己创建FBO这个对象来实现简单的滤镜的效果，但是这样的话各种滤镜选择的逻辑的可能都会存在一个类当中，而且在这个绘制对应的Fragment Shader 也会存在这种需要变量和属性，但是对应的属性和变量又可能只在一个对象中用到，这就造成了部分代码文件及其臃肿，以至于根本无法扩展，而通过FBO 的方式，这样相当于形成了一个流水线的方式，我们只要拿到上一个步骤最终绘制的纹理，就可以继续拼接下一步操作，这样在整个流程中插入想要的步骤就十分容易了。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/04/Replugin-学习笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Tom Liu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Learning">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/04/Replugin-学习笔记/" itemprop="url">Replugin 学习笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-04T22:12:00+08:00">
                2017-09-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在Replugin 这个框架中，360实现了只需要hook一个点，就可实现插件化加载，而这个点就是classloader。为什么hook这个点就能解决Activity 动态加载的问题，这个就要从我们的Activity是怎么来的说起了,Activity的启动代码相当复杂，在这里就不分析了，网上有不少大神的blog都分析了这个问题，其中跟hook点最相关的就是下面的这一段。<br>这一段从ActivityThread的 performLaunchActivity 方法中摘出，</p>
<pre><code>Activity activity = null;
    try {
        java.lang.ClassLoader cl = r.packageInfo.getClassLoader();
        activity = mInstrumentation.newActivity(
                cl, component.getClassName(), r.intent);
        StrictMode.incrementExpectedActivityCount(activity.getClass());
        r.intent.setExtrasClassLoader(cl);
        r.intent.prepareToEnterProcess();
        if (r.state != null) {
            r.state.setClassLoader(cl);
        }
    } catch (Exception e) {
        if (!mInstrumentation.onException(activity, e)) {
            throw new RuntimeException(
                &quot;Unable to instantiate activity &quot; + component
                + &quot;: &quot; + e.toString(), e);
        }
    }
</code></pre><p>进入mInstrumentation 的 newActivity 方法：</p>
<pre><code>public Activity newActivity(ClassLoader cl, String className,
        Intent intent)
        throws InstantiationException, IllegalAccessException,
        ClassNotFoundException {
    return (Activity)cl.loadClass(className).newInstance();
}
</code></pre><p>看到这个方法是不是就有一种恍然大悟的感觉了，最终的Activity 实例是通过其 Activity 的class对象调用newInstance()得到的. 所以只需要控制了 Activity的class 对象， 就控制了Activity的产生，而这个class对象，正是我们可以通过hooK来解决的。</p>
<p>在这里Relugin 框架解决了Activity 怎么来的问题，同时因为Activity需要在AndroidManifest中注册，所以在使用Replugin 框架的时候，框架的插件会在生成的Apk文件中添加很多的Activity组件来作为一个个占坑，比如当我们启动的一个Activity A 的时候，Relugin 会将我们的目标Activity替换为坑位中的一个Activity AP ,但是在实际返回这个Activity目标class 对象的时候，返回的却是Activity A 的class 对象。</p>
<p>走完这个流程，Replugin 的核心原理应该就算是掌握了，虽然说得这么简单，但是其中每个步骤都相当的复杂，继续学习吧。</p>
<p>具体实现可以看下<a href="https://github.com/LNeway/PluginTest" target="_blank" rel="external">demo</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/02/Android-OpenGL-lookAt-函数/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Tom Liu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Learning">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/02/Android-OpenGL-lookAt-函数/" itemprop="url">Android OpenGL lookAt 函数</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-02T16:05:34+08:00">
                2017-09-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Android-OpenGL-3D中的LookAt的理解"><a href="#Android-OpenGL-3D中的LookAt的理解" class="headerlink" title="Android OpenGL 3D中的LookAt的理解"></a>Android OpenGL 3D中的LookAt的理解</h1><p>在opengl中的坐标空间有几种， 物体坐标，世界坐标系，相机坐标系，裁剪空间坐标系。</p>
<p>其他的几种坐标系相对好理解，这个相机坐标系反复试验才明白其中含义。</p>
<p>先来看一下安卓中GLES20中的lookatM函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Matrix.setLookAtM(mViewMatrix, 0, eyeX, eyeY, eyeZ, lookX, lookY, lookZ, upX, upY, upZ);</div></pre></td></tr></table></figure>
<p>在文档中给出的注释如下 </p>
<blockquote>
<p>Defines a viewing transformation in terms of an eye point, a center of view, and an up vector.</p>
</blockquote>
<p>看着这个注释还是没理解。</p>
<p>函数中的的参数前两个可以忽略，后面的九个参数分为三组</p>
<p><strong>第一组是眼睛在空间的坐标</strong></p>
<p>这个就是相机在一个空间直角坐标系中的绝对位置</p>
<p><strong>第二组是物体在空间中的坐标</strong></p>
<p>这个坐标就是我们看的物体在空间坐标系中的位置。</p>
<p><strong>第三组坐标实际上是相机顶部的的指向</strong></p>
<p>这里第三组参数决定了📷顶部方向，大家使用这个参数的时候可以想象一下我们自己的眼睛看东西的时候，实际上这个参数的值是（0, 1, 0）,因为把我们自己的头想象称为一个相机，那么这个相机顶部实际上永远指向的天空（假设天空是正轴方向），现在假设我们看屏幕的时候，想把屏幕倒着看，除了不旋转屏幕，我们还有一个选项就是让自己的头顶朝地，这样我们看屏幕的时候就可以实现倒着看了，那么这个时候向量的值应该是(0, -1, 0)。</p>
<p>具体的话大家可以看下面的<a href="https://github.com/LNeway/OpenGL-learning" target="_blank" rel="external">例子</a>，下面的实例中我们的物体始终都在（0, 0, 0）这个位置不变。</p>
<p><img src="../images/WechatIMG1.png" alt=""></p>
<p>第一组数据是我们眼睛的位置，目前参数值在（-2，-2，2）,也就是从立方体的一个顶点的正上方看过去的，现在（upX, upY, upZ）这组参数设定的值是(0, 1, 0), 紫红色是在图形下面的位置，按照上面的解释，如果把upY的值改为-1，表示相机顶部是向下了，那么这个时候最终看到的图形，紫红色是在图像的上部。</p>
<p><img src="../images/WechatIMG2.png" alt=""></p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ol>
<li>这个参数的设定不能和视线平行，在这个例子当中我们的向量是（-2，-2，-2）,如果设定这个up值是x * （-2, -2, -2), 那么将看不到任何图像。</li>
<li>这个值得含义是表示顶点指向的方向，所以最终含义是在方向这个意思上面，所以（0, -1, 0）和 （0, -x, 0) (x 的取值大于0) 的含义是一样的，最终看到的图像也就没有区别了。</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/27/Andorid-OpenGL-多层纹理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Tom Liu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Learning">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/27/Andorid-OpenGL-多层纹理/" itemprop="url">Andorid OpenGL 多层纹理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-27T21:26:57+08:00">
                2017-08-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在opengl 可以使用多个纹理单元，从而实现了使用多成纹理渲染，在使用的时候也需要绑定多个纹理单元，然后在GLSL中使用多个纹理绘制即可。</p>
<p>话不多少直接上代码</p>
<pre><code>public class TextureRender implements GLSurfaceView.Renderer {

private Context context;

private int program;
private final float vertext [] = {
        1, 1, 0,   // top right
        -1, 1, 0,  // top left
        -1, -1, 0, // bottom left
        1, -1, 0,  // bottom right
};

private final short position [] = {0, 1, 2, 2, 3, 0};


private FloatBuffer verextBuffer = null;
private ShortBuffer shortBuffer = null;
private FloatBuffer texBuffer;

private int v_position;
private int tex_position;
private int texture;
private int textureUniform;
private int matrix;
private int watermark;
private int watermarkUniform;

private float texure [] = {
        0f, 0f,
        1f, 0f,
        1f, 1f,
        0f, 1f };

public TextureRender(Context context){
    this.context =  context;
    verextBuffer = ByteBuffer.allocateDirect(vertext.length * 4)
            .order(ByteOrder.nativeOrder()).asFloatBuffer().put(vertext);
    verextBuffer.position(0);

    shortBuffer = ByteBuffer.allocateDirect(position.length * 2)
            .order(ByteOrder.nativeOrder()).asShortBuffer().put(position);
    shortBuffer.position(0);

    texBuffer = ByteBuffer.allocateDirect(texure.length * 4)
            .order(ByteOrder.nativeOrder()).asFloatBuffer().put(texure);
    texBuffer.position(0);
}

@Override
public void onSurfaceCreated(GL10 gl, EGLConfig config) {

    program = GLES20.glCreateProgram();
    int vertex = Util.createShade(GLES20.GL_VERTEX_SHADER,
            Util.readTextResourceFromRaw(context, R.raw.texture_vertex));
    int fragment = Util.createShade(GLES20.GL_FRAGMENT_SHADER,
            Util.readTextResourceFromRaw(context, R.raw.texture_fragment));

    GLES20.glAttachShader(program, vertex);
    GLES20.glAttachShader(program, fragment);
    GLES20.glLinkProgram(program);
    GLES20.glUseProgram(program);

    v_position = GLES20.glGetAttribLocation(program, &quot;aPos&quot;);
    GLES20.glEnableVertexAttribArray(v_position);
    GLES20.glVertexAttribPointer(v_position, 3, GLES20.GL_FLOAT, false, 12, verextBuffer);

    tex_position = GLES20.glGetAttribLocation(program, &quot;v_texCoord&quot;);
    GLES20.glEnableVertexAttribArray(tex_position);
    GLES20.glVertexAttribPointer(tex_position, 2, GLES20.GL_FLOAT, false, 0, texBuffer);

    textureUniform = GLES20.glGetUniformLocation(program, &quot;u_samplerTexture&quot;);
    GLES20.glUniform1i(textureUniform, 0);

    watermarkUniform = GLES20.glGetUniformLocation(program, &quot;watermark&quot;);
    GLES20.glUniform1i(watermarkUniform, 1);


    try {
        texture = Util.createTexture(BitmapFactory.decodeStream(context.getAssets().open(&quot;texture.png&quot;)));
        watermark = Util.createTexture(BitmapFactory.decodeStream(context.getAssets().open(&quot;watermark.png&quot;)));
    } catch (IOException e) {
        e.printStackTrace();
    }
}

@Override
public void onSurfaceChanged(GL10 gl, int width, int height) {
    GLES20.glViewport(0, 0, width, height);
    //设置相机位置
}

@Override
public void onDrawFrame(GL10 gl) {
    GLES20.glClearColor(0.0f, 0.0f, 0.0f, 0.0f);
    GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT);
    GLES20.glActiveTexture(GLES20.GL_TEXTURE0);
    GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, texture);
    GLES20.glActiveTexture(GLES20.GL_TEXTURE1);
    GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, watermark);

    // 用 glDrawElements 来绘制，mVertexIndexBuffer 指定了顶点绘制顺序
    GLES20.glDrawElements(GLES20.GL_TRIANGLES, position.length,
            GLES20.GL_UNSIGNED_SHORT, shortBuffer);
}}
</code></pre><p>下面是createTexture方法</p>
<pre><code>public static int createTexture(Bitmap bitmap) {
    int[] texture = new int[1];
    if (bitmap != null &amp;&amp; !bitmap.isRecycled()) {
        // 生成纹理
        GLES20.glGenTextures(1, texture, 0);
        // 生成纹理
        GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, texture[0]);
        GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_S, GLES20.GL_CLAMP_TO_EDGE);
        GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_T, GLES20.GL_CLAMP_TO_EDGE);

        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_LINEAR);
        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_LINEAR);

        GLUtils.texImage2D(GLES20.GL_TEXTURE_2D, 0, bitmap, 0);
        return texture[0];
    }

    return 0;
}
</code></pre><p><strong>顶点着色器</strong></p>
<pre><code>attribute vec3 aPos;
attribute vec2 v_texCoord;
varying vec2 outTexCoord;
void main() {
    gl_Position =  vec4(aPos, 1.0);
    outTexCoord = v_texCoord;
}
</code></pre><p><strong>片段着色器</strong></p>
<pre><code>precision mediump float;
varying vec2 outTexCoord;
uniform sampler2D u_samplerTexture;
uniform sampler2D watermark;
void main(){
 gl_FragColor = mix(texture2D(u_samplerTexture, outTexCoord) * vec4(0, 1, 0, 1),           texture2D(watermark, vec2(1.0 - outTexCoord.x, outTexCoord.y)), 0.2);
}
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/20/性能优化/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Tom Liu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Learning">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/20/性能优化/" itemprop="url">性能优化</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-20T22:15:15+08:00">
                2017-08-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近在做一个相机的的APP，其中涉及到了很多以前没有接触过的知识，APP做到现在功能也都基本完成了，现在有心思把精力放在一些以前比较奇怪的代码上。</p>
<h2 id="内存优化"><a href="#内存优化" class="headerlink" title="内存优化"></a>内存优化</h2><p>在目前的实现中，相机的预览页采用了open GL 的方式来展示摄像头采集的数据，但是在根据人脸识别后的添加的sticker上还是采用了Bitmap和 canvas 实现的方式，看到了bitmap就知道内存抖动这块一定是跟它有关了</p>
<ol>
<li>问题一：sticker 资源的加载<br>在优化前实现中，采用的是通过glide同步的获取bitmap对象，同时通过一个队列来缓存加载的图片，但是这样面对的一个问题是在一个动态的sticker中，如果出现的sticker过多，那么很可能造成这个队列不够用，那么实际上造成的效果是bitmap对象根本没有办法复用。例如实际上这个队列的最大容量是 10， 但是我们有40张图片需要加载的时候，这个队列根本起不到缓存的作用，并且在sticker较大的时候还是比较大的OOM 风险。</li>
</ol>
<p>1.1 减少bitmap.<br>   首先切换了思路，我们并没有采用队列的方式来缓存所有的图片，而是针对每一个类型的sticker资源都只缓存2个bitmap，这样就内存里面关于sticker的bitmap数量最大为10个（有些类型的sticker只有一个图片资源），这样大大的减少了sticker的内存占用，在这种情况下，也基本上不会出现OOM 的风险，虽然这个时候可能会出现sticker加载慢导致的sticker掉帧情况，但是实际上这个对视觉上的影响并不大，同时加载本地资源的时候，sticker加载的速度还是很快的，并且因为在子线程执行所以这个优化方法是可以采纳的。</p>
<p>1.2 使用option.inBitmap 和 option.inMutable</p>
<p>   option.inBitmap 是ANDROID 11  之后推出的属性，通过这个属性在加载bitmap时候可以复用inBItmap 所指向对象的内存而不用重新开辟内存的占用，这个属性在不同的sdk基本上有不同的限制要求，使用的时候需要注意，因为我们的同类型的sticker序列的图片大小都是相同的，所以在使用的时候不用担心这个限制问题。</p>
<p>  option.inMutable 通过这个属性我们可以让每次返回的bitmap都是之前的同一个对象</p>
<p> 这里引用一下一篇<a href="https://juejin.im/entry/57cd1c7cbf22ec006c2e2261" target="_blank" rel="external">博客</a>的内容</p>
<blockquote>
<p>inBitmap<br>Android在API11添加的属性，用于重用已有的Bitmap，这样可以减少内存的分配与回收，提高性能。但是使用该属性存在很多限制： 在API19及以上，存在两个限制条件：<br>被复用的Bitmap必须是Mutable。违反此限制，不会抛出异常，且会返回新申请内存的Bitmap。<br>被复用的Bitmap的内存大小（通过Bitmap.getAllocationByteCount方法获得，API19及以上才有）必须大于等于被加载的Bitmap的内存大小。违反此限制，将会导致复用失败，抛出异常IllegalArgumentException(Problem decoding into existing bitmap）<br>在API11 ~ API19之间，还存在额外的限制：<br>被复用的Bitmap的宽高必须等于被加载的Bitmap的原始宽高。（注意这里是指原始宽高，即没进行缩放之前的宽高）<br>被加载Bitmap的Options.inSampleSize必须明确指定为1。<br>被加载Bitmap的Options.inPreferredConfig字段设置无效，因为会被被复用的Bitmap的inPreferredConfig值所覆盖（不然，所占内存可能就不一样了）</p>
</blockquote>
<p>1.3 使用bitmap pool</p>
<p>因为在最终的绘制到canvas的时候使用的是一个bitmap，在优化前每次都重新创建了一个bitmap对象，实际上这是没有必要的，在使用完了bitmap之后可以通过bitmap pool 缓存起来，然后再次使用，在再次使用之前通过btimap.erase() 方法来擦除之前的数据信息即可，这样就避免了每次都重复创建新的bitmap对象。</p>
<h2 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h2><p>在多线程的环境下锁的使用的确是避不开的，但是在一定条件下，是可以避免锁的使用的。例如在这次开发的APP中，摄像头的数据通过回调的方式传递过来（主线程），同时通过人脸识别的子线程对这个数据进行人脸识别的数据的处理。因为摄像头数据存放在一个类的成员变量中，主线程会进行写操作，而子线程会进行读写两个操作，在优化前两个线程操作这个数据都加上了锁。但是实际上分析一下会发现加锁的情况是可以避免的。锁的作用就是让两个操作在多线程的情况下不会交叉进行，既然是多线程的情况，我们把这个情况变成单线程的即可,在单线程的情况下就不会有这个问题了。</p>
<p>所以优化操作中，直接把子线程读写操作放到了主线程当中，这样数据的操作就避免加锁的情况。</p>
<p>通过对比前后的操作，一个方法的平均执行时间从32ms降低到了 0.4ms,优化有极大的提升。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/25/锁的可重入/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Tom Liu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Learning">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/25/锁的可重入/" itemprop="url">锁的可重入</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-25T21:50:53+08:00">
                2017-06-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>当一个线程正在请求一个被其他线程持有的锁的时候，会被挂起。但是因为锁的可重入性，一个线程再次请求被自己持有的锁，这个请求会成功。锁的可重入性意味着锁的占有是基于线程的而不是基于调用次数的。</p>
<p>锁的可重入性通过一个锁的占用计数和当前占用线程来实现，当占用计数是零的时候，这个锁会被认为是一个未被占用的锁，当一个线程请求一个未占用的锁的时候，JVM会记录占用锁的当前线程，然后设置占用计数为1. 如果当前持有线程再次请求这个锁，那么计数器将会加1. 如果当前线程退出同步块，那么锁占用计数将会减1，如果最后的占用计数为零，那么锁将会被释放</p>
<p>锁的可重入性极大的简化了面向对象编程的代码，如果没有锁的可重入性，那么一些即使看起来很简单的代码也会出错。</p>
<pre><code>public class Base {
    public synchronized void method() {

    }
}   
public class Sub extends Base {
    public synchronized void method() {
        //do something 
        super.method();
    }
}
</code></pre><p>在上面的代码中，如果没有锁的可重入性，当一个线程执行Sub的 method 方法时，首先会获取Sub当前实例的锁，当时在调用super的时候，同样需要当前实例的锁，但是这个时候第一次取得的锁并没有释放，所以这样便形成了死锁。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/25/TCP学习笔记2-滑动窗口/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Tom Liu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Learning">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/25/TCP学习笔记2-滑动窗口/" itemprop="url">TCP学习笔记2 滑动窗口</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-25T17:58:54+08:00">
                2017-06-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>TCP连接的每一端都可以收发数据，这些收发数据的管理是通过滑动窗口的结构来来维护的</p>
<h2 id="发送窗口"><a href="#发送窗口" class="headerlink" title="发送窗口"></a>发送窗口</h2><p>TCP协议以字节为单位来维护窗口，其中可以为分为三个部分</p>
<ol>
<li>已经发送并且已经收到ACK 的部分</li>
<li>已经发送但是未收到ACK 和 即将发送的部分</li>
<li>窗口移到该位置前都不可以发送的部分</li>
</ol>
<p>随着时间的推移，发送端不断的发送和接收到ACK，并且接收到接收端的窗口通告，发送端的窗口会不算的往右移动，</p>
<p>下面的三个属于描述了窗口的移动情况</p>
<ol>
<li>关闭 窗口的左边界右移，当接收到已经发送数据的ACK的时候，窗口会减小</li>
<li>打开 即窗口的右边界右移，使得可以发送的数量增大，这通常是因为接收端的处理了数据，缓存区变大，发送了一个更大的窗口通告。</li>
<li>收缩 即窗口的右边界左移，</li>
</ol>
<p>TCP的每个报文都包含ack号和窗口通告信息，TCP发送端可以根据这些信息调节窗口的大小，窗口的左边界不能向左移动，因为左边界记录的是接收端的确认信息，具有累计性不能返回。</p>
<h2 id="接收窗口"><a href="#接收窗口" class="headerlink" title="接收窗口"></a>接收窗口</h2><p>接收端也维护了一个接收窗口，窗口记录了已经接收并且确认的数据，以及能接收到的最大序列号，接收端希望避免存储重复接收的数据和已经确认的数据，并且避免存储不应该接收的数据(超过右边界的数据）</p>
<p>如果接收到了窗口左边界以左的数据，接收到的数据将会被丢弃，因为这些数据已经被确认接受过，超过了右边界的数据被认为无法处理也会被丢弃。只有当接收数据的序列号到等于左边界的时候，数据才会被接收处理，窗口才会向前滑动，对于使用了SACK的报文来说，这个窗口内的其他的报文也能被接收，但是只有接收到等于左边的数据时，窗口才会移动。</p>
<h2 id="窗口通告"><a href="#窗口通告" class="headerlink" title="窗口通告"></a>窗口通告</h2><p>通过窗口通告，TCP 的接收方可以有效的控制发送端的发送速率，当当前的窗口为零的时候，可以有效的阻止发送端发送新的数据。当接收端已经成功处理了接收到的数据，有重新可用的缓存空间的时候，就可以发送一个窗口通告给发送方，来恢复发送。这样的窗口通告通常都不包括数据，成为纯ACK，窗口通告通常采用不可靠的方式传输。</p>
<p>在接收端发送一个窗口通告的同时，发送方还可以通过窗口探测的方式查询当前可用窗口，发送方发送的窗口探测包括一个有效的字节，采用TCP的可靠传输（丢失重传），这样就避免了由窗口通告丢失导致的零窗口死锁。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/24/FFMPEG记录/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Tom Liu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Learning">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/24/FFMPEG记录/" itemprop="url">FFMPEG记录</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-24T20:50:21+08:00">
                2017-06-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>使用的两个关键命令 </p>
<pre><code>ffmpeg 
    -framerate 10 
    -start_number 1 
    -i app_imagecache/3461686%04d.png 
    -i logo.png 
    -i pa.png 
    -vframes 44 
    -filter_complex &quot;[1:v]scale=50:50[water];[0:v][water]overlay=0:0[x];[x][2:v] paletteuse,reverse&quot; 
    -y logo.gif
</code></pre><p>下面来简单的解析一下这段命令 </p>
<ul>
<li>framerate 指定生成gif的 帧率，目前ffmpeg 最快支持为 20ms/每帧，所以这里的帧率最大0为 50</li>
<li>start_number 指定图片输入序列的启示位置</li>
<li>-i  app_imagecache/3461686%04d.png 指定生成gif的 图片序列</li>
<li>-i logo.png 指定水印</li>
<li>vframes 指定帧数</li>
<li>-filter_complex “[1:v]scale=50:50[water];[0:v] [water]overlay=0:0[x];[x][2:v]paletteuse,reverse”</li>
</ul>
<p>这一段指定对输入的处理 [1:v]实际上指定了命令的中的输入参数，这里的 1 表示参数的序号，序号是基于0开始的，这里实际上指向了第二个输入参数也就是 logo.png. scale说明对这个水印的大小，这里指定了高宽为 50、接下来跟着了一个[water]这个就表示对上一个步骤处理结果的重命名，在后续的操作中就可以用这个重命名来指代。接下来使用[water] 表示上一步指定为 50:50 的这个水印 偏移量 为0:0； 接下来是[x][2:v] 这两个单独的意思都能理解，放在一起的理解应该是对将[2:v]所致的结果应用到[x]上面去，[2:v] 执行了第三个输入参数即pa.png， 后面跟着了paletteuse，加上这个是为了提升了gif图像的质量，为gif制定了一个全局的调色盘。</p>
<p>再接下来的reverse 制定了整个gif按照倒序的方式生成。</p>
<p>刚刚说到了gif的调色盘，生成的方式如下</p>
<pre><code>ffmpeg
-i source
-vf palettegen
-y palettegen.png
</code></pre><p>-i 即我们制定的生成调色盘的源文件，在项目中，我们的gif来源于视频，所以在生成调色盘的时候，这里制定为 视频的路径。</p>
<p>开发的时候遇到一个问题， 从制定的时间开始取视频帧的时候，非常的慢，因为需要从头开始解析，所以后来的做法就是先截取视频，然后截取后的视频中开始取帧。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/12/TCP学习笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Tom Liu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Learning">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/12/TCP学习笔记/" itemprop="url">TCP学习笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-12T23:47:20+08:00">
                2017-06-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>TCP 和UDP 都是运行在IP层之上的协议，但是和UDP协议很大的一个不同点是，TCP面向连接的可靠协议。面向连接是指在TCP开始传输数据之前，传输的端点之间需要先建立一条连接，然后再开始传输数据，可靠是指TCP协议中对数据的可达性作出了保证，如果在传输的过程中出现了数据丢失的情况，那么会对数据进行重传，正是因为这两个不同点，所以TCP协议比UDP协议会复杂很多，在TCP/IP协议详解一书中，花了六个章节来讲解其中的知识。其中的基本知识点包括：连接的建立，超时和重传，数据流和窗口管理，拥塞和控制.</p>
<h2 id="TCP-数据格式"><a href="#TCP-数据格式" class="headerlink" title="TCP 数据格式"></a>TCP 数据格式</h2><p>TCP的数据格式如下图所示</p>
<p><img src="http://docs.52im.net/extend/docs/book/tcpip/vol1/17/images2/52im_net_2.png" alt="此处输入图片的描述"></p>
<ol>
<li>每个TCP的头部都包含了目的地的端口号和源端口号，TCP层的端口号和IP成的ip地址，组成了一个四元组，这个四元组唯一标识一个连接。 </li>
<li>32位的序列号代表了该数据中包中第一个字节的编号。</li>
<li>32对确认号是指该数据包的发送方希望接收的下一个序列号，这个值是对当前已经接收的序列号加一所得。</li>
<li>4位的头部长度标识tcp头部的长度，这个值最大位15，每位标识32位的长度，所以TCP头部长度限制为 15 * 32(bit) = 60字节，在不带选项的情况下，头部长度为20字节。</li>
<li>当前TCP协议当中还有8位字段，分别标识 1.拥塞窗口减 2.ECN回显 3.URG 4.ACK 5.PSH 6.RST 7.SYN 8.FIN 这些置位分别在连接的不同阶段起作用</li>
</ol>
<h2 id="TCP连接的建立"><a href="#TCP连接的建立" class="headerlink" title="TCP连接的建立"></a>TCP连接的建立</h2><p>TCP连接的建立需要经典的三次握手的过程。过程如下</p>
<p><img src="http://docs.52im.net/extend/docs/book/tcpip/vol1/19/images2/52im_net_1.png" alt="此处输入图片的描述"></p>
<ol>
<li>客户端首先发送一个SYN报文(TCP头部中的SYN被置位)，并且指明自己想要连接的端口号和给定一个初始化的序列号SYN(c)。（第一次握手）</li>
<li>服务端收到这个客户端的SYN 报文之后给出一个响应，在这个响应当中，服务器给出了自己的初始化序列号SYN(s)，此时为了对确认客户端的请求，服务端会将客户端发送的序列号加一之后放在TCP头部的确认号字段当中ACK(c+1)，因此每发送一个syn，序列号都会加1.（第二次握手）</li>
<li>为了确认服务器端SYN（S），客户端会将服务器端的S + 1之后放在ACK(S+1)中，发送给服务端。（第三次握手）</li>
</ol>
<p>三次握手的过程不仅让通信的双方了解到一个连接正在建立，同时也在利用数据包的选项来交换初始序列号。</p>
<h2 id="TCP连接的断开"><a href="#TCP连接的断开" class="headerlink" title="TCP连接的断开"></a>TCP连接的断开</h2><p>与TCP 连接的建立相比，TCP 连接的断开多了一步，一共需要四个步骤。</p>
<ol>
<li>连接的主动关闭者（Client），发送一个FIN报文来表示自己想关闭连接，同时这个报文里面还包括一个ACK来确认对方最近一次发来的数据。</li>
<li>服务端接收到客户端断开的请求之后，发送一个ACK对客户端的FIN 报文做出响应，这个时候连接处于半关闭状态。</li>
<li>服务端在发送完数据之后，同样发送一个FIN给客户端，来关闭连接。</li>
<li>客户端接收到了FIN之后，对服务端的FIN做出一个响应，至此连接关闭。</li>
</ol>
<h2 id="初始化序列号"><a href="#初始化序列号" class="headerlink" title="初始化序列号"></a>初始化序列号</h2><p>TCP建立的连接的时候需要选择一个初始化序列号，这个初始化序列号随着时间的变化而变化，所以每个连接的初始化序列号都不一样。</p>
<p>TCP连接是由双方的端口和IP地址这个四元组组成，选择有效的初始化序列号可以有效避免连接超时重连后，无效的数据重新到达目的主机导致的数据混乱问题，这个时候选择有效的初始化序列号可以最大限度的避免这一问题。在双方通信的过程中，一个TCP报文只有同时具备连接四元组和当前活动窗口的序列号才会被通信双方接受。</p>
<h2 id="TCP选项"><a href="#TCP选项" class="headerlink" title="TCP选项"></a>TCP选项</h2><p>TCP的头部可以包含多个选项，常用的选项如下</p>
<ol>
<li>最大段大小选项 指的是允许从对方接收到的最大报文段，这个报文段大小只记录器数据的厂区而不包括TCP和IP包头的长度。</li>
<li>选择确认选项 这个可以帮助TCP实现快速重传，并且帮助发送方了解到接收方的空洞，</li>
<li>窗口缩放选项（待补充）</li>
<li>时间戳选项和防回绕序列 这个选项要求发送方在每一个报文中添加2-4个字节的时间戳数字，接收方会在响应中反映这些数字，这也允许发送方来测量一个RTT</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Tom Liu" />
          <p class="site-author-name" itemprop="name">Tom Liu</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">37</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">43</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Tom Liu</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  

  

  

  

  

</body>
</html>
